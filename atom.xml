<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://annecoding.github.io/"/>
  <updated>2019-09-04T06:00:41.086Z</updated>
  <id>https://annecoding.github.io/</id>
  
  <author>
    <name>Annecoding&#39;s</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux使用expect批量执行主机命令</title>
    <link href="https://annecoding.github.io/2019/09/04/linux%E4%BD%BF%E7%94%A8expect%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C%E4%B8%BB%E6%9C%BA%E5%91%BD%E4%BB%A4/"/>
    <id>https://annecoding.github.io/2019/09/04/linux使用expect批量执行主机命令/</id>
    <published>2019-09-04T02:57:10.000Z</published>
    <updated>2019-09-04T06:00:41.086Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>现在有两台Linux主机A和B，如何从A主机ssh到B主机，然后在B主机上执行命令，如何使这个过程实现全程自动化？之前有用过<strong>ssh-copy-id免密钥</strong>的形式，这里是用第二种方式<strong>expect</strong>实现。</p><a id="more"></a><h3 id="expect是什么"><a href="#expect是什么" class="headerlink" title="expect是什么"></a>expect是什么</h3><p>expect是一个免费的编程工具，用来<strong>实现自动的交互式任务，而无需人为干预。</strong> 说白了，expect就是一套用来实现自动交互功能的软件。</p><p>在实际工作中，我们运行命令、脚本或程序时，这些命令、脚本或程序都需要从终端输入某些继续运行的指令，而这些输入都需要人为的手工进行。而<strong>利用expect，则可以根据程序的提示，模拟标准输入提供给程序，从而实现自动化交互执行。</strong> 这就是expect！！！</p><p>1.安装expect</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install expect -y</span><br></pre></td></tr></table></figure><p>2.使用expect，基本上都是和以下四个命令打交道：</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>send</td><td>用于向进程发送字符串</td></tr><tr><td>expect</td><td>从进程接收字符串</td></tr><tr><td>spawn</td><td>启动新的进程</td></tr><tr><td>interact</td><td>允许用户交互</td></tr></tbody></table><p><code>send</code>命令接收一个<strong>字符串参数</strong>，并将该参数发送到进程。</p><p><code>expect</code>命令和<code>send</code>命令相反，<code>expect</code>通常用来等待一个进程的反馈，我们根据进程的反馈，再发送对应的交互命令。</p><p><code>spawn</code>命令用来<strong>启动新的进程</strong>，<code>spawn</code>后的<code>send</code>和<code>expect</code>命令都是和使用<code>spawn</code>打开的进程进行交互。</p><p>interact命令用的其实不是很多，一般情况下使用<code>spawn</code>、<code>send</code>和<code>expect</code>命令就可以很好的完成我们的任务；但在一些特殊场合下还是需要使用<code>interact</code>命令的，<code>interact</code>命令主要用于退出自动化，进入人工交互。比如我们使用<code>spawn</code>、<code>send</code>和<code>expect</code>命令完成了ftp登陆主机，执行下载文件任务，但是我们希望在文件下载结束以后，仍然可以停留在ftp命令行状态，以便手动的执行后续命令，此时使用<code>interact</code>命令就可以很好的完成这个任务。</p><h3 id="ssh免密登录"><a href="#ssh免密登录" class="headerlink" title="ssh免密登录"></a>ssh免密登录</h3><p>1.实现ssh登录执行命令，脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">SERVER=<span class="string">"192.168.1.241"</span></span><br><span class="line">PASSWD=nf123456</span><br><span class="line">expect -c <span class="string">"</span></span><br><span class="line"><span class="string">        set timeout -1;</span></span><br><span class="line"><span class="string">        spawn ssh <span class="variable">$SERVER</span>;</span></span><br><span class="line"><span class="string">        expect &#123;</span></span><br><span class="line"><span class="string">                \"yes/no\" &#123; send \"yes\r\" ;exp_contine; &#125;</span></span><br><span class="line"><span class="string">                \"password:\" &#123; send \"<span class="variable">$PASSWD</span>\r\"; &#125;</span></span><br><span class="line"><span class="string">        &#125;;</span></span><br><span class="line"><span class="string">        expect \"]#\" &#123; send \"ls -la \r\" &#125;;</span></span><br><span class="line"><span class="string">        expect \"]#\" &#123; send \"exit \r\" &#125;;</span></span><br><span class="line"><span class="string">        expect eof;</span></span><br><span class="line"><span class="string">        "</span></span><br></pre></td></tr></table></figure><p>上面的shell功能和expect脚本实现的功能一致，都是通过ssh登录进去后输入，执行<code>ls -la</code>命令，其中</p><p><code>set timeout -1</code>设置超时时间</p><p><code>expect</code>后面需要加上-c</p><p><code>expect</code>命令用“双引号包围起来的，这点要注意，里面如果有”需要用\”转义</p><p><code>ls -la</code>代表命令结束后发送一个退出命令，一般需要加上，防止阻塞</p><p><code>expect eof</code>匹配spawn结束</p><p>2.ssh批量免密demo，脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">SERVERS=<span class="string">"192.168.1.241 192.168.1.242"</span></span><br><span class="line">PASSWD=<span class="string">"123456"</span></span><br><span class="line"><span class="keyword">function</span> sshcopyid</span><br><span class="line">&#123;</span><br><span class="line">        expect -c <span class="string">"</span></span><br><span class="line"><span class="string">                set timeout -1;</span></span><br><span class="line"><span class="string">                spawn ssh-copy-id <span class="variable">$1</span>;</span></span><br><span class="line"><span class="string">                expect &#123;</span></span><br><span class="line"><span class="string">                        \"yes/no\" &#123; send \"yes\r\" ;exp_contine; &#125;</span></span><br><span class="line"><span class="string">                        \"password:\" &#123; send \"<span class="variable">$PASSWD</span>\r\";exp_continue; &#125;</span></span><br><span class="line"><span class="string">                &#125;;</span></span><br><span class="line"><span class="string">                expect eof;</span></span><br><span class="line"><span class="string">        "</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> server <span class="keyword">in</span> <span class="variable">$SERVERS</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        sshcopyid <span class="variable">$server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="批量执行主机命令"><a href="#批量执行主机命令" class="headerlink" title="批量执行主机命令"></a>批量执行主机命令</h3><p>1.存储在host.info的主机信息如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat host.info </span><br><span class="line">192.168.1.3 root 22 111111</span><br></pre></td></tr></table></figure><p>2.linux下批量执行主机命令实现脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ cat batch_host.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 接收所传所有参数</span></span><br><span class="line">COMMAND=$*</span><br><span class="line">HOST_INFO=host.info</span><br><span class="line"><span class="comment"># 不匹配文件中的注释</span></span><br><span class="line"><span class="keyword">for</span> IP <span class="keyword">in</span> $(awk <span class="string">'/^[^#]/&#123;print $1&#125;'</span> <span class="variable">$HOST_INFO</span>);<span class="keyword">do</span></span><br><span class="line">        USER=$(awk -v ip=<span class="variable">$IP</span> <span class="string">'ip=$1&#123;print $2&#125;'</span> <span class="variable">$HOST_INFO</span>)</span><br><span class="line">        PORT=$(awk -v ip=<span class="variable">$IP</span> <span class="string">'ip=$1&#123;print $3&#125;'</span> <span class="variable">$HOST_INFO</span>)</span><br><span class="line">        PASS=$(awk -v ip=<span class="variable">$IP</span> <span class="string">'ip=$1&#123;print $4&#125;'</span> <span class="variable">$HOST_INFO</span>)</span><br><span class="line">        <span class="comment"># expect -c执行自身的语句</span></span><br><span class="line">        <span class="comment"># 因为外面有双引号，再次出现都需要转义</span></span><br><span class="line">        <span class="comment"># 执行完命令要退出</span></span><br><span class="line">        expect -c <span class="string">"</span></span><br><span class="line"><span class="string">                spawn ssh -p <span class="variable">$PORT</span> <span class="variable">$USER</span>@<span class="variable">$IP</span></span></span><br><span class="line"><span class="string">                expect &#123;</span></span><br><span class="line"><span class="string">                        \"(yes/no)\" &#123;send \"yes\r\"; exp_continue&#125;</span></span><br><span class="line"><span class="string">                        \"password:\" &#123;send \"<span class="variable">$PASS</span>\r\"; exp_continue&#125;</span></span><br><span class="line"><span class="string">                        \"<span class="variable">$USER</span>@*\" &#123;send \"<span class="variable">$COMMAND</span>\r exit\r\"; exp_continue&#125;</span></span><br><span class="line"><span class="string">                &#125;;</span></span><br><span class="line"><span class="string">        "</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"--------------------------------------------"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>其中<code>exp_continue</code>表示循环式匹配，通常匹配之后都会退出语句，但如果有<code>exp_continue</code>则可以不断循环匹配，输入多条命令，简化写法。</p><p>结合着expect <code>&quot;*password*&quot; {send &quot;$password\r&quot;}</code>这句代码来说说“模式-动作”。简单的说就是匹配到一个模式，就执行对应的动作；匹配到password字符串，就输入密码。</p><p><strong>执行结果如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ bash  test.sh <span class="string">'df -h'</span></span><br><span class="line">spawn ssh -p 22 root@192.168.1.3</span><br><span class="line">Last login: Tue Sep  3 05:05:47 2019 from 192.168.1.2</span><br><span class="line">[root@localhost ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root   14G  979M   13G   7% /</span><br><span class="line">devtmpfs                 3.9G     0  3.9G   0% /dev</span><br><span class="line">tmpfs                    3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs                    3.9G   49M  3.8G   2% /run</span><br><span class="line">tmpfs                    3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1                497M  125M  373M  25% /boot</span><br><span class="line">tmpfs                    783M     0  783M   0% /run/user/0</span><br><span class="line">[root@localhost ~]<span class="comment">#  exit</span></span><br><span class="line"><span class="built_in">logout</span></span><br><span class="line">Connection to 192.168.1.3 closed.</span><br><span class="line">df -h</span><br><span class="line"> <span class="built_in">exit</span></span><br><span class="line">--------------------------------------------</span><br></pre></td></tr></table></figure><blockquote><p>参考链接<br><a href="https://www.jellythink.com/archives/373" target="_blank" rel="noopener">linux expect命令详解</a><br><a href="https://www.cnblogs.com/nfcm/p/7899831.html" target="_blank" rel="noopener">linux下expect命令实现批量ssh免密</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;现在有两台Linux主机A和B，如何从A主机ssh到B主机，然后在B主机上执行命令，如何使这个过程实现全程自动化？之前有用过&lt;strong&gt;ssh-copy-id免密钥&lt;/strong&gt;的形式，这里是用第二种方式&lt;strong&gt;expect&lt;/strong&gt;实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Centos" scheme="https://annecoding.github.io/tags/Centos/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>linux查看网卡实时流量</title>
    <link href="https://annecoding.github.io/2019/08/30/linux%E6%9F%A5%E7%9C%8B%E7%BD%91%E5%8D%A1%E5%AE%9E%E6%97%B6%E6%B5%81%E9%87%8F/"/>
    <id>https://annecoding.github.io/2019/08/30/linux查看网卡实时流量/</id>
    <published>2019-08-30T12:24:52.000Z</published>
    <updated>2019-09-01T04:57:57.769Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>在工作中，我们经常需要查看服务器的实时网卡流量。通常，我们会通过这几种方式查看Linux服务器的实时网卡流量。</p><a id="more"></a><h3 id="sar命令"><a href="#sar命令" class="headerlink" title="sar命令"></a>sar命令</h3><p>sar命令包含在sysstat工具包中，提供系统的众多统计数据。其在不同的系统上命令有些差异，某些系统提供的sar支持基于网络接口的数据统计，也可以查看设备上每秒收发包的个数和流量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DEV显示网络接口信息</span></span><br><span class="line"><span class="comment"># 命令后面1 2 意思是：每一秒钟取1次值，取2次</span></span><br><span class="line">$ sar –n DEV  1 2</span><br></pre></td></tr></table></figure><p>另外，-n参数很有用，他有6个不同的开关：DEV | EDEV | NFS | NFSD | SOCK | ALL ，其代表的含义如下：</p><p>DEV显示网络接口信息。<br>EDEV显示关于网络错误的统计数据。<br>NFS统计活动的NFS客户端的信息。<br>NFSD统计NFS服务器的信息<br>SOCK显示套接字信息<br>ALL显示所有5个开关</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ sar -n DEV 1 2       </span><br><span class="line">Linux 3.10.0-514.26.2.el7.x86_64 (localhost)    08/31/2019      _x86_64_        (1 CPU)</span><br><span class="line"></span><br><span class="line">09:52:28 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">09:52:29 AM      eth0      2.02      1.01      0.13      0.16      0.00      0.00      0.00</span><br><span class="line">09:52:29 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">09:52:29 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">09:52:30 AM      eth0      1.02      1.02      0.07      0.23      0.00      0.00      0.00</span><br><span class="line">09:52:30 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">Average:        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">Average:         eth0      1.52      1.02      0.10      0.19      0.00      0.00      0.00</span><br><span class="line">Average:           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong><br>IFACE：LAN接口<br>rxpck/s：每秒钟接收的数据包<br>txpck/s：每秒钟发送的数据包<br>rxbyt/s：每秒钟接收的字节数<br>txbyt/s：每秒钟发送的字节数<br>rxcmp/s：每秒钟接收的压缩数据包<br>txcmp/s：每秒钟发送的压缩数据包<br>rxmcst/s：每秒钟接收的多播数据包<br>rxerr/s：每秒钟接收的坏数据包<br>txerr/s：每秒钟发送的坏数据包<br>coll/s：每秒冲突数<br>rxdrop/s：因为缓冲充满，每秒钟丢弃的已接收数据包数<br>txdrop/s：因为缓冲充满，每秒钟丢弃的已发送数据包数<br>txcarr/s：发送数据包时，每秒载波错误数<br>rxfram/s：每秒接收数据包的帧对齐错误数<br>rxfifo/s：接收的数据包每秒FIFO过速的错误数<br>txfifo/s：发送的数据包每秒FIFO过速的错误数</p><h3 id="实时监控脚本（1）"><a href="#实时监控脚本（1）" class="headerlink" title="实时监控脚本（1）"></a>实时监控脚本（1）</h3><p>ifconfig可以查看的是从连上网开始的流量总和，<code>cat /proc/net/dev</code>记录的值也是总流量，那么可以计算一下，实时流量=当前流量-上一秒的流量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat network.sh </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 传入网卡参数</span></span><br><span class="line">ethn=<span class="variable">$1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  RX_pre=$(cat /proc/net/dev | grep <span class="variable">$ethn</span> | sed <span class="string">'s/:/ /g'</span> | awk <span class="string">'&#123;print $2&#125;'</span>)</span><br><span class="line">  TX_pre=$(cat /proc/net/dev | grep <span class="variable">$ethn</span> | sed <span class="string">'s/:/ /g'</span> | awk <span class="string">'&#123;print $10&#125;'</span>)</span><br><span class="line">  sleep 1</span><br><span class="line">  RX_next=$(cat /proc/net/dev | grep <span class="variable">$ethn</span> | sed <span class="string">'s/:/ /g'</span> | awk <span class="string">'&#123;print $2&#125;'</span>)</span><br><span class="line">  TX_next=$(cat /proc/net/dev | grep <span class="variable">$ethn</span> | sed <span class="string">'s/:/ /g'</span> | awk <span class="string">'&#123;print $10&#125;'</span>)</span><br><span class="line"> </span><br><span class="line">  clear</span><br><span class="line">  <span class="comment"># echo -e激活转义符</span></span><br><span class="line">  <span class="comment"># 输出时间的标题</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">"\t RX `date +%k:%M:%S` TX"</span></span><br><span class="line"> </span><br><span class="line">  RX=$((<span class="variable">$&#123;RX_next&#125;</span>-<span class="variable">$&#123;RX_pre&#125;</span>))</span><br><span class="line">  TX=$((<span class="variable">$&#123;TX_next&#125;</span>-<span class="variable">$&#123;TX_pre&#125;</span>))</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> [[ <span class="variable">$RX</span> -lt 1024 ]];<span class="keyword">then</span></span><br><span class="line">    RX=<span class="string">"<span class="variable">$&#123;RX&#125;</span>B/s"</span></span><br><span class="line">  <span class="keyword">elif</span> [[ <span class="variable">$RX</span> -gt 1048576 ]];<span class="keyword">then</span></span><br><span class="line">    RX=$(<span class="built_in">echo</span> <span class="variable">$RX</span> | awk <span class="string">'&#123;print $1/1048576 "MB/s"&#125;'</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    RX=$(<span class="built_in">echo</span> <span class="variable">$RX</span> | awk <span class="string">'&#123;print $1/1024 "KB/s"&#125;'</span>)</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> [[ <span class="variable">$TX</span> -lt 1024 ]];<span class="keyword">then</span></span><br><span class="line">    TX=<span class="string">"<span class="variable">$&#123;TX&#125;</span>B/s"</span></span><br><span class="line">  <span class="keyword">elif</span> [[ <span class="variable">$TX</span> -gt 1048576 ]];<span class="keyword">then</span></span><br><span class="line">    TX=$(<span class="built_in">echo</span> <span class="variable">$TX</span> | awk <span class="string">'&#123;print $1/1048576 "MB/s"&#125;'</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    TX=$(<span class="built_in">echo</span> <span class="variable">$TX</span> | awk <span class="string">'&#123;print $1/1024 "KB/s"&#125;'</span>)</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="comment"># 输出流量</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$ethn</span> \t <span class="variable">$RX</span>   <span class="variable">$TX</span> "</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>执行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ./network.sh  eth0</span></span><br><span class="line">         RX 20:23:38 TX</span><br><span class="line">eth0     66B/s   0B/s </span><br><span class="line">         RX 20:23:39 TX</span><br><span class="line">eth0     132B/s   0B/s </span><br><span class="line">         RX 20:23:40 TX</span><br><span class="line">eth0     186B/s   194B/s </span><br><span class="line">         RX 20:23:41 TX</span><br><span class="line">eth0     240B/s   194B/s </span><br><span class="line">         RX 20:23:42 TX</span><br><span class="line">eth0     132B/s   0B/s </span><br><span class="line">         RX 20:23:43 TX</span><br><span class="line">eth0     240B/s   194B/s </span><br><span class="line">         RX 20:23:44 TX</span><br><span class="line">eth0     396B/s   4.19727KB/s </span><br><span class="line">         RX 20:23:45 TX</span><br><span class="line">eth0     276B/s   178B/s</span><br></pre></td></tr></table></figure></p><h3 id="实时监控脚本（2）"><a href="#实时监控脚本（2）" class="headerlink" title="实时监控脚本（2）"></a>实时监控脚本（2）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat network_flow.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 监控实时网卡流量</span></span><br><span class="line"><span class="comment"># $1 接收所传第一个参数 即要监控的网卡</span></span><br><span class="line">NIC=<span class="variable">$1</span></span><br><span class="line"><span class="comment"># echo -e "traffic in --- traffic out"</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>;<span class="keyword">do</span></span><br><span class="line">        <span class="comment"># $0 命令输出结果 ~ 匹配模式</span></span><br><span class="line">        OLD_IN=`awk <span class="string">'$0~"'</span><span class="variable">$NIC</span><span class="string">'"&#123;print $2&#125;'</span> /proc/net/dev`</span><br><span class="line">        OLD_OUT=`awk <span class="string">'$0~"'</span><span class="variable">$NIC</span><span class="string">'"&#123;print $10&#125;'</span> /proc/net/dev`</span><br><span class="line">        sleep 1</span><br><span class="line">        NEW_IN=`awk <span class="string">'$0~"'</span><span class="variable">$NIC</span><span class="string">'"&#123;print $2&#125;'</span> /proc/net/dev`</span><br><span class="line">        NEW_OUT=`awk <span class="string">'$0~"'</span><span class="variable">$NIC</span><span class="string">'"&#123;print $10&#125;'</span> /proc/net/dev`</span><br><span class="line">        clear</span><br><span class="line">        <span class="comment"># printf不换行 %s占位符</span></span><br><span class="line">        IN=$(<span class="built_in">printf</span> <span class="string">"%.1f%s"</span> <span class="string">"<span class="variable">$(($NEW_IN-$OLD_IN)</span>)"</span> <span class="string">"B/s"</span>)</span><br><span class="line">        OUT=$(<span class="built_in">printf</span> <span class="string">"%.1f%s"</span> <span class="string">"<span class="variable">$(($NEW_OUT-$OLD_OUT)</span>)"</span> <span class="string">"B/s"</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"       traffic in  `date +%k:%M:%S`  traffic out "</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$NIC</span>   <span class="variable">$IN</span>              <span class="variable">$OUT</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ./network_flow.sh eth0</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:02  traffic out </span><br><span class="line">eth0   732.0B/s              948.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:03  traffic out </span><br><span class="line">eth0   132.0B/s              0.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:04  traffic out </span><br><span class="line">eth0   132.0B/s              0.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:05  traffic out </span><br><span class="line">eth0   132.0B/s              0.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:06  traffic out </span><br><span class="line">eth0   186.0B/s              242.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:07  traffic out </span><br><span class="line">eth0   132.0B/s              0.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:08  traffic out </span><br><span class="line">eth0   132.0B/s              0.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:09  traffic out </span><br><span class="line">eth0   132.0B/s              0.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:10  traffic out </span><br><span class="line">eth0   240.0B/s              242.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:11  traffic out </span><br><span class="line">eth0   132.0B/s              0.0B/s</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;在工作中，我们经常需要查看服务器的实时网卡流量。通常，我们会通过这几种方式查看Linux服务器的实时网卡流量。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Centos" scheme="https://annecoding.github.io/tags/Centos/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>一键查看服务器资源利用率</title>
    <link href="https://annecoding.github.io/2019/08/29/%E4%B8%80%E9%94%AE%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%BA%90%E5%88%A9%E7%94%A8%E7%8E%87/"/>
    <id>https://annecoding.github.io/2019/08/29/一键查看服务器资源利用率/</id>
    <published>2019-08-29T09:09:22.000Z</published>
    <updated>2019-08-29T09:18:34.970Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>一般要查服务器资源利用率，我们会先从以下几个方面入手，比如cpu、内存、硬盘、tcp连接情况等。</p><a id="more"></a><p>这里以cpu、内存、硬盘、tcp连接情况来举例，实现如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">$ cat resource_utilization_rate.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 一键查看服务器资源利用率</span></span><br><span class="line"><span class="comment"># 可通过 cpu 内存 硬盘 tcp连接情况 ...等来查看</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">cpu</span></span>()&#123;</span><br><span class="line">        <span class="comment"># NUM=1</span></span><br><span class="line">        <span class="comment"># while [ $NUM -le 3 ];do</span></span><br><span class="line">                <span class="comment"># 相较于top vmstat 可免交互取静态数据，id,空间状态百分比</span></span><br><span class="line">                util=`vmstat |awk <span class="string">'&#123;if(NR==3)print 100-$15"%"&#125;'</span>`</span><br><span class="line">                <span class="comment"># us用户进程消耗cpu时间百分比</span></span><br><span class="line">                user=`vmstat |awk <span class="string">'&#123;if(NR==3)print $13"%"&#125;'</span>`</span><br><span class="line">                <span class="comment"># 系统内核进程消耗cpu时间百分比</span></span><br><span class="line">                sys=`vmstat |awk <span class="string">'&#123;if(NR==3)print $14"%"&#125;'</span>`</span><br><span class="line">                <span class="comment"># cpu资源等待I/O时间百分比</span></span><br><span class="line">                iowait=`vmstat |awk <span class="string">'&#123;if(NR==3)print $16"%"&#125;'</span>`</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"CPU - 使用率：<span class="variable">$util</span> ,等待磁盘IO响应使用率：<span class="variable">$iowait</span>"</span></span><br><span class="line">        <span class="comment">#echo "===========          ****         ================"</span></span><br><span class="line">        <span class="comment">#       let NUM++</span></span><br><span class="line">        <span class="comment">#       sleep 1</span></span><br><span class="line">        <span class="comment">#done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">memory</span></span>()&#123;</span><br><span class="line">        <span class="comment"># ` ` 等同于 $()</span></span><br><span class="line">        total=`free -h |awk <span class="string">'&#123;if(NR==2)print $2&#125;'</span>`</span><br><span class="line">        <span class="comment"># $NF表示取最后一列数据值</span></span><br><span class="line">        used=`free -h |awk <span class="string">'&#123;if(NR==2)print $2-$NF&#125;'</span>`</span><br><span class="line">        available=`free -h |awk <span class="string">'&#123;if(NR==2)print $NF&#125;'</span>`</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"内存 - 总大小：<span class="variable">$&#123;total&#125;</span>G ,已使用：<span class="variable">$&#123;used&#125;</span>G ,可利用：<span class="variable">$&#123;available&#125;</span>G"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">function</span> <span class="function"><span class="title">disk</span></span>()&#123;</span><br><span class="line">     <span class="comment"># 特殊符号/转义,只取第一列</span></span><br><span class="line">     fs=`df -h |awk <span class="string">'/^\/dev/&#123;print $1&#125;'</span>`</span><br><span class="line">     <span class="keyword">for</span> p <span class="keyword">in</span> <span class="variable">$fs</span>;<span class="keyword">do</span></span><br><span class="line">             <span class="comment"># 只有当第一列是磁盘Filesystem，输出最后一列</span></span><br><span class="line">             mounted=`df -h |awk <span class="string">'$1=="'</span><span class="variable">$p</span><span class="string">'"&#123;print $NF&#125;'</span>`</span><br><span class="line">             size=`df -h |awk <span class="string">'$1=="'</span><span class="variable">$p</span><span class="string">'"&#123;print $2&#125;'</span>`</span><br><span class="line">             used=`df -h |awk <span class="string">'$1=="'</span><span class="variable">$p</span><span class="string">'"&#123;print $3&#125;'</span>`</span><br><span class="line">             used_percent=`df -h |awk <span class="string">'$1=="'</span><span class="variable">$p</span><span class="string">'"&#123;print $5&#125;'</span>`</span><br><span class="line">             <span class="built_in">echo</span> <span class="string">"硬盘 - 挂载点：<span class="variable">$&#123;mounted&#125;</span> , 总大小：<span class="variable">$&#123;size&#125;</span> , 使用：<span class="variable">$&#123;used&#125;</span> , 使用率：<span class="variable">$&#123;used_percent&#125;</span>"</span></span><br><span class="line">     <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">tcp_status</span></span>()&#123;</span><br><span class="line"><span class="comment"># printf不换行 “:”以冒号分隔  ss第一列表示连接状态</span></span><br><span class="line">summary=`ss -antp |awk <span class="string">'&#123;status[$1]++&#125;END&#123;for(i in status) printf i ":" status[i]" "&#125;'</span>`</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"TCP - 连接状态：<span class="variable">$summary</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">cpu</span><br><span class="line">memory</span><br><span class="line">disk</span><br><span class="line">tcp_status</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./resource_utilization_rate.sh </span><br><span class="line">CPU - 使用率：0% ,等待磁盘IO响应使用率：0%</span><br><span class="line">内存 - 总大小：1.8GG ,已使用：0.2G ,可利用：1.6GG</span><br><span class="line">硬盘 - 挂载点：/ , 总大小：40G , 使用：1.9G , 使用率：5%</span><br><span class="line">TCP - 连接状态：LISTEN:3 ESTAB:3 State:1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;一般要查服务器资源利用率，我们会先从以下几个方面入手，比如cpu、内存、硬盘、tcp连接情况等。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>批量创建用户并设置随机密码</title>
    <link href="https://annecoding.github.io/2019/08/29/%E6%89%B9%E9%87%8F%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E8%AE%BE%E7%BD%AE%E9%9A%8F%E6%9C%BA%E5%AF%86%E7%A0%81/"/>
    <id>https://annecoding.github.io/2019/08/29/批量创建用户并设置随机密码/</id>
    <published>2019-08-29T09:08:31.000Z</published>
    <updated>2019-09-01T11:42:01.780Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>假如，在linux系统服务器上，要一次创建多个用户并设置密码，你有什么好办法吗？跟我来吧🔅</p><a id="more"></a><h3 id="批量创建用户"><a href="#批量创建用户" class="headerlink" title="批量创建用户"></a>批量创建用户</h3><p>使用shell脚本实现批量创建用户，实现方式如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ cat batch_create_user.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 批量创建用户</span></span><br><span class="line"><span class="comment"># $@接收输入的所有参数</span></span><br><span class="line">USER_LIST=<span class="variable">$@</span></span><br><span class="line"><span class="comment"># 将生成的用户名和密码存在文件里面，这样写默认user.txt存在当前路径下</span></span><br><span class="line">USER_FILE=user.txt</span><br><span class="line"><span class="keyword">for</span> USER <span class="keyword">in</span> <span class="variable">$USER_LIST</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 通过id来判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span> ! id <span class="variable">$USER</span> &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># 生产随机的8位字符串</span></span><br><span class="line">        PASS=$(<span class="built_in">echo</span> <span class="variable">$RANDOM</span> |md5sum |cut -c 1-8)</span><br><span class="line">        <span class="comment"># 创建用户</span></span><br><span class="line">        useradd <span class="variable">$USER</span></span><br><span class="line">        <span class="comment"># 将随机生成的密码分配给用户</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$PASS</span> |passwd --stdin <span class="variable">$USER</span> &amp;&gt;/dev/null</span><br><span class="line">        <span class="comment"># 生成的用户名和密码存入文件中</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$USER</span>   <span class="variable">$PASS</span>"</span> &gt;&gt; <span class="variable">$USER_FILE</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$USER</span> User create successful."</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$USER</span> User already exists!"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>执行结果如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./batch_create_user.sh coco zhangsan</span><br><span class="line">coco User create successful.</span><br><span class="line">zhangsan User create successful.</span><br><span class="line"><span class="comment"># 文件默认存放在当前目录下</span></span><br><span class="line">$ cat user.txt </span><br><span class="line">coco   69b7bc14</span><br><span class="line">zhangsan   fd343a4f</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;假如，在linux系统服务器上，要一次创建多个用户并设置密码，你有什么好办法吗？跟我来吧🔅&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本实现centos系统初始化配置</title>
    <link href="https://annecoding.github.io/2019/08/28/shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0centos%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>https://annecoding.github.io/2019/08/28/shell脚本实现centos系统初始化配置/</id>
    <published>2019-08-28T01:32:11.000Z</published>
    <updated>2019-08-28T04:48:03.309Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>Linux系统配置初始化，顾名思义，在我们有大量机器要做相同工作时，比如都要安装好某些软件，配置环境等，这时候，一个便捷实用的脚本就派上用场啦。</p><a id="more"></a><p><strong>背景：</strong>新购买100台服务器并已安装linux操作系统</p><p><strong>需求：</strong><br>1.设置时区并同步时间<br>2.禁用selinux<br>3.清空防火墙默认策略<br>4.历史命令显示操作时间<br>5.禁止root远程登录，这个要注意，禁止之前确保有普通账户可以sudo到root权限使用，不然切不到root账户<br>6.禁止定时任务发送邮件<br>7.设置最大打开文件数，默认比较少<br>8.减少swap使用，默认物理内存不够会使用swap来交换，速度慢，不建议使用<br>9.系统内核参数优化<br>10.安装系统性能分析工具及一些其他的</p><p><strong>实现脚本如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">$ cat server_initialize.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 设置时区为上海并每小时同步一次时间，默认时区为东八区</span></span><br><span class="line">ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"><span class="comment"># if判断是根据命令执行状态返回值$#?来判断是否执行成功，执行成功则为0，执行失败则为其他，一般为1</span></span><br><span class="line"><span class="keyword">if</span> ! crontab -l | grep ntpdate &amp;&gt;/dev/null; <span class="keyword">then</span> </span><br><span class="line">        <span class="comment"># | crontab通过管道符接收定时任务</span></span><br><span class="line">        (<span class="built_in">echo</span> <span class="string">"* 1 * * * ntpdate time.windows.com &gt;/dev/null 2&gt;&amp;1"</span>;crontab -l) | crontab</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用selinux</span></span><br><span class="line">sed -i <span class="string">'/SELINUX/&#123;s/permissive/disabled/&#125;'</span> /etc/selinux/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line"><span class="keyword">if</span> egrep <span class="string">"7.[0-9]"</span> /etc/redhat-release &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">        systemctl stop firewalld</span><br><span class="line">        systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"><span class="keyword">elif</span> egrep <span class="string">"6.[0-9]"</span> /etc/redhat-release &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">        service iptables stop</span><br><span class="line">        chkconfig iptables off</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 历史命令显示操作时间</span></span><br><span class="line"><span class="comment"># 方便后期审计，谁在什么时间操作</span></span><br><span class="line"><span class="keyword">if</span> ! grep HISTTIMEFORMAT /etc/bashrc &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'export HISTTIMEFORMAT="%F %T `whoami` "'</span> &gt;&gt; /etc/bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SSH超时时间</span></span><br><span class="line"><span class="comment"># 只有TMOUT可以控制ssh连接在空闲时间超时，自动断开连接的时间，数字单位为“秒”</span></span><br><span class="line"><span class="keyword">if</span> ! grep <span class="string">"TMOUT=1500"</span> /etc/profile &amp;&gt;/dev/null; <span class="keyword">then</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"export TMOUT=1500"</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁止root远程登录</span></span><br><span class="line"><span class="comment"># 操作之前授权其他账号或者将自己本机的key保存在系统，或者授权其他账户可以sudo到root账户</span></span><br><span class="line"><span class="comment"># sed -i 's/#PermitRootLogin yes/PermitRootLogin no/' /etc/ssh/sshd_config</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁止定时任务向root发送邮件</span></span><br><span class="line"><span class="comment"># 定时任务的错误等会给当前用户发送邮件，默认是当前用户，会在/var/mail很多小文件占用很大的磁盘空间</span></span><br><span class="line">sed -i <span class="string">'s/^MAILTO=root/MAILTO=""/'</span> /etc/crontab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置最大打开文件数</span></span><br><span class="line"><span class="comment"># 并发较高时，很容易会达到默认，很容易不可用，这里做个优化</span></span><br><span class="line"><span class="comment"># EOF直接将内容追加到文件中，需要在当前行起始位置，不能加空格</span></span><br><span class="line"><span class="keyword">if</span> ! grep <span class="string">"* soft nofile 65535"</span> /etc/security/limits.conf &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">        cat &gt;&gt; /etc/security/limits.conf &lt;&lt; EOF</span><br><span class="line">        * soft nofile 65535</span><br><span class="line">        * hard nofile 65535</span><br><span class="line">EOF</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统内核优化</span></span><br><span class="line"><span class="comment"># 默认数值可通过systcl -a查看</span></span><br><span class="line"><span class="comment"># net.core.netdev_max_backlog 决定了，网络设备接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。</span></span><br><span class="line"><span class="comment"># net.ipv4.tcp_syncookies = 1表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭。</span></span><br><span class="line"><span class="comment"># net.ipv4.tcp_fin_timeout =20表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。</span></span><br><span class="line">cat &gt;&gt; /etc/sysctl.conf &lt;&lt; EOF</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 20480</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 20480</span><br><span class="line">net.core.netdev_max_backlog = 262144</span><br><span class="line">net.ipv4.tcp_fin_timeout = 20</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 减少SWAP使用</span></span><br><span class="line"><span class="comment"># 权重值设置的越大，使用的可能越大。设置为0，尽可能不使用它。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"0"</span> &gt; /proc/sys/vm/swappiness</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装系统性能分析工具及其他</span></span><br><span class="line"><span class="comment"># htop 比top好用的工具</span></span><br><span class="line">yum install gcc make autoconf vim htop sysstat net-tools iostat iftop iotp lrzsz -y</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;Linux系统配置初始化，顾名思义，在我们有大量机器要做相同工作时，比如都要安装好某些软件，配置环境等，这时候，一个便捷实用的脚本就派上用场啦。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Centos使用mailx告警邮件配置</title>
    <link href="https://annecoding.github.io/2019/08/22/Centos%E4%BD%BF%E7%94%A8mailx%E5%91%8A%E8%AD%A6%E9%82%AE%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    <id>https://annecoding.github.io/2019/08/22/Centos使用mailx告警邮件配置/</id>
    <published>2019-08-22T01:09:19.000Z</published>
    <updated>2019-08-24T01:38:04.551Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>今天为大家介绍一个可以直接在 Linux 上使用 SMTP 发送邮件的程序：Mailx，这个程序可以帮助我们让服务器直接支持邮件发送，不用再在每个站点上都设置了。</p><a id="more"></a><p><strong>centos配置自带邮件服务器mailx发件配置</strong></p><h4 id="安装mailx程序"><a href="#安装mailx程序" class="headerlink" title="安装mailx程序"></a>安装mailx程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mailx</span><br></pre></td></tr></table></figure><p>🌟 安装之前，建议移除不再需要且可能会引起冲突的 postfix 或 sendmail 程序。</p><h4 id="修改发件人设置"><a href="#修改发件人设置" class="headerlink" title="修改发件人设置"></a>修改发件人设置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ vim + /etc/mail.rc </span><br><span class="line"><span class="built_in">set</span> nss-config-dir=/root/.certs</span><br><span class="line"><span class="built_in">set</span> smtp=<span class="string">"smtps://smtp.163.com:465"</span></span><br><span class="line"><span class="comment"># set smtp=smtp.163.com  默认25端口不放开</span></span><br><span class="line"><span class="built_in">set</span> from=<span class="string">"annecoding@163.com"</span></span><br><span class="line"><span class="built_in">set</span> smtp-auth=login</span><br><span class="line"><span class="built_in">set</span> smtp-auth-user=<span class="string">"annecoding@163.com"</span></span><br><span class="line"><span class="comment"># 不是密码，不是密码！！！获取网易163设置的客户端授权密码。</span></span><br><span class="line"><span class="built_in">set</span> smtp-auth-password=<span class="string">"xxxxxx"</span></span><br><span class="line"><span class="built_in">set</span> ssl-verify=ignore</span><br></pre></td></tr></table></figure><p>💡 一般邮件服务器会提供 smtp、smtps 和 smtp starttls 服务来发送邮件。smtp 最简单的，也最不安全的，不建议使用，最好使用 smtps 或者 smtp starttls 来发送邮件。</p><h4 id="测试发送"><a href="#测试发送" class="headerlink" title="测试发送"></a>测试发送</h4><p>可以发送出邮件，但是会报错，如下面这种情况。需要生成证书来解决此问题。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"TEST"</span> | mail -s <span class="string">"Title"</span> <span class="string">"annecoding@163.com"</span></span><br><span class="line">$ Error <span class="keyword">in</span> certificate: Peer<span class="string">'s certificate issuer is not recognized.</span></span><br></pre></td></tr></table></figure></p><h4 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h4><p>在本地新建目录生成证书<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /root/.certs/</span><br><span class="line">$ <span class="built_in">echo</span> -n | openssl s_client -connect smtp.163.com:465 | sed -ne <span class="string">'/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p'</span> &gt; ~/.certs/163.crt</span><br><span class="line">$ certutil -A -n <span class="string">"GeoTrust SSL CA"</span> -t <span class="string">"C,,"</span> -d ~/.certs -i ~/.certs/163.crt</span><br><span class="line">$ certutil -A -n <span class="string">"GeoTrust Global CA"</span> -t <span class="string">"C,,"</span> -d ~/.certs -i ~/.certs/163.crt</span><br><span class="line">$ certutil -L -d /root/.certs</span><br><span class="line"><span class="comment"># 信任证书</span></span><br><span class="line">$ <span class="built_in">cd</span> .certs</span><br><span class="line">$ certutil -A -n <span class="string">"GeoTrust SSL CA - G3"</span> -t <span class="string">"Pu,Pu,Pu"</span>  -d ./ -i 163.crt</span><br></pre></td></tr></table></figure></p><p>💡 参考上面的设置（如果要用qq邮箱，可以把所有的生成证书的163改为qq），同样可以使用 126，163 等邮箱在服务器上通过 SMTP 发送邮件。设置成功以后，服务器上的所有站点，或者其他程序、其他语言开发的站点，都可以直接发送邮件了，是不是很方便？</p><h4 id="再次修改mail-rc"><a href="#再次修改mail-rc" class="headerlink" title="再次修改mail.rc"></a>再次修改mail.rc</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/mail.rc</span><br><span class="line">$ <span class="built_in">set</span> nss-config-dir=/root/.certs/</span><br></pre></td></tr></table></figure><h4 id="测试发送-1"><a href="#测试发送-1" class="headerlink" title="测试发送"></a>测试发送</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mail -s发送邮件 -v可以显示发件的详细信息</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"邮件正文"</span> | mail -s <span class="string">"标题"</span> <span class="string">"annecoding@163.com"</span> </span><br><span class="line">$ mail -s <span class="string">"xxxx"</span> annecoding@163.com &lt; /root/cpu.sh</span><br></pre></td></tr></table></figure><blockquote><p>参考链接：</p><p><a href="https://www.wpzhiku.com/shi-yong-mailx-tong-guo-smtp-zai-centos-shang-fa-song-you-jian/" target="_blank" rel="noopener">使用 Mailx 通过 SMTP 在 Centos 上发送邮件，解决 WordPress 发送邮件问题</a></p><p> <a href="https://www.cnblogs.com/hqqq/p/6261419.html" target="_blank" rel="noopener">mialx配置qq邮箱发送邮件</a></p><p> <a href="https://help.mail.163.com/faqDetail.do?code=d7a5dc8471cd0c0e8b4b8f4f8e49998b374173cfe9171305fa1ce630d7f67ac2cda80145a1742516" target="_blank" rel="noopener">如何开启客户端授权码？</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;今天为大家介绍一个可以直接在 Linux 上使用 SMTP 发送邮件的程序：Mailx，这个程序可以帮助我们让服务器直接支持邮件发送，不用再在每个站点上都设置了。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Centos" scheme="https://annecoding.github.io/tags/Centos/"/>
    
      <category term="mailx" scheme="https://annecoding.github.io/tags/mailx/"/>
    
  </entry>
  
  <entry>
    <title>shell中切分文件名和扩展名</title>
    <link href="https://annecoding.github.io/2019/08/13/shell%E4%B8%AD%E5%88%87%E5%88%86%E6%96%87%E4%BB%B6%E5%90%8D%E5%92%8C%E6%89%A9%E5%B1%95%E5%90%8D/"/>
    <id>https://annecoding.github.io/2019/08/13/shell中切分文件名和扩展名/</id>
    <published>2019-08-13T08:22:49.000Z</published>
    <updated>2019-08-13T08:50:59.385Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>对于shell涉及的修改文件名的操作，我们可能需要提取某个文件名，或者提取某个文件的扩展名。get✔</p><a id="more"></a><h3 id="根据扩展名切分文件名"><a href="#根据扩展名切分文件名" class="headerlink" title="根据扩展名切分文件名"></a>根据扩展名切分文件名</h3><p>截取文件名称示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat file.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">file_jpg=<span class="string">"sample.jpg"</span></span><br><span class="line">name=<span class="variable">$&#123;file_jpg%.*&#125;</span></span><br><span class="line"><span class="built_in">echo</span> File name is:<span class="variable">$name</span></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./file.sh </span><br><span class="line">File name is:sample</span><br></pre></td></tr></table></figure><p>截取文件扩展名示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat file1.sh</span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">file_jpg=<span class="string">"sample.jpg"</span></span><br><span class="line">extension=<span class="variable">$&#123;file_jpg#*.&#125;</span></span><br><span class="line"><span class="built_in">echo</span> Extension is:<span class="variable">$extension</span></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./file1.sh</span><br><span class="line">Extension is:jpg</span><br></pre></td></tr></table></figure><p><code>${VAR%.*}</code>工作原理：</p><ul><li>从<code>$VAR</code>中删除位于<code>%</code>右侧的通配符（在上例中式<code>.*</code>），通配符从右向左进行匹配。</li><li>给<code>VAR</code>赋值，即<code>VAR=sample.jpg</code>，通配符从右向左匹配得到的内容是<code>.jpg</code>，因此从<code>$VAR</code>中删除匹配结果，得到输出结果sample。</li></ul><p>💡 那么，有没有考虑过，要是文件名有很多后缀呢<code>cute.a.b.c.d.txt</code>？要是提取的变量为域名<code>www.google.com</code>呢？有的是办法，往下看~</p><p><strong>%属于非贪婪匹配，它从右向左找出匹配通配符的最短结果。还有另一个操作符%%，它于%相似，但行为模式确是贪婪的，它会匹配符合通配符的最长结果。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明变量var</span></span><br><span class="line">$ var=hack.fun.book.txt</span><br><span class="line"><span class="comment"># 执行从右向左非贪婪匹配，得到的匹配结果为.txt,删除了.txt之后文件名，可以得到具体的文件名</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var%.*&#125;</span></span><br><span class="line">hack.fun.book</span><br><span class="line"><span class="comment"># 执行从右向左贪婪匹配，得到结果.fun.book.txt,删除了.fun.book.txt</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var%%.*&#125;</span></span><br><span class="line">hack</span><br></pre></td></tr></table></figure><p><code>${VAR#*.}</code>工作原理：</p><ul><li>从<code>$VAR</code>中删除位于<code>#</code>右侧的通配符（上个栗子中使用的<code>*.</code>），从左到右匹配字符串。</li><li>和<code>#</code>对应的贪婪操作是<code>##</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从右到左进行非贪婪匹配，得到匹配结果hack，从指定变量中删除匹配结果</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var#*.&#125;</span></span><br><span class="line">fun.book.txt</span><br><span class="line"><span class="comment"># 从右到左进行非贪婪匹配，得到匹配结果hack.fun.book，删除匹配结果后得到扩展名</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var##*.&#125;</span></span><br><span class="line">txt</span><br></pre></td></tr></table></figure><p>💡总结</p><p><strong>文件名中可能包含多个.字符，所以呢</strong></p><p><strong>对于文件名：相较于%%，%更适合于提取文件名。%执行的是非贪婪匹配，只会删除扩展名。</strong></p><p><strong>对于扩展名：相较于#，##更适合于从中提取扩展名。##执行的是贪婪匹配，因此能准确的提取扩展名。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;对于shell涉及的修改文件名的操作，我们可能需要提取某个文件名，或者提取某个文件的扩展名。get✔&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>监控多台服务器利用率</title>
    <link href="https://annecoding.github.io/2019/07/25/%E7%9B%91%E6%8E%A7%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%A9%E7%94%A8%E7%8E%87/"/>
    <id>https://annecoding.github.io/2019/07/25/监控多台服务器利用率/</id>
    <published>2019-07-25T02:12:15.000Z</published>
    <updated>2019-09-01T04:57:52.968Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>通常，我们可以在linux主机ssh通过密码<strong>交互登录</strong>到远程其他主机。但是，我们在脚本里面不想用交互呢？当然了，ssh给我们提供了一个强大的工具。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">环境：192.168.1.2（监控主机） 192.168.1.3（被监控主机） 192.168.1.4（被监控主机）</span><br></pre></td></tr></table></figure><p>现在要做的是在ssh主机之间免密钥登录，这样才能方便我们下一步使用脚本在直接在本机连接远程主机执行命令。其实就是在监控主机上面生成公钥，然后放到被监控主机上，类似于我们登录github把自己本机的公钥放在github服务器上面一样，这样我们ssh连接的时候就不用总输入密码了。</p><h3 id="免密钥登录"><a href="#免密钥登录" class="headerlink" title="免密钥登录"></a>免密钥登录</h3><p>1.产生公钥对<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在本地机器上使用ssh-keygen产生公钥私钥对</span></span><br><span class="line"><span class="comment"># 在/root根目录下，一直默认，默认存在当前目录下.ssh里面（ll -a）</span></span><br><span class="line">$ ssh-keygen</span><br></pre></td></tr></table></figure></p><p>2.将本机公钥复制到远程要免密登录的机器中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用ssh-copy-id将公钥id_rsa.pub复制到远程机器中，第一次需要输入密码</span></span><br><span class="line"><span class="comment"># 默认将192.168.1.2的公钥存放在/root根目录下的.ssh里面authorized_keys</span></span><br><span class="line">$ ssh root@192.168.1.3</span><br><span class="line">$ ssh root@192.168.1.4</span><br></pre></td></tr></table></figure></p><p>3.免密连接远程主机执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh root@192.168.1.3</span><br><span class="line">$ ssh root@192.168.1.4 <span class="string">'df -h'</span></span><br></pre></td></tr></table></figure></p><h3 id="监控服务器利用率"><a href="#监控服务器利用率" class="headerlink" title="监控服务器利用率"></a>监控服务器利用率</h3><p>好了，现在基础环境已经做好了，磁盘使用情况可以用<code>df -h</code>来查询，脚本实现如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ cat disk_availabile.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 监控多台服务器利用率</span></span><br><span class="line"><span class="comment"># 将需要监控的服务器信息存储在host.info中，IP地址 用户 端口号</span></span><br><span class="line">HOST_INFO=host.info</span><br><span class="line"><span class="comment"># 逐行匹配，不匹配注释（以#开头）</span></span><br><span class="line"><span class="keyword">for</span> IP <span class="keyword">in</span> $(awk <span class="string">'/^[^#]/&#123;print $1&#125;'</span> <span class="variable">$HOST_INFO</span>);<span class="keyword">do</span></span><br><span class="line"> <span class="comment"># awk -v 在shell中使用变量，以ip为基准匹配，匹配到了取出用户</span></span><br><span class="line">        USER=`awk -v ip=<span class="variable">$IP</span> <span class="string">'ip==$1&#123;print $2&#125;'</span> <span class="variable">$HOST_INFO</span>`</span><br><span class="line">        PORT=`awk -v ip=<span class="variable">$IP</span> <span class="string">'ip==$1&#123;print $3&#125;'</span> <span class="variable">$HOST_INFO</span>`</span><br><span class="line">        TMP_FILE=/tmp/disk.tmp</span><br><span class="line">        <span class="comment"># 将连接到远程主机的信息暂时存入文件中</span></span><br><span class="line">        ssh -p <span class="variable">$PORT</span> <span class="variable">$USER</span>@<span class="variable">$IP</span> <span class="string">'df -h'</span> &gt; <span class="variable">$TMP_FILE</span></span><br><span class="line">        <span class="comment"># 取出挂载点并添加分隔符=  </span></span><br><span class="line">        <span class="comment"># int($5) 去除百分比以方便后面做判断 /=5</span></span><br><span class="line">        USE_PART_LIST=`awk <span class="string">'BEGIN&#123;OFS="="&#125;/^\/dev/&#123;print $NF,int($5)&#125;'</span> <span class="variable">$TMP_FILE</span>`</span><br><span class="line">        <span class="comment"># 取挂载点和利用率</span></span><br><span class="line">        <span class="keyword">for</span> USE_RATE <span class="keyword">in</span> <span class="variable">$USE_PART_LIST</span>;<span class="keyword">do</span></span><br><span class="line">                <span class="comment"># 挂载点 匹配到=右边的 /</span></span><br><span class="line">                PART_NAME=<span class="variable">$&#123;USE_RATE%=*&#125;</span></span><br><span class="line">                <span class="comment"># 使用率 匹配到=左边的 5</span></span><br><span class="line">                USE_RATE=<span class="variable">$&#123;USE_RATE#*=&#125;</span></span><br><span class="line">                <span class="keyword">if</span> [ <span class="variable">$USE_RATE</span> -ge 80 ]; <span class="keyword">then</span></span><br><span class="line">                        <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$IP</span> \n Warning: <span class="variable">$PART_NAME</span> Partition usage <span class="variable">$USE_RATE</span>%!"</span></span><br><span class="line">                <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat host.info </span><br><span class="line">192.168.1.3 root 22</span><br><span class="line">$ ./disk_availabile.sh</span><br><span class="line">192.168.1.3 </span><br><span class="line"> Warning: / Partition usage 86%!</span><br><span class="line">192.168.1.3 </span><br><span class="line"> Warning: /dev/sda2 Partition usage 88%!</span><br><span class="line">192.168.1.4</span><br><span class="line"> Warning: / Partition usage 89%!</span><br><span class="line">192.168.1.4 </span><br><span class="line"> Warning: /dev/vda1 Partition usage 92%!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;通常，我们可以在linux主机ssh通过密码&lt;strong&gt;交互登录&lt;/strong&gt;到远程其他主机。但是，我们在脚本里面不想用交互呢？当然了，ssh给我们提供了一个强大的工具。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Centos" scheme="https://annecoding.github.io/tags/Centos/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>mtr网络分析工具安装</title>
    <link href="https://annecoding.github.io/2019/07/24/mtr%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/"/>
    <id>https://annecoding.github.io/2019/07/24/mtr网络分析工具安装/</id>
    <published>2019-07-24T08:00:54.000Z</published>
    <updated>2019-08-03T01:19:07.801Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>遇到了安装完成mtr以后命令不能使用的情况，因为环境变量的配置问题！！！</p><a id="more"></a><p>mtr网络分析工具安装</p><p>1.首先保证安装brew工具</p><p>2.执行<code>brew cask mtr</code>进行软件安装</p><p>3.配置PATH变量 <code>vim ~/.bash_profile</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/sbin</span><br></pre></td></tr></table></figure><p>4.配置文件生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><p>5.安装完以后在<code>usr/local/sbin</code>目录下，第一次执行可以执行，再打开窗口就不行，环境变量只生效了一次。</p><p>再次打开新的窗口就发现不能使用了，输入<code>mtr</code>命令发现不能运行，提示如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtr: mtr should not run suid</span><br></pre></td></tr></table></figure><p>再次查看环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 内容如下</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin:/usr/bin:/bin:/usr/sbin:/sbin</span><br></pre></td></tr></table></figure><p>果然，没有<code>usr/local/sbin</code></p><p>6.此时有两种解决方案： </p><p>第一种解决方案，建立软链接，将所安装的mtr指令软链接到系统找得到的目录下，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/sbin/mtr* /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure><p>第二种解决方案，修改/etc/paths的path文件，添加。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/paths </span><br><span class="line">在最后一行添加：/usr/<span class="built_in">local</span>/sbin，此修改重新启动程序便会生效。</span><br></pre></td></tr></table></figure><p>7.使用mtr命令必须是root权限，当然也可以修改目录权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mtr www.baidu.com</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;遇到了安装完成mtr以后命令不能使用的情况，因为环境变量的配置问题！！！&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="mtr" scheme="https://annecoding.github.io/tags/mtr/"/>
    
  </entry>
  
  <entry>
    <title>mac下如何修改环境变量</title>
    <link href="https://annecoding.github.io/2019/07/24/mac%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>https://annecoding.github.io/2019/07/24/mac下如何修改环境变量/</id>
    <published>2019-07-24T08:00:33.000Z</published>
    <updated>2019-07-28T01:39:28.265Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>mac下环境变量到底该修改哪个文件呢？？？黑人问号脸，所以，一起来揭穿它神秘的面纱吧。<br><a id="more"></a></p><p>mac下一般使用bash作为默认shell</p><p>mac系统的环境变量，加载顺序为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc</span><br></pre></td></tr></table></figure><p>当然<code>/etc/profile</code>和<code>/etc/paths</code>是系统级别的，系统启动就会加载，后面几个是当前用户级的环境变量。</p><p>后面3个按照从前往后的顺序读取，如果<code>/.bash_profile</code>文件存在，则后面的几个文件就会被忽略不读了，如果<code>~/.bash_profile</code>文件不存在，才会以此类推读取后面的文件。</p><p><code>~/.bashrc</code>没有上述规则，它是<code>bash shell</code>打开的时候载入的。</p><p>如果没特殊说明,设置PATH的语法都为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#中间用冒号隔开 </span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:------:&lt;PATH N&gt;</span><br></pre></td></tr></table></figure><h3 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h3><p>下面的几个文件设置是全局的,修改时需要root权限</p><p>1、<code>/etc/paths</code> （全局建议修改这个文件 ）</p><p>编辑 <code>/etc/paths</code>，将环境变量添加到<code>/etc/paths</code>文件中 ，一行一个路径</p><p>Hint：输入环境变量时，不用一个一个地输入，只要拖动文件夹到 Terminal 里就可以了。</p><p>2、<code>/etc/profile</code>（建议不修改这个文件 ）全局（公有）配置，不管是哪个用户，登录时都会读取该文件。</p><p>3、<code>/etc/bashrc</code>（一般在这个文件中添加系统级环境变量）全局（公有）配置，bash shell执行时，不管是何种方式，都会读取此文件。</p><p>4、这条是什么鬼，先放着hhh~~~~👻</p><p>1.创建一个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo touch /etc/paths.d/mysql</span><br></pre></td></tr></table></figure><p>2.用 vim 打开这个文件（如果是以 open -t 的方式打开，则不允许编辑）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/paths.d/mysql</span><br></pre></td></tr></table></figure><p>3.编辑该文件，键入路径并保存（关闭该 Terminal 窗口并重新打开一个，就能使用 mysql 命令了）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/mysql/bin</span><br></pre></td></tr></table></figure><p>据说，这样可以自己生成新的文件，不用把变量全都放到 paths 一个文件里，方便管理。</p><h3 id="单个用户设置"><a href="#单个用户设置" class="headerlink" title="单个用户设置"></a>单个用户设置</h3><p>1、<code>~/.bash_profile</code> （任意一个文件中添加用户级环境变量）</p><p>（注：Linux 里面是<code>.bashrc</code> 而 Mac 是 <code>.bash_profile</code>）</p><p>若<code>bash shell</code>是以login方式执行时，才会读取此文件。该文件仅仅执行一次!默认情况下,他设置一些环境变量</p><p>设置命令别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> ll=’ls -la’</span><br></pre></td></tr></table></figure><p>设置环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/opt/<span class="built_in">local</span>/bin:/opt/<span class="built_in">local</span>/sbin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>2、<code>~/.bashrc</code>同上</p><p>如果想立刻生效，则可执行下面的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source 相应的文件</span><br></pre></td></tr></table></figure><p>一般环境变量更改后，重启程序后生效。</p><blockquote><p>参考：</p><p><a href="https://segmentfault.com/q/1010000008484965/a-1020000008485621" target="_blank" rel="noopener">MAC OS中修改环境变量到底应该修改哪个文件</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;mac下环境变量到底该修改哪个文件呢？？？黑人问号脸，所以，一起来揭穿它神秘的面纱吧。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mac" scheme="https://annecoding.github.io/categories/Mac/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Mac" scheme="https://annecoding.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>linux安装hping添加环境变量</title>
    <link href="https://annecoding.github.io/2019/07/20/linux%E5%AE%89%E8%A3%85hping%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>https://annecoding.github.io/2019/07/20/linux安装hping添加环境变量/</id>
    <published>2019-07-20T11:06:59.000Z</published>
    <updated>2019-07-24T09:03:16.493Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>当我试图去安装hping的时候，出现了一些些问题，明明已经安装，但是却不能使用，后来发现是环境变量没有配置上。<br><a id="more"></a></p><p>在mac下通过brew安装hping<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install hping</span><br></pre></td></tr></table></figure></p><p>查看已安装列表…找到如下一列<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew list</span><br><span class="line">.... ... .... hping ... .... ...</span><br></pre></td></tr></table></figure></p><p>然而,当我运行hping时…<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hping</span><br><span class="line">zsh: <span class="built_in">command</span> not found: hping</span><br></pre></td></tr></table></figure></p><p>再次查看安装信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ brew info hping</span><br><span class="line">hping: stable 3.20051105</span><br><span class="line">http://www.hping.org/</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/hping/3.20051105 (9 files, 196K) *</span><br><span class="line">  Built from <span class="built_in">source</span></span><br><span class="line">From: https://github.com/Homebrew/homebrew/blob/master/Library/Formula/hping.rb</span><br></pre></td></tr></table></figure></p><p>emmm…得出结论，安装了hping却不能使用<br>将<code>/usr/local/sbin</code>添加到<code>$PATH</code>,<br>因为hping二进制文件安装在<code>/usr/local/sbin</code>中,而不是安装在<code>/usr/local/bin</code>中。</p><p><strong>解决方案</strong></p><p>在终端中输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/sbin</span><br></pre></td></tr></table></figure></p><p>哦对了 等号之间不能有空格</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;当我试图去安装hping的时候，出现了一些些问题，明明已经安装，但是却不能使用，后来发现是环境变量没有配置上。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mac" scheme="https://annecoding.github.io/categories/Mac/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="hping" scheme="https://annecoding.github.io/tags/hping/"/>
    
      <category term="Mac" scheme="https://annecoding.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu修改IP地址</title>
    <link href="https://annecoding.github.io/2019/07/20/ubuntu%E4%BF%AE%E6%94%B9IP%E5%9C%B0%E5%9D%80/"/>
    <id>https://annecoding.github.io/2019/07/20/ubuntu修改IP地址/</id>
    <published>2019-07-20T10:59:03.000Z</published>
    <updated>2019-07-28T01:42:55.801Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>ubuntu修改静态ip地址需要单独设置DNS，这个要注意一下哦。<br><a id="more"></a></p><h3 id="ubuntu修改ip地址"><a href="#ubuntu修改ip地址" class="headerlink" title="ubuntu修改ip地址"></a>ubuntu修改ip地址</h3><h4 id="ubuntu16-04修改IP地址"><a href="#ubuntu16-04修改IP地址" class="headerlink" title="ubuntu16.04修改IP地址"></a>ubuntu16.04修改IP地址</h4><p>1、修改网卡配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sudo  vi /etc/network/interfaces</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到其中以下几行进行修改</span></span><br><span class="line">auto ens123</span><br><span class="line">iface ens123 inet static</span><br><span class="line">        address 10.10.133.233</span><br><span class="line">        netmask 255.255.255.0</span><br><span class="line">        network 10.10.133.0</span><br><span class="line">        broadcast 10.10.133.255</span><br><span class="line">        gateway 10.10.133.254</span><br><span class="line">        <span class="comment"># dns-* options are implemented by the resolvconf package, if installed</span></span><br><span class="line">        dns-nameservers 8.8.8.8</span><br></pre></td></tr></table></figure><p>2、修改DNS配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi + /etc/resolvconf/resolv.conf.d/head</span><br><span class="line"><span class="comment"># 在文件最后添加一句话</span></span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>3、重启网卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo /etc/init.d/networking restart</span><br></pre></td></tr></table></figure><h4 id="ubuntu18-04修改ip地址"><a href="#ubuntu18-04修改ip地址" class="headerlink" title="ubuntu18.04修改ip地址"></a>ubuntu18.04修改ip地址</h4><p>1、修改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/netplan/50-cloud-init.yaml</span><br><span class="line"><span class="comment"># 修改以下内容</span></span><br><span class="line">network:</span><br><span class="line">    ethernets:</span><br><span class="line">        eth0:</span><br><span class="line">            addresses:</span><br><span class="line">            - 192.168.15.72/20</span><br><span class="line">            gateway4: 192.168.12.2</span><br><span class="line">            nameservers:</span><br><span class="line">                addresses:</span><br><span class="line">                - 223.5.5.5</span><br><span class="line">                search: []</span><br><span class="line">            optional: <span class="literal">true</span></span><br><span class="line">    version: 2</span><br></pre></td></tr></table></figure><p>2、使配置生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netplan apply</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;ubuntu修改静态ip地址需要单独设置DNS，这个要注意一下哦。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://annecoding.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>linux系统扫描命令和安全防范笔记</title>
    <link href="https://annecoding.github.io/2019/07/20/linux%E7%B3%BB%E7%BB%9F%E6%89%AB%E6%8F%8F%E5%91%BD%E4%BB%A4%E5%92%8C%E5%AE%89%E5%85%A8%E9%98%B2%E8%8C%83%E7%AC%94%E8%AE%B0/"/>
    <id>https://annecoding.github.io/2019/07/20/linux系统扫描命令和安全防范笔记/</id>
    <published>2019-07-20T09:21:31.000Z</published>
    <updated>2019-07-28T01:40:42.649Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>本文主要介绍了一些常用的网络扫描工具以及安全防范，了解更多命令的使用。<br><a id="more"></a></p><h3 id="linux系统扫描命令和安全防范笔记"><a href="#linux系统扫描命令和安全防范笔记" class="headerlink" title="linux系统扫描命令和安全防范笔记"></a><strong>linux系统扫描命令和安全防范笔记</strong></h3><p>通过网络入侵来窃取敏感信息</p><p>通过网络扫描获取运营商核心设备的管理权限</p><h3 id="网络入侵方式"><a href="#网络入侵方式" class="headerlink" title="网络入侵方式"></a><strong>网络入侵方式</strong></h3><p>踩点-网络扫描-差点-提权</p><p><strong>常用命令</strong></p><p>tracert/traceroute、namp、nc</p><h3 id="主机扫描命令fping"><a href="#主机扫描命令fping" class="headerlink" title="主机扫描命令fping"></a><strong>主机扫描命令fping</strong></h3><p>批量的给目标主机发送ping请求，测试主机的存活情况。</p><p>特点：并行发送，结果易读</p><p><strong>源码包编译过程</strong></p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g54yozizhcj30yg0lign8.jpg" alt="image-20190719105646797"></p><p>fping编译安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># wget https://fping.org/dist/fping-4.2.tar.gz</span></span><br><span class="line">[root@localhost ~]<span class="comment"># tar -xvf fping-4.2.tar.gz </span></span><br><span class="line">[root@localhost fping-4.2]<span class="comment"># ./configure &amp; make &amp; make install</span></span><br><span class="line">[root@localhost fping-4.2]<span class="comment"># fping -h  #查看帮助命令</span></span><br><span class="line">[root@localhost fping-4.2]<span class="comment"># fping -v</span></span><br><span class="line">fping: Version 4.2</span><br><span class="line">fping: comments to david@schweikert.ch</span><br></pre></td></tr></table></figure><h4 id="fping参数介绍"><a href="#fping参数介绍" class="headerlink" title="fping参数介绍"></a><strong>fping参数介绍</strong></h4><p>命令参数man、-h方式</p><p>常用参数：</p><p>-a 只显示出存活的主机(相反参数-u)</p><p>-l 循环ping</p><p>1、通过标准输入方式fping+IP1+IP2</p><p>-g 支持主机段的方式 192.168.1.1 192.168.1.255 192.168.1.0/24</p><p>2、通过读取一个文件中的IP内容</p><p>方式：fping -f filename</p><p>3、fping使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找存货的主机</span></span><br><span class="line">fping -a 10.10.163.233</span><br><span class="line"><span class="comment"># 可以查找某个网段内存活的主机</span></span><br><span class="line">fping  -g -a 10.10.163.1 10.10.163.254</span><br><span class="line"><span class="comment"># 查找某个网段内存活主机第二种写法</span></span><br><span class="line">fping -a -g 10.10.163.233/24</span><br></pre></td></tr></table></figure><h3 id="主机扫描命令hping"><a href="#主机扫描命令hping" class="headerlink" title="主机扫描命令hping"></a><strong>主机扫描命令hping</strong></h3><p>支持使用tcp/ip数据包组装、分析工具</p><p>linux下编译安装</p><p>如果遇到如下错误</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g556megt3vj30oi04et9c.jpg" alt="image-20190719153110732"></p><p>可通过安装下面库解决</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g556sceynmj30ji09274q.jpg" alt="image-20190719153652881"></p><p><a href="http://rpmfind.net/" target="_blank" rel="noopener">http://rpmfind.net/</a></p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g556pk21f9j30xy082do7.jpg" alt="image-20190719153414670"></p><h4 id="hping常用参数"><a href="#hping常用参数" class="headerlink" title="hping常用参数"></a><strong>hping常用参数</strong></h4><p>1、对特定的目标发起tcp探测（规避运营商防火墙、主机等对icmp包屏蔽）</p><p>-p 端口tcp</p><p>-S 设置TCP模式SYN包</p><p>2、伪造来源IP，模拟Ddos攻击</p><p>-a 伪造IP地址</p><p>3、hping使用 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo hping -p 22 -S 10.10.163.233</span><br><span class="line"></span><br><span class="line">sudo hping -p 22 -S 10.10.163.233 -a 10.10.163.235</span><br></pre></td></tr></table></figure><p> centos拒绝掉icmp包设置</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g56489gypsj30kg01mwei.jpg" alt="image-20190720105353473"></p><h3 id="路由扫描"><a href="#路由扫描" class="headerlink" title="路由扫描"></a><strong>路由扫描</strong></h3><p>作用：查询一个主机经过的路由的跳数、及数据延迟情况</p><p>常用工具：traceroute、mtr</p><p>mtr特点：能测出主机到每一个路由间的联通性。</p><p>traceroute连接原理。</p><p>linux下发送udp包（&gt;30000端口），windows发送icmp包。</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g564xl90vhj30pk0i23zb.jpg" alt="image-20190720111813791"></p><p>TTL，生存时间的值。发给第一跳，ttl-1=0，返回udp数据包。</p><p>扫描到几个路由器，发送几个ttl数据包。</p><h4 id="traceroute参数的使用"><a href="#traceroute参数的使用" class="headerlink" title="traceroute参数的使用"></a><strong>traceroute参数的使用</strong></h4><p> linux一般默认有，如果没有安装方式</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5657hwwdpj30mi03gjru.jpg" alt="image-20190720112746947"></p><p>1、默认使用的是udp协议(30000以上的端口)</p><p>2、支持使用TCP协议 -T(发送tcp协议) -p(基于tcp什么端口)</p><p>3、使用ICMP协议介绍 -I </p><p>4、traceroute使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">traceroute www.baidu.com</span><br><span class="line"><span class="comment"># -n 去掉解析</span></span><br><span class="line">traceroute -n www.baidu.com </span><br><span class="line"><span class="comment"># 使用icmp，window默认使用</span></span><br><span class="line">traceroute -In  www.imooc.com</span><br><span class="line"><span class="comment"># 使用tcp才能检测到最终跳数(一般会屏蔽icmp协议)</span></span><br><span class="line">traceroute -T -p 80 -n www.imooc.com</span><br></pre></td></tr></table></figure><h4 id="mtr使用"><a href="#mtr使用" class="headerlink" title="mtr使用"></a>mtr使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum install mtr -y</span><br><span class="line"><span class="comment"># 使用，原理和traceroute一样，可以看到到哪一跳丢包率更为严重</span></span><br><span class="line">mtr www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="批量主机扫描"><a href="#批量主机扫描" class="headerlink" title="批量主机扫描"></a><strong>批量主机扫描</strong></h3><p>目的：</p><p>1、批量主机存活扫描</p><p>2、针对主机服务扫描</p><p>作用：</p><p>1、能快捷的获取主机的存活状态</p><p>2、能更加细致、只能获取主机服务侦查情况</p><p><strong>典型命令</strong></p><p>1、nmap 基于端口扫描，特别强大</p><p>2、ncat 瑞士军刀</p><h4 id="nmap使用"><a href="#nmap使用" class="headerlink" title="nmap使用"></a><strong>nmap使用</strong></h4><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g56dmqgtktj30v60f8dhb.jpg" alt="image-20190720161913675"></p><p>tcp半开放，不建立完整的tcp，未建立完整的三次握手。</p><p>1、主机存活扫描</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 扫描主机存活状态,s检测用什么协议做侦测</span></span><br><span class="line">namp -sP 10.10.140.0/24</span><br></pre></td></tr></table></figure><p>2、主机端口开放扫描，默认扫描范围1-1024，以及一些常用的服务端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namp -sS 10.10.10.163.233</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g56dzj5o2kj30mq0ae400.jpg" alt="image-20190720163117782"></p><p>3、半开放指定端口扫描</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namp -sS -p 0-30000 10.10.163.233</span><br></pre></td></tr></table></figure><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g56e6peru2j30nw0a0t9w.jpg" alt="image-20190720163823202"></p><p>4、全开放连接参数，建立一次全握手，时间长</p><p>建立全握手，可以模拟用户的真实操作请求，需要服务端能检测到相关的日志，打印出相关记录信息。</p><p>建议日常使用半扫描模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sT -p 0-30000 10.10.163.233</span><br></pre></td></tr></table></figure><p> 5、udp协议扫描方式</p><p>扫描udp，响应比较慢、可能特别慢。会限制icmp不可达返回的次数。不建议使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sU 10.10.163.233</span><br></pre></td></tr></table></figure><h4 id="ncat使用"><a href="#ncat使用" class="headerlink" title="ncat使用"></a><strong>ncat使用</strong></h4><p>查看某个路由开放哪些端口80 23</p><p>通过shell交互更改数据 ，可进行任意操作</p><p>nc -lvp 2005 监听端口</p><p><strong>nc好处</strong></p><p>1、不会频繁通过界面登录留下痕迹</p><p>2、登录非常方便</p><p>3、不会被侦测设备侦测到</p><p>-w 设置的超市时间</p><p>-z 一个输入输出模式</p><p>-v 显示命令执行过程</p><p>1、基于tcp协议(默认)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看22端口开放情况</span></span><br><span class="line">nc -zv 10.10.163.233 22</span><br><span class="line"><span class="comment"># 查看一些端口开放 超时2s</span></span><br><span class="line">nc -zv -w2 10.10.163.233 1-50</span><br></pre></td></tr></table></figure><p>2、基于udp协议 -u  </p><p>回应时间长，不建议使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看一些端口开放 超时2s</span></span><br><span class="line">nc -zv -u -w2 10.10.163.233 1-50</span><br></pre></td></tr></table></figure><h3 id="预防策略"><a href="#预防策略" class="headerlink" title="预防策略"></a><strong>预防策略</strong></h3><p>在linux进行防御。</p><p>常见攻击方法：</p><p>1、SYN攻击</p><p>2、DDoS攻击</p><p>3、恶意扫描</p><p>什么是SYN攻击？</p><p>利用TCP协议缺陷进行，导致系统服务停止响应，网络带宽跑满或者响应缓慢。</p><p>什么是DDoS攻击？</p><p>分布式拒绝访问服务攻击。</p><p>正常服务在同一时间接到了很多个类似于正常服务的请求，也有可能是完全正常的请求，导致服务响应不过来。</p><p>SYN攻击一般会伴随着DDoS攻击进行</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g56eutfdydj30qq0ikgmc.jpg" alt="image-20190720170129641"></p><p>SYN攻击原理，eg可以利用hping伪造源ip，发送给假的主机，得不到第三次请求。目标机器不断发送重试，不停回应包，就会导致网络带宽占满。</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g56f1z4xe1j30og0iuq3m.jpg" alt="image-20190720170357218"></p><ul><li><p>减少重试次数</p></li><li><p>可以增加backlog</p></li><li><p>禁止三次握手，SYN cookies技术</p></li></ul><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g56f1r9lamj30m40c40x8.jpg" alt="image-20190720170816652"></p><p>linux下其他预防策略</p><p>1、防火墙上面做相关设置</p><p>2、linux下面可以关闭icmp协议请求</p><p>3、通过iptables防止扫描</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g56f53ibkej30xc0bqmyd.jpg" alt="image-20190720171122849"></p><blockquote><p>学习笔记整理自慕课网以下课程:<br>linux系统扫描命令和安全防范笔记</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;本文主要介绍了一些常用的网络扫描工具以及安全防范，了解更多命令的使用。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="hping" scheme="https://annecoding.github.io/tags/hping/"/>
    
      <category term="traceroute" scheme="https://annecoding.github.io/tags/traceroute/"/>
    
      <category term="Nmap" scheme="https://annecoding.github.io/tags/Nmap/"/>
    
      <category term="Ncap" scheme="https://annecoding.github.io/tags/Ncap/"/>
    
      <category term="fping" scheme="https://annecoding.github.io/tags/fping/"/>
    
  </entry>
  
  <entry>
    <title>linux下占用cpu和内存top10</title>
    <link href="https://annecoding.github.io/2019/06/15/linux%E4%B8%8B%E5%8D%A0%E7%94%A8cpu%E5%92%8C%E5%86%85%E5%AD%98%E5%BE%88%E9%AB%98%E7%9A%84%E8%BF%9B%E7%A8%8B/"/>
    <id>https://annecoding.github.io/2019/06/15/linux下占用cpu和内存很高的进程/</id>
    <published>2019-06-15T06:00:21.000Z</published>
    <updated>2019-09-01T04:58:41.496Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>服务器访问变慢，那么到底是什么进程导致服务器资源变慢呢？我们可以根据cpu、内存等查看占用资源较高的进程。</p><a id="more"></a><p>可以通过ps命令的相关操作来查看。这里分别找出最高占用cpu和内存的10个进程，实现脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat cpu_memory_top.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 查看占用cpu、内存过高的进程</span></span><br><span class="line"><span class="comment"># 占用cpu内存过高的前十个进程</span></span><br><span class="line"><span class="comment"># -e 显示所有程序 -o 使用用户自定义格式 --sort排序</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"--------    cpu top10   ---------"</span></span><br><span class="line">ps -eo user,pid,pcpu,pmem,args --sort=-pcpu |head -n 10</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"--------  memory top10  ---------"</span></span><br><span class="line">ps -eo user,pid,pcpu,pmem,args --sort=-pmem |head -n 10</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ ./cpu_memory_top.sh   </span><br><span class="line">--------    cpu top10   ---------</span><br><span class="line">USER       PID %CPU %MEM COMMAND</span><br><span class="line">root      1066  0.3  0.6 /usr/<span class="built_in">local</span>/aegis/aegis_client/aegis_10_69/AliYunDun</span><br><span class="line">root         1  0.0  0.1 /usr/lib/systemd/systemd --switched-root --system --deserialize 21</span><br><span class="line">root         2  0.0  0.0 [kthreadd]</span><br><span class="line">root         3  0.0  0.0 [ksoftirqd/0]</span><br><span class="line">root         5  0.0  0.0 [kworker/0:0H]</span><br><span class="line">root         7  0.0  0.0 [migration/0]</span><br><span class="line">root         8  0.0  0.0 [rcu_bh]</span><br><span class="line">root         9  0.0  0.0 [rcu_sched]</span><br><span class="line">root        10  0.0  0.0 [watchdog/0]</span><br><span class="line">--------  memory top10  ---------</span><br><span class="line">USER       PID %CPU %MEM COMMAND</span><br><span class="line">root       683  0.0  1.8 /sbin/dhclient -H localhost -1 -q -lf /var/lib/dhclient/dhclient--eth0.lease -pf /var/run/dhclient-eth0.pid eth0</span><br><span class="line">root       328  0.0  1.5 /usr/lib/systemd/systemd-journald</span><br><span class="line">root       765  0.0  0.8 /usr/bin/python -Es /usr/sbin/tuned -l -P</span><br><span class="line">polkitd    458  0.0  0.6 /usr/lib/polkit-1/polkitd --no-debug</span><br><span class="line">root      1066  0.3  0.6 /usr/<span class="built_in">local</span>/aegis/aegis_client/aegis_10_69/AliYunDun</span><br><span class="line">root       767  0.0  0.4 /usr/sbin/rsyslogd -n</span><br><span class="line">root     11661  0.0  0.3 sshd: root@notty</span><br><span class="line">root     11752  0.0  0.2 sshd: root@pts/0</span><br><span class="line">root      2166  0.0  0.2 /usr/sbin/aliyun-service</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;服务器访问变慢，那么到底是什么进程导致服务器资源变慢呢？我们可以根据cpu、内存等查看占用资源较高的进程。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Centos" scheme="https://annecoding.github.io/tags/Centos/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>linux中玩转sed技巧分享</title>
    <link href="https://annecoding.github.io/2019/06/11/linux%E4%B8%AD%E7%8E%A9%E8%BD%ACsed/"/>
    <id>https://annecoding.github.io/2019/06/11/linux中玩转sed/</id>
    <published>2019-06-11T10:51:19.000Z</published>
    <updated>2019-09-01T11:39:38.161Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p><code>sed</code>命令应用广泛，使用简单，是快速文本处理的利器。它其实没多少技巧，背诵、使用是最合适的学习渠道，属于硬技能。但它又很复杂，因为高级功能太多。本篇不去关注sed的高级功能，仅对常用的一些操作，进行说明。<br><a id="more"></a></p><h3 id="sed使用"><a href="#sed使用" class="headerlink" title="sed使用"></a>sed使用</h3><p>sed编辑器被称作流编辑器，它和vim这种的交互式文本编辑器不同，是根据命令来处理数据流中的数据。会执行下列操作：</p><ul><li>一次从输入中读取一行数据（重复该操作直到全部行被读取完）</li><li>根据编辑器命令匹配数据</li><li>按照命令修改数据流中的数据</li><li>将新数据输出到STDOUT(标准输出)</li></ul><p>其中sed命令的可以从命令行中输入，也可以从一个命令文件中读取。</p><p><strong>sed</strong>命令的格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用格式</span></span><br><span class="line">$ sed options script file</span><br><span class="line"><span class="comment"># 添加script中指定的命令</span></span><br><span class="line">$ sed -e script </span><br><span class="line"><span class="comment"># 添加file中指定的命令</span></span><br><span class="line">$ sed -f file </span><br><span class="line"><span class="comment"># 不产生命令输出，使用print命令来完成输出</span></span><br><span class="line"><span class="comment"># -n 这个参数是--quiet或者--silent的意思。表明忽略执行过程的输出，只输出我们的结果即可。</span></span><br><span class="line">$ sed -n</span><br></pre></td></tr></table></figure><h3 id="替换命令s"><a href="#替换命令s" class="headerlink" title="替换命令s"></a>替换命令s</h3><p><code>s</code>命令会用斜线间指定的<strong>第二个</strong>文本字符串来<strong>替换第一个</strong>文本字符串模式。</p><p>1.用big test替换了test。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"This is a test"</span> | sed <span class="string">'s/test/big test/'</span></span><br><span class="line">This is a big <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>2.用<strong>cat</strong>替换整个文件中的<strong>dog</strong></p><p>示例文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat data1.txt</span><br><span class="line">The quick brown fox jumps over the lazy dog.</span><br><span class="line">The quick brown fox jumps over the lazy dog.</span><br><span class="line">The quick brown fox jumps over the lazy dog.</span><br><span class="line">The quick brown fox jumps over the lazy dog.</span><br></pre></td></tr></table></figure><p>使用sed命令进行替换：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'s/dog/cat/'</span> data1.txt</span><br><span class="line">The quick brown fox jumps over the lazy cat.</span><br><span class="line">The quick brown fox jumps over the lazy cat.</span><br><span class="line">The quick brown fox jumps over the lazy cat.</span><br><span class="line">The quick brown fox jumps over the lazy cat.</span><br></pre></td></tr></table></figure><p>🌟 重要的是，要记住，<strong>sed编辑器并不会修改文本文件的数据</strong>。它只会将修改后的数据发送到STDOUT。<strong>如果你查看原来的文本文件，它仍然保留着原始数据。</strong></p><p>3.在命令行使用多个编辑器命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e <span class="string">'s/brown/green/; s/dog/cat/'</span> data1.txt</span><br><span class="line">The quick green fox jumps over the lazy cat.</span><br><span class="line">The quick green fox jumps over the lazy cat.</span><br><span class="line">The quick green fox jumps over the lazy cat.</span><br><span class="line">The quick green fox jumps over the lazy cat.</span><br></pre></td></tr></table></figure><p>4.从文件中读取编辑器命令</p><p>如果有大量要处理的sed命令，那么将它们放进一个单独的文件中通常会更方便一些。<br>可以在sed命令中用<code>-f</code>选项来指定文件。</p><p>示例sed编辑器脚本文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat script1.sed</span><br><span class="line">s/brown/green/</span><br><span class="line">s/fox/elephant/</span><br><span class="line">s/dog/cat/</span><br></pre></td></tr></table></figure><p>执行sed编辑器脚本文件，按照脚本文件替换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed -f script1.sed data1.txt</span><br><span class="line">The quick green elephant jumps over the lazy cat.</span><br><span class="line">The quick green elephant jumps over the lazy cat.</span><br><span class="line">The quick green elephant jumps over the lazy cat.</span><br><span class="line">The quick green elephant jumps over the lazy cat.</span><br></pre></td></tr></table></figure><h3 id="更多替换选项"><a href="#更多替换选项" class="headerlink" title="更多替换选项"></a>更多替换选项</h3><h4 id="替换标记"><a href="#替换标记" class="headerlink" title="替换标记"></a>替换标记</h4><p>替换命令在替换多行中的文本时能正常工作，但默认情况下它只替换每行中出现的第一处。要让替换命令能够替换一行中不同地方出现的文本必须使用替换标记（substitution flag）。</p><p>替换标记会在替换命令字符串之后设置。格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s/pattern/replacement/flags</span><br></pre></td></tr></table></figure><p>有4种可用的替换标记：</p><ul><li>数字，表明新文本将替换第几处模式匹配的地方；</li><li>g，表明新文本将会替换所有匹配的文本；</li><li>p，表明原先行的内容要打印出来；</li><li>w file，将替换的结果写到文件中。</li></ul><p>示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sed编辑器只替换每行中第二次出现的匹配模式</span></span><br><span class="line">$ sed <span class="string">'s/test/trial/2'</span> data4.txt</span><br><span class="line">This is a <span class="built_in">test</span> of the trial script.</span><br><span class="line">This is the second <span class="built_in">test</span> of the trial script. </span><br><span class="line"><span class="comment"># g替换标记使你能替换文本中匹配模式所匹配的每处地方</span></span><br><span class="line">$ sed <span class="string">'s/test/trial/g'</span> data4.txt</span><br><span class="line">This is a trial of the trial script.</span><br><span class="line">This is the second trial of the trial script. </span><br><span class="line"><span class="comment"># p替换标记会打印与替换命令中指定的模式匹配的行。-n选项将禁止sed编辑器输出。</span></span><br><span class="line"><span class="comment"># p -n只输出被替换命令修改过的行。</span></span><br><span class="line">$ cat data5.txt</span><br><span class="line">This is a <span class="built_in">test</span> line.</span><br><span class="line">This is a different line.</span><br><span class="line">$ sed -n <span class="string">'s/test/trial/p'</span> data5.txt</span><br><span class="line">This is a trial line. </span><br><span class="line"><span class="comment"># w替换标记会产生同样的输出，不过会将输出保存到指定文件中。</span></span><br><span class="line">$ sed <span class="string">'s/test/trial/w test.txt'</span> data5.txt</span><br><span class="line">This is a trial line.</span><br><span class="line">This is a different line.</span><br><span class="line">$ cat test.txt</span><br><span class="line">This is a trial line.</span><br></pre></td></tr></table></figure><p>🌟  sed并没有对文件内容进行改变，因此如果要写回文件，可以使用重定向。</p><p>1.通过重定向写入新文件，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">"s/dog/cat/g"</span> data1.txt &gt; data1new.txt</span><br></pre></td></tr></table></figure><p>或者使用<code>-i</code>参数直接修改文件内容，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -i <span class="string">"s/dog/cat/g"</span> data1.txt</span><br></pre></td></tr></table></figure><p>2.在每一行前面添加内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'s/^/#/g'</span> data1.txt</span><br><span class="line"><span class="comment">#the quick brown fox jumps over the lazy dog.</span></span><br><span class="line"><span class="comment">#the quick brown fox jumps over the lazy dog.</span></span><br><span class="line"><span class="comment">#the quick brown fox jumps over the lazy dog.</span></span><br><span class="line"><span class="comment">#the quick brown fox jumps over the lazy dog.</span></span><br></pre></td></tr></table></figure><p>3.在每一行最后添加内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'s/$/---/g'</span> data1.txt</span><br><span class="line">the quick brown fox jumps over the lazy dog.---</span><br><span class="line">the quick brown fox jumps over the lazy dog.---</span><br><span class="line">the quick brown fox jumps over the lazy dog.---</span><br><span class="line">the quick brown fox jumps over the lazy dog.---</span><br></pre></td></tr></table></figure><p>顺便介绍一下正则表达式的一些最基本的东西：</p><ul><li><code>^</code> 表示一行的开头。如：<code>/^#/</code> 以#开头的匹配。</li><li><code>$</code> 表示一行的结尾。如：<code>/}$/</code> 以}结尾的匹配。</li><li><code>\&lt;</code> 表示词首。 如：<code>\&lt;abc</code> 表示以 abc 为首的詞。</li><li><code>\&gt;</code> 表示词尾。 如：<code>abc\&gt;</code> 表示以 abc 結尾的詞。</li><li><code>.</code> 通配符，表示几乎任意字符，除了换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号 … 中的每个点，此处省略了无数个字（什么情况都可能发生）。</li><li><code>?</code>表示某个字符出现了0次或1次。</li><li><code>*</code>表示某个字符出现了0次或多次。</li><li><code>+</code>表示某个字符出现了1次或多次。</li><li><code>[ ]</code> 字符集合。 如：<code>[abc]</code> 表示匹配a或b或c，还有 <code>[a-zA-Z]</code> 表示匹配所有的26个字符。如果其中有^表示反，如 <code>[^a]</code> 表示非a的字符。还有<code>[0-9]</code> 匹配括号中的任何一个字符。</li><li><code>{m}</code>前面的匹配重复m次，<code>{m,n}</code> 前面的匹配重复m到n次</li></ul><p>💡 强大到无往不利的正则表达式简单示例，比如去除下面html中的tags:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;This&lt;/b&gt; is what &lt;span style=<span class="string">"text-decoration: underline;"</span>&gt;I&lt;/span&gt; meant. Understand?</span><br></pre></td></tr></table></figure></p><p>sed命令实现：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果你这样搞的话，就会有问题，贪婪模式，匹配(&lt;)到(&gt;)之间的所有内容</span></span><br><span class="line">$ sed <span class="string">'s/&lt;.*&gt;//g'</span> html.txt</span><br><span class="line"> meant. Understand</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 要解决上面的那个问题，就得像下面这样。</span></span><br><span class="line"><span class="comment"># 其中的'[^&gt;]' 指定了除了&gt;的字符重复0次或多次。</span></span><br><span class="line">$ sed <span class="string">'s/&lt;[^&gt;]*&gt;//g'</span> html.txt</span><br><span class="line">This is what I meant. Understand?</span><br></pre></td></tr></table></figure></p><p>💡 <strong>其他有趣示例</strong></p><p>1.输出长度不小于50个字符的行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="string">'/^.&#123;50&#125;/p'</span></span><br></pre></td></tr></table></figure><p>2.统计文件中有每个单词出现了多少次</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'s/ /\n/g'</span> file | sort | uniq -c</span><br></pre></td></tr></table></figure><p>3.查找目录中的py文件，删掉所有行级注释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find ./ -name <span class="string">"*.py"</span> | xargs sed  -i.bak <span class="string">'/^[ ]*#/d'</span></span><br></pre></td></tr></table></figure><p>4.查看第5-7行和10-13行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n -e <span class="string">'5,7p'</span> -e <span class="string">'10,13p'</span> file</span><br></pre></td></tr></table></figure><p>5.仅输出ip地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip route show | sed -n <span class="string">'/src/p'</span> | sed -e <span class="string">'s/  */ /g'</span> | cut -d<span class="string">' '</span> -f9</span><br></pre></td></tr></table></figure><h3 id="使用地址"><a href="#使用地址" class="headerlink" title="使用地址"></a>使用地址</h3><p>默认情况下，在sed编辑器中使用的命令会作用于文本数据的所有行。如果只想将命令作用于特定行或某些行，则必须用行寻址（line addressing）。</p><h4 id="数字方式寻址"><a href="#数字方式寻址" class="headerlink" title="数字方式寻址"></a>数字方式寻址</h4><p>sed编辑器会将文本流中的第一行编号为1，然后继续按顺序为接下来的行分配行号。</p><p>1.只修改第二行的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'2s/dog/cat/'</span> data1.txt</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br></pre></td></tr></table></figure><p>2.修改第二行和第三行，使用行地址区间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'2,3s/dog/cat/'</span> data1.txt</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br></pre></td></tr></table></figure><p>3.也可以匹配从文本中某行开始到结束的所有行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'2,$s/dog/cat/'</span> data1.txt</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br></pre></td></tr></table></figure><h4 id="使用文本过滤器"><a href="#使用文本过滤器" class="headerlink" title="使用文本过滤器"></a>使用文本过滤器</h4><p>sed编辑器允许指定文本模式来过滤出命令要作用的行。格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/pattern/<span class="built_in">command</span></span><br></pre></td></tr></table></figure><p>必须用正斜线将要指定的pattern封起来。sed编辑器会将该命令作用到包含指定文本模式的行上。</p><p>举个栗子🌰来说明一下吧，在<code>/etc/passwd</code>中只修改用户Samantha的默认shell，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ grep Samantha /etc/passwd</span><br><span class="line">Samantha:x:502:502::/home/Samantha:/bin/bash</span><br><span class="line">$ sed <span class="string">'/Samantha/s/bash/csh/'</span> /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">[...]</span><br><span class="line">Christine:x:501:501:Christine B:/home/Christine:/bin/bash</span><br><span class="line">Samantha:x:502:502::/home/Samantha:/bin/csh</span><br><span class="line">Timothy:x:503:503::/home/Timothy:/bin/bash</span><br></pre></td></tr></table></figure><h3 id="删除行"><a href="#删除行" class="headerlink" title="删除行"></a>删除行</h3><p>使用删除命令d对文本进行删除操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有文本</span></span><br><span class="line">sed <span class="string">'d'</span> data1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除单行</span></span><br><span class="line">sed <span class="string">'2d'</span> data1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除行区间[2,3]</span></span><br><span class="line">sed <span class="string">'2,3d'</span> data1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除行区间[2,endline]</span></span><br><span class="line">sed <span class="string">'2,$d'</span> data1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除匹配文本aa的行</span></span><br><span class="line">sed <span class="string">'/aa/d'</span> data1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除两个匹配文本之间的文本 匹配到1和3的行之间的文本全部被删除</span></span><br><span class="line">sed <span class="string">'/1/,/3/d'</span> data1.txt</span><br></pre></td></tr></table></figure><h3 id="插入、附加文本"><a href="#插入、附加文本" class="headerlink" title="插入、附加文本"></a>插入、附加文本</h3><p>1.插入命令<code>i</code>在指定行前增加新行</p><p>2.附加命令<code>a</code>在指定行后增加新行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 追加</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"Test Line 2"</span> | sed <span class="string">'a\Test Line 1'</span></span><br><span class="line">Test Line 2</span><br><span class="line">Test Line 1 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"Test Line 2"</span> | sed <span class="string">'i\Test Line 1'</span></span><br><span class="line">Test Line 1</span><br><span class="line">Test Line 2</span><br></pre></td></tr></table></figure><h3 id="修改行"><a href="#修改行" class="headerlink" title="修改行"></a>修改行</h3><p>使用<code>c</code>命令来修改一行数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改第三行文本</span></span><br><span class="line">$ sed <span class="string">'3c\</span></span><br><span class="line"><span class="string">This is a changed line of text.'</span> data1.txt</span><br><span class="line">the quick brown fox jumps over the lazy dog.</span><br><span class="line">the quick brown fox jumps over the lazy dog.</span><br><span class="line">This is a changed line of text.</span><br><span class="line">the quick brown fox jumps over the lazy dog.</span><br></pre></td></tr></table></figure><h3 id="转换命令"><a href="#转换命令" class="headerlink" title="转换命令"></a>转换命令</h3><p>命令格式<code>sed &#39;y/inchar/outchar&#39;</code></p><p>将inchar中的字符一一对应地转换成outchar的字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"This 1 is a test of 1 try."</span> | sed <span class="string">'y/123/456/'</span></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">This 4 is a <span class="built_in">test</span> of 4 try.</span><br></pre></td></tr></table></figure><p>💡 如你在输出中看到的，inchars模式中指定字符的<strong>每个实例都会被替换成outchars模式中</strong><br><strong>相同位置的那个字符。</strong></p><h3 id="打印命令"><a href="#打印命令" class="headerlink" title="打印命令"></a>打印命令</h3><p>1.打印数据文本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"this is a test"</span> | sed <span class="string">'p'</span></span><br><span class="line">this is a <span class="built_in">test</span></span><br><span class="line">this is a <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>2.打印包含匹配文本模式的行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line"><span class="comment"># 模式匹配</span></span><br><span class="line">$ sed -n <span class="string">'/number 3/p'</span> data6.txt</span><br><span class="line">This is line number 3. </span><br><span class="line"><span class="comment"># 从一个模式到另一个模式</span></span><br><span class="line">$ sed -n <span class="string">'/number 2/,/number 3/p'</span> data6.txt</span><br><span class="line">this is line number 2.</span><br><span class="line">this is line number 3.</span><br></pre></td></tr></table></figure><p>3.快速打印数据流中的某些行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="string">'2,3p'</span> data6.txt</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br></pre></td></tr></table></figure><p>4.从第一行打印匹配3成功的那一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="string">'1,/3/p'</span> data6.txt</span><br><span class="line">this is line number 1.</span><br><span class="line">this is line number 2.</span><br><span class="line">this is line number 3.</span><br></pre></td></tr></table></figure><blockquote><p>参考链接：<br><a href="https://coolshell.cn/articles/9104.html" target="_blank" rel="noopener">SED 简明教程</a><br><a href="https://juejin.im/post/5ce5190b5188252dbb08baa8" target="_blank" rel="noopener">Linux生产环境上，最常用的一套“Sed“技巧</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;&lt;code&gt;sed&lt;/code&gt;命令应用广泛，使用简单，是快速文本处理的利器。它其实没多少技巧，背诵、使用是最合适的学习渠道，属于硬技能。但它又很复杂，因为高级功能太多。本篇不去关注sed的高级功能，仅对常用的一些操作，进行说明。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="sed" scheme="https://annecoding.github.io/tags/sed/"/>
    
  </entry>
  
  <entry>
    <title>linux中玩转awk技巧分享</title>
    <link href="https://annecoding.github.io/2019/06/10/linux%E4%B8%AD%E7%8E%A9%E8%BD%ACawk/"/>
    <id>https://annecoding.github.io/2019/06/10/linux中玩转awk/</id>
    <published>2019-06-10T01:22:36.000Z</published>
    <updated>2019-09-01T11:39:33.992Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p><strong>awk</strong>其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</p><a id="more"></a><h3 id="awk简明教程"><a href="#awk简明教程" class="headerlink" title="awk简明教程"></a>awk简明教程</h3><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑（擅长取行），awk（擅长取列）在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p><p>awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。</p><p><strong>awk</strong>简单来讲：<strong>取文件中的某列数据</strong>。</p><p>通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种</span></span><br><span class="line">awk <span class="string">'&#123;pattern + action&#125;'</span> &#123;filenames&#125;</span><br><span class="line"><span class="comment"># 第二种</span></span><br><span class="line">awk [可选的命令行选项] <span class="string">'BEGIN&#123;命令 &#125; pattern&#123; 命令 &#125; END&#123; 命令 &#125;'</span>  文件名</span><br></pre></td></tr></table></figure><p>关于第二种方式，解释如下：</p><p>1.<strong>BEGIN 开头部分</strong>，可选的。用来设置一些参数，输出一些表头，定义一些变量等。上面的命令仅打印了一行信息而已。</p><p>2.<strong>END 结尾部分</strong>，可选的。用来计算一些汇总逻辑，或者输出这些内容。上面的命令，使用简单的for循环，输出了数组rt中的内容。</p><p>3.<strong>Pattern 匹配部分</strong>，依然可选。用来匹配一些需要处理的行。上面的命令，只匹配tcp开头的行，其他的不进入处理。</p><p>4.<strong>Action 模块</strong>。主要逻辑体，按行处理，统计打印，都可以。</p><h3 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h3><p>1.首先保存一个示例文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat netstat </span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2036/sshd           </span><br><span class="line">tcp6       0      0 :::7500                 :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::7000                 :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::443                  :::*                    LISTEN      17767/./frps</span><br></pre></td></tr></table></figure><p>2.输出第一列和第四列</p><ul><li>其中<strong>单引号</strong>中被大括号括着的就是<strong>awk语句</strong>，<strong>只能被单引号包含</strong>。</li><li><code>$1..$n</code>表示<strong>第几列</strong>，<code>$0</code>表示<strong>整行</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'&#123;print $1,$4&#125;'</span> netstat </span><br><span class="line">Active (only</span><br><span class="line">Proto Local</span><br><span class="line">tcp 0.0.0.0:22</span><br><span class="line">tcp6 :::7500</span><br><span class="line">tcp6 :::80</span><br><span class="line">tcp6 :::7000</span><br><span class="line">tcp6 :::443</span><br><span class="line"></span><br><span class="line">$ cat /etc/passwd |awk  -F <span class="string">':'</span>  <span class="string">'&#123;print $1&#125;'</span>  </span><br><span class="line">root</span><br><span class="line">daemon</span><br><span class="line">bin</span><br><span class="line">sys</span><br></pre></td></tr></table></figure><h3 id="过滤记录"><a href="#过滤记录" class="headerlink" title="过滤记录"></a>过滤记录</h3><p>1.awk可以对其中的某些字段进行判断，通过与或非连接。awk 中的比较运算符用于比较字符串和或者数值，包括以下类型：</p><ul><li><code>&gt;</code> – 大于</li><li><code>&lt;</code> – 小于</li><li><code>&gt;=</code> – 大于等于</li><li><code>&lt;=</code> – 小于等于</li><li><code>==</code> – 等于</li><li><code>!=</code> – 不等于</li><li><code>some_value ~ / pattern/</code> – 如果 some_value 匹配模式 pattern，则返回 true</li><li><code>some_value !~ / pattern/</code> – 如果 some_value 不匹配模式 pattern，则返回 true</li></ul><p>如以下常用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'$1=="tcp" &amp;&amp; $6=="LISTEN" '</span> netstat  </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2036/sshd   </span><br><span class="line"><span class="comment"># 需要表头的话，可以引入内建变量NR</span></span><br><span class="line">$ awk <span class="string">'$1=="tcp" &amp;&amp; $6=="LISTEN" || NR==2 '</span> netstat  </span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2036/sshd </span><br><span class="line"><span class="comment"># NR也可以用来打印行号</span></span><br><span class="line">$ awk <span class="string">'$1=="tcp6" &#123; print NR,$0 &#125;'</span> netstat  </span><br><span class="line">4 tcp6       0      0 :::7500                 :::*                    LISTEN      17767/./frps        </span><br><span class="line">5 tcp6       0      0 :::80                   :::*                    LISTEN      17767/./frps        </span><br><span class="line">6 tcp6       0      0 :::7000                 :::*                    LISTEN      17767/./frps        </span><br><span class="line">7 tcp6       0      0 :::443                  :::*                    LISTEN      17767/./frps</span><br></pre></td></tr></table></figure><h3 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h3><p>程序已经定义好的变量，可以直接来使用，以下常见的变量。</p><table><thead><tr><th style="text-align:left">变量</th><th>释义</th></tr></thead><tbody><tr><td style="text-align:left"><code>$0</code></td><td>当前记录（这个变量中存放着整个行的内容）</td></tr><tr><td style="text-align:left"><code>$1~$n</code></td><td>当前记录的第n个字段，字段间由FS分隔</td></tr><tr><td style="text-align:left"><code>FS</code></td><td>输入字段分隔符 默认是空格或Tab</td></tr><tr><td style="text-align:left"><code>NF</code></td><td>当前记录中的字段个数，就是有多少列</td></tr><tr><td style="text-align:left"><code>NR</code></td><td>已经读出的记录数，就是行号，从1开始，如果有多个文件话，不断累加。</td></tr><tr><td style="text-align:left"><code>FNR</code></td><td>当前记录数，与NR不同的是，这个值会是各个文件自己的行号</td></tr><tr><td style="text-align:left"><code>RS</code></td><td>输入的记录分隔符， 默认为换行符</td></tr><tr><td style="text-align:left"><code>OFS</code></td><td>输出字段分隔符， 默认也是空格</td></tr><tr><td style="text-align:left"><code>ORS</code></td><td>输出的记录分隔符，默认为换行符</td></tr><tr><td style="text-align:left"><code>FILENAME</code></td><td>当前输入文件的名字</td></tr></tbody></table><p>❈ ❈ ❈   <strong>一般的开发语言，数组下标是以0开始的，但awk的列$是以1开始的，而0指的是原始字符串。</strong></p><p>1.输出表头、行号及特定列</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用内建变量NR、FNR输出行号以及表头</span></span><br><span class="line">$ awk <span class="string">'$3==0 &amp;&amp; $6=="LISTEN" || NR==2 &#123;print NR,FNR,$1,$3,$6&#125;'</span> netstat</span><br><span class="line">2 2 Proto Send-Q Foreign</span><br><span class="line">3 3 tcp 0 LISTEN</span><br><span class="line">4 4 tcp6 0 LISTEN</span><br><span class="line">5 5 tcp6 0 LISTEN</span><br><span class="line">6 6 tcp6 0 LISTEN</span><br><span class="line">7 7 tcp6 0 LISTEN</span><br></pre></td></tr></table></figure><p>2.使用分隔符来输出特定的行或者列，下面👇两个命令等价：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;FS=":"&#125; &#123;print $1, $7&#125;'</span> /etc/passwd | head -n 4</span><br><span class="line">root /bin/bash</span><br><span class="line">bin /sbin/nologin</span><br><span class="line">daemon /sbin/nologin</span><br><span class="line">adm /sbin/nologin</span><br><span class="line"></span><br><span class="line"><span class="comment"># -F指定域分隔符为':'</span></span><br><span class="line">$ cat /etc/passwd |awk  -F <span class="string">':'</span>  <span class="string">'&#123;print $1"\t"$7&#125;'</span> | head -n 4</span><br><span class="line">root    /bin/bash</span><br><span class="line">bin     /sbin/nologin</span><br><span class="line">daemon  /sbin/nologin</span><br><span class="line">adm     /sbin/nologin</span><br></pre></td></tr></table></figure><p>❈ ❈ ❈  如果要是用多个分隔符，可以使用下面方式来指定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F <span class="string">'[;:]'</span></span><br></pre></td></tr></table></figure><p>3.自定义以<code>\t</code>作为分隔符输出的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F: <span class="string">'&#123;print $1,$7&#125;'</span> OFS=<span class="string">"\t"</span> /etc/passwd | head -n 4</span><br><span class="line">root    /bin/bash</span><br><span class="line">bin     /sbin/nologin</span><br><span class="line">daemon  /sbin/nologin</span><br><span class="line">adm     /sbin/nologin</span><br></pre></td></tr></table></figure><h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><p>1.像<strong>grep</strong>一样匹配相关字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只匹配80的字符</span></span><br><span class="line">$ awk <span class="string">'/80/'</span> netstat</span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      17767/./frps  </span><br><span class="line"><span class="comment"># 匹配80、或者7000、或者tcp6的相关字符</span></span><br><span class="line">$ awk <span class="string">'/80|7000|tcp6/'</span> netstat  </span><br><span class="line">tcp6       0      0 :::7500                 :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::7000                 :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::443                  :::*                    LISTEN      17767/./frps</span><br></pre></td></tr></table></figure><p>2.精确的匹配某个字段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $4匹配第四列的数据</span></span><br><span class="line">$ awk <span class="string">'$4 ~/80|7000/ &#123;print $0&#125;'</span> netstat </span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::7000                 :::*                    LISTEN      17767/./frps   </span><br><span class="line"><span class="comment"># 搜索包含System关键字的行并输出</span></span><br><span class="line">$ cat -n /etc/passwd | gawk -F: <span class="string">'/System/&#123;print $1" "$5&#125;'</span></span><br><span class="line">    17  dbus System message bus</span><br></pre></td></tr></table></figure><p> ❈ ❈ ❈  <strong>其实 <code>~</code>表示模式开始。<code>/ /</code>中是模式。这就是一个正则表达式的匹配。</strong></p><p>对此模式取反的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串匹配取反</span></span><br><span class="line">$ awk <span class="string">'!/80/'</span> netstat                      </span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2036/sshd           </span><br><span class="line">tcp6       0      0 :::7500                 :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::7000                 :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::443                  :::*                    LISTEN      17767/./frps </span><br><span class="line"><span class="comment"># 精确匹配取反</span></span><br><span class="line">$ awk <span class="string">'$4 !~/80|7000/ &#123;print $0&#125;'</span> netstat    </span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2036/sshd           </span><br><span class="line">tcp6       0      0 :::7500                 :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::443                  :::*                    LISTEN      17767/./frps</span><br></pre></td></tr></table></figure><h3 id="拆分文件"><a href="#拆分文件" class="headerlink" title="拆分文件"></a>拆分文件</h3><p>1.指定某列为分类符，使用<strong>重定向</strong>就可以导出到不同的文件中，例如下列语句通过第1列进行分割：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照第1列拆分文件，第一列有tcp、tcp6两种类型</span></span><br><span class="line"><span class="comment"># 所以按照类型命名，当前目录下会多两个文件</span></span><br><span class="line">$ awk <span class="string">'NR!=2&#123;print &gt; $1&#125;'</span> netstat  </span><br><span class="line">$ cat tcp</span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2036/sshd           </span><br><span class="line">$ ls</span><br><span class="line">netstat  tcp  tcp6</span><br></pre></td></tr></table></figure><p>2.也可以把<strong>指定的列</strong>追加<code>&gt;&gt;</code>到文件，追加不会覆盖源文件，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'NR!=1&#123;print $4,$7 &gt;&gt; $1&#125;'</span> netstat</span><br><span class="line">$ cat tcp</span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2036/sshd           </span><br><span class="line">0.0.0.0:22 2036/sshd</span><br></pre></td></tr></table></figure><p>3.也可以使用复杂的表达式（例如if-else-if语句，awk是个脚本解释器）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'NR!=1&#123;if($4 ~ /80|443/) print &gt; "1.txt";         </span></span><br><span class="line"><span class="string">else if($4 ~/7000/) print &gt; "2.txt";</span></span><br><span class="line"><span class="string">else print &gt; "3.txt" &#125;'</span> netstat</span><br><span class="line">$ ls ?.txt</span><br><span class="line">1.txt  2.txt  3.txt    </span><br><span class="line">$ cat 1.txt</span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::443                  :::*                    LISTEN      17767/./frps </span><br><span class="line">$ cat 2.txt</span><br><span class="line">tcp6       0      0 :::7000                 :::*                    LISTEN      17767/./frps </span><br><span class="line"><span class="comment"># 其中NR!=1，不取第一行数据</span></span><br><span class="line"><span class="comment"># 这是第一行数据Active Internet connections (only servers)</span></span><br><span class="line"><span class="comment"># else print &gt; "3.txt" 匹配的是非前两列匹配到的其他内容，注意if和else if要对相同列数据进行操作，不然可能输出内容有问题</span></span><br><span class="line">$ cat 3.txt</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2036/sshd           </span><br><span class="line">tcp6       0      0 :::7500                 :::*                    LISTEN      17767/./frps</span><br></pre></td></tr></table></figure><h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>1.统计某个文件夹下的文件占用的字节数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l |awk <span class="string">'BEGIN &#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print "[end]size is ", size&#125;'</span></span><br><span class="line">[end]size is  8657198</span><br></pre></td></tr></table></figure><p> 如果以M为单位显示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l |awk <span class="string">'BEGIN &#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print "[end]size is ", size/1024/1024,"M"&#125;'</span> </span><br><span class="line">[end]size is  8.25889 M</span><br></pre></td></tr></table></figure><p>注意，统计不包括文件夹的子目录。</p><p>2.统计以.txt为后缀的文件总大小：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ll *.txt | awk <span class="string">'&#123;sum+=$5&#125; END &#123;print sum&#125;'</span></span><br><span class="line">769.9</span><br></pre></td></tr></table></figure><p>3.统计文件夹下的文件数目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -lha | gawk <span class="string">'BEGIN &#123;count=0&#125; &#123;count++&#125; END &#123; print "File Count:"count&#125;'</span> </span><br><span class="line">File Count:41</span><br></pre></td></tr></table></figure><p>4.统计外网连接数，根据ip分组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -ant | awk <span class="string">'/^tcp/&#123;print $5&#125;'</span> | awk -F: <span class="string">'!/^:/&#123;print $1&#125;'</span> | sort | uniq -c</span><br><span class="line"><span class="comment"># sort 将重复的行集中在一起</span></span><br><span class="line"><span class="comment"># uniq 对文本行进行去重 -c 统计重复次数</span></span><br><span class="line"><span class="comment"># 可实现对文本行按重复次数进行排序 默认是升序  -r 降序</span></span><br><span class="line">$ sort 1.txt | uniq -c | sort -rn</span><br></pre></td></tr></table></figure><p>5.统计第6列连接状态总共出现了几次</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'NR!=1&#123;a[$6]++;&#125; END &#123;for (i in a) print i ", " a[i];&#125;'</span> netstat </span><br><span class="line">LISTEN, 5</span><br><span class="line">Foreign, 1</span><br></pre></td></tr></table></figure><p>6.统计每个用户的进程占用了多少内存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps aux | awk <span class="string">'NR!=1&#123;a[$1]+=$6;&#125; END &#123;for(i in a) print i "," a[i]"KB"; &#125;'</span></span></span><br><span class="line">dbus,1492KB</span><br><span class="line">polkitd,10972KB</span><br><span class="line">ntp,2104KB</span><br><span class="line">root,138580KB</span><br></pre></td></tr></table></figure><h3 id="awk脚本"><a href="#awk脚本" class="headerlink" title="awk脚本"></a>awk脚本</h3><p>在上面我们可以看到一个<strong>END</strong>关键字。<strong>END</strong>的意思是“处理完所有的行的标识”，即然说到了<strong>END</strong>就有必要介绍一下BEGIN，这两个关键字意味着<strong>执行前</strong>和<strong>执行后</strong>的意思，语法如下：</p><ul><li><strong>BEGIN</strong>{ 这里面放的是执行前的语句 }</li><li><strong>END</strong> { 这里面放的是处理完所有的行后要执行的语句 }</li><li>{ 这里面放的是处理每一行时要执行的语句 }</li></ul><p>so，举个栗子🌰</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat score </span><br><span class="line">Marry   2143 78 84 77</span><br><span class="line">Jack    2321 66 78 45</span><br><span class="line">Tom     2122 48 77 71</span><br><span class="line">Mike    2537 87 97 95</span><br><span class="line">Bob     2415 40 57 62</span><br></pre></td></tr></table></figure><p>awk脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cat cal.awk </span><br><span class="line"><span class="comment">#!/bin/awk -f</span></span><br><span class="line"><span class="comment">#运行前</span></span><br><span class="line">BEGIN &#123;</span><br><span class="line">    math = 0</span><br><span class="line">    english = 0</span><br><span class="line">    computer = 0</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n"</span></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"---------------------------------------------\n"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#运行中</span></span><br><span class="line">&#123;</span><br><span class="line">    math+=<span class="variable">$3</span></span><br><span class="line">    english+=<span class="variable">$4</span></span><br><span class="line">    computer+=<span class="variable">$5</span></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"%-6s %-6s %4d %8d %8d %8d\n"</span>, <span class="variable">$1</span>, <span class="variable">$2</span>, <span class="variable">$3</span>,<span class="variable">$4</span>,<span class="variable">$5</span>, <span class="variable">$3</span>+<span class="variable">$4</span>+<span class="variable">$5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#运行后</span></span><br><span class="line">END &#123;</span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"---------------------------------------------\n"</span></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"  TOTAL:%10d %8d %8d \n"</span>, math, english, computer</span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"AVERAGE:%10.2f %8.2f %8.2f\n"</span>, math/NR, english/NR, computer/NR</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -f调用脚本</span></span><br><span class="line">$ awk -f cal.awk score     </span><br><span class="line">NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL</span><br><span class="line">---------------------------------------------</span><br><span class="line">Marry  2143     78       84       77      239</span><br><span class="line">Jack   2321     66       78       45      189</span><br><span class="line">Tom    2122     48       77       71      196</span><br><span class="line">Mike   2537     87       97       95      279</span><br><span class="line">Bob    2415     40       57       62      159</span><br><span class="line">---------------------------------------------</span><br><span class="line">  TOTAL:       319      393      350 </span><br><span class="line">AVERAGE:     63.80    78.60    70.00</span><br></pre></td></tr></table></figure><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>awk脚本与环境变量的交互，使用-v参数（定义变量）和ENVIRON，使用ENVIRON的环境变量需要export。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ x=5</span><br><span class="line">$ y=10</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$x</span></span><br><span class="line">5</span><br><span class="line">$ <span class="built_in">export</span> y</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$x</span> <span class="variable">$y</span></span><br><span class="line">5 10</span><br><span class="line">$ awk -v val=<span class="variable">$x</span> <span class="string">'&#123;print $1,$2,$3,$4+val,$5+ENVIRON["y"]&#125;'</span> OFS=<span class="string">"\t"</span> score </span><br><span class="line">Marry   2143    78      89      87</span><br><span class="line">Jack    2321    66      83      55</span><br><span class="line">Tom     2122    48      82      81</span><br><span class="line">Mike    2537    87      102     105</span><br><span class="line">Bob     2415    40      62      72</span><br></pre></td></tr></table></figure><h3 id="有趣示例"><a href="#有趣示例" class="headerlink" title="有趣示例"></a>有趣示例</h3><p>1.从file文件中找出长度大于20的行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'length&gt;=21'</span> score </span><br><span class="line">Marry   2143 78 84 77</span><br><span class="line">Jack    2321 66 78 45</span><br><span class="line">Tom     2122 48 77 71</span><br><span class="line">Mike    2537 87 97 95</span><br><span class="line">Bob     2415 40 57 62</span><br></pre></td></tr></table></figure><p>2.按连接数查看客户端ip，根据ip分组计数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -ntu | awk <span class="string">'&#123;print $5&#125;'</span> | cut -d: -f1 | sort | uniq -c</span><br><span class="line">      1 100.100.30.25</span><br><span class="line">      2 112.213.179.149</span><br><span class="line">      1 173.255.234.138</span><br><span class="line">      1 47.52.207.198</span><br><span class="line">      1 47.93.222.200</span><br><span class="line">      1 60.247.88.82</span><br><span class="line">      1 77.247.110.219</span><br><span class="line">      1 80.1.15.172</span><br><span class="line">      7 80.82.70.187</span><br><span class="line">      1 89.248.174.198</span><br><span class="line">      1 Address</span><br><span class="line">      1 servers)</span><br><span class="line"><span class="comment"># cut用法</span></span><br><span class="line"><span class="comment"># -d ：自定义分隔符，默认为制表符。</span></span><br><span class="line"><span class="comment"># -f ：与-d一起使用，指定显示哪个区域。</span></span><br></pre></td></tr></table></figure><p>3.打印九九乘法表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ seq 9 | sed <span class="string">'H;g'</span> | awk -v RS=<span class="string">''</span> <span class="string">'&#123;for(i=1;i&lt;=NF;i++)printf("%dx%d=%d%s", i, NR, i*NR, i==NR?"\n":"\t")&#125;'</span></span><br><span class="line">1x1=1</span><br><span class="line">1x2=2   2x2=4</span><br><span class="line">1x3=3   2x3=6   3x3=9</span><br><span class="line">1x4=4   2x4=8   3x4=12  4x4=16</span><br><span class="line">1x5=5   2x5=10  3x5=15  4x5=20  5x5=25</span><br><span class="line">1x6=6   2x6=12  3x6=18  4x6=24  5x6=30  6x6=36</span><br><span class="line">1x7=7   2x7=14  3x7=21  4x7=28  5x7=35  6x7=42  7x7=49</span><br><span class="line">1x8=8   2x8=16  3x8=24  4x8=32  5x8=40  6x8=48  7x8=56  8x8=64</span><br><span class="line">1x9=9   2x9=18  3x9=27  4x9=36  5x9=45  6x9=54  7x9=63  8x9=72  9x9=81</span><br></pre></td></tr></table></figure><blockquote><p>参考链接:<br><a href="https://coolshell.cn/articles/9070.html" target="_blank" rel="noopener">AWK 简明教程</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;&lt;strong&gt;awk&lt;/strong&gt;其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="awk" scheme="https://annecoding.github.io/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>hexo图片显示问题</title>
    <link href="https://annecoding.github.io/2019/05/20/hexo%20img%20403/"/>
    <id>https://annecoding.github.io/2019/05/20/hexo img 403/</id>
    <published>2019-05-20T03:19:37.000Z</published>
    <updated>2019-07-25T00:08:26.530Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>解决markdown图片不显示，返回403 forbidden。</p><a id="more"></a><p>在文章中引用外链图片时不显示，但是本身外链（图床）图片又是可以打开的，错误如下图所示：<br><img src="http://images2015.cnblogs.com/blog/415042/201604/415042-20160419175110210-69232656.png" alt></p><p><img src="http://www.manongjc.com/images/cnblogs/153579233815357B3A9v2338.png" alt><br>只需要在文件头部添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>关于meta referrer，有如下可设置的值：<br><img src="https://images2017.cnblogs.com/blog/985078/201802/985078-20180208084932873-358057556.png" alt></p><blockquote><p>参考链接如下：<br><a href="https://github.com/xcodebuild/hexo-asset-image" target="_blank" rel="noopener">关于hexo-asset-image</a><br><a href="http://www.manongjc.com/article/9294.html" target="_blank" rel="noopener">hexo图片不显示</a><br><a href="https://www.cnblogs.com/awzf/p/9811386.html" target="_blank" rel="noopener">img标签forbidden问题</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;解决markdown图片不显示，返回403 forbidden。&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://annecoding.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://annecoding.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>linux下项目上线流程</title>
    <link href="https://annecoding.github.io/2019/05/15/%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E6%B5%81%E7%A8%8B/"/>
    <id>https://annecoding.github.io/2019/05/15/项目上线流程/</id>
    <published>2019-05-15T07:48:23.317Z</published>
    <updated>2019-07-28T01:43:11.512Z</updated>
    
    <content type="html"><![CDATA[<p>项目上线流程</p><p>1.选择服务器，比如CentOS、ubuntu等。</p><p>2.选择Web服务器，比如Nginx、Apache、Tomcat等。</p><p>3.独立域名购买，比如阿里云、腾讯云等。<br><a id="more"></a></p><h3 id="web服务器构建"><a href="#web服务器构建" class="headerlink" title="web服务器构建"></a>web服务器构建</h3><p>linux下安装nginx，yum下没有nginx源，在epel-release下有<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先安装epel-release源</span></span><br><span class="line">yum install epel-release</span><br><span class="line"><span class="comment"># 安装nginx</span></span><br><span class="line">yum install nginx</span><br></pre></td></tr></table></figure></p><p>可输入下面命令查看是否安装成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br></pre></td></tr></table></figure></p><p>安装编辑器vim<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install vim</span><br></pre></td></tr></table></figure></p><p>安装scp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install openssh-client</span><br></pre></td></tr></table></figure></p><h3 id="网站上传到服务器"><a href="#网站上传到服务器" class="headerlink" title="网站上传到服务器"></a>网站上传到服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># local_dir为本地目录数据</span></span><br><span class="line">scp -r local_dir user@ip:/remote_dir</span><br><span class="line"><span class="comment"># 示例如下  当下目录所有数据上传到远程目录/root/www</span></span><br><span class="line">scp -r ./* root@ip:/root/www</span><br></pre></td></tr></table></figure><h3 id="域名购买及解析-阿里云直接用新手引导"><a href="#域名购买及解析-阿里云直接用新手引导" class="headerlink" title="域名购买及解析(阿里云直接用新手引导)"></a>域名购买及解析(阿里云直接用新手引导)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">添加www和@记录</span><br><span class="line"></span><br><span class="line">记录值：公网IP地址</span><br></pre></td></tr></table></figure><p>如以上操作步骤无误，便可根据购买的域名访问相关网站。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目上线流程&lt;/p&gt;
&lt;p&gt;1.选择服务器，比如CentOS、ubuntu等。&lt;/p&gt;
&lt;p&gt;2.选择Web服务器，比如Nginx、Apache、Tomcat等。&lt;/p&gt;
&lt;p&gt;3.独立域名购买，比如阿里云、腾讯云等。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Centos" scheme="https://annecoding.github.io/tags/Centos/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本实例入门精选系列</title>
    <link href="https://annecoding.github.io/2019/05/15/shell%E8%84%9A%E6%9C%AC%E7%BB%83%E4%B9%A0/"/>
    <id>https://annecoding.github.io/2019/05/15/shell脚本练习/</id>
    <published>2019-05-15T01:23:41.000Z</published>
    <updated>2019-09-01T04:58:06.942Z</updated>
    
    <content type="html"><![CDATA[<h3 id="读取有效的电话号码"><a href="#读取有效的电话号码" class="headerlink" title="读取有效的电话号码"></a>读取有效的电话号码</h3><p>给定一个包含电话号码列表（一行一个电话号码）的文本文件 <code>file.txt</code>，写一个 bash 脚本输出所有有效的电话号码。<br><a id="more"></a><br>你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）</p><p>你也可以假设每行前后没有多余的空格字符。</p><p><strong>示例:</strong></p><p>假设 <code>file.txt</code> 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">987-123-4567</span><br><span class="line">123 456 7890</span><br><span class="line">(123) 456-7890</span><br></pre></td></tr></table></figure><p>你的脚本应当输出下列有效的电话号码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">987-123-4567</span><br><span class="line">(123) 456-7890</span><br></pre></td></tr></table></figure><p>实现脚本如下：</p><p>方法一：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n -r <span class="string">'/^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$/p'</span> file.txt</span><br></pre></td></tr></table></figure></p><p>方法二：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -P <span class="string">'^(\d&#123;3&#125;-|\(\d&#123;3&#125;\) )\d&#123;3&#125;-\d&#123;4&#125;$'</span> file.txt</span><br><span class="line"><span class="comment"># \d 等价于 [0-9]  试验结果[0-9]更快</span></span><br><span class="line">grep -P <span class="string">'^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$'</span> file.txt</span><br></pre></td></tr></table></figure></p><p>方法三<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'/^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$/'</span> file.txt</span><br></pre></td></tr></table></figure></p><p><strong>其他参考</strong></p><ul><li><a href="https://blog.csdn.net/yufenghyc/article/details/51078107" target="_blank" rel="noopener">正则表达式BREs,EREs,PREs的比较</a></li></ul><h3 id="打印文件第十行"><a href="#打印文件第十行" class="headerlink" title="打印文件第十行"></a>打印文件第十行</h3><p>给定一个文本文件 <code>file.txt</code>，请只打印这个文件中的第十行。</p><p><strong>示例:</strong></p><p>假设 <code>file.txt</code> 有如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Line 1</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">Line 4</span><br><span class="line">Line 5</span><br><span class="line">Line 6</span><br><span class="line">Line 7</span><br><span class="line">Line 8</span><br><span class="line">Line 9</span><br><span class="line">Line 10</span><br></pre></td></tr></table></figure><p>你的脚本应当显示第十行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Line 10</span><br></pre></td></tr></table></figure><p>实现脚本如下：<br>方法一：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Read from the file file.txt and output the tenth line to stdout.</span></span><br><span class="line">sed -n <span class="string">'10p'</span> file.txt</span><br></pre></td></tr></table></figure></p><p>方法二：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'10&#123;p;q&#125;'</span> file.txt</span><br></pre></td></tr></table></figure></p><p>方法三：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">"NR==10"</span> file.txt</span><br></pre></td></tr></table></figure></p><p>方法四：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | awk <span class="string">'NR==10'</span></span><br></pre></td></tr></table></figure></p><p>方法五:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | head -10 | tail -1</span><br></pre></td></tr></table></figure></p><h3 id="centos下常用参数"><a href="#centos下常用参数" class="headerlink" title="centos下常用参数"></a>centos下常用参数</h3><p>1.提取IP地址<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig  | grep inet | grep -v 127.0.0.1 | grep -v inet6| awk -F <span class="string">' '</span> <span class="string">'&#123;print $2&#125;'</span></span><br></pre></td></tr></table></figure></p><p>2.格式化日期<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATE=$(date +%F<span class="string">" "</span>%H:%M)</span><br></pre></td></tr></table></figure></p><p>3.内存空闲情况查询<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TOTAL=$(free -m | awk <span class="string">'/Mem/&#123;print $2&#125;'</span>)</span><br><span class="line">USE=$(free -m | awk <span class="string">'/Mem/&#123;print $3+$6&#125;'</span>)</span><br><span class="line">FREE=$((<span class="variable">$TOTAL</span>-<span class="variable">$USE</span>))</span><br></pre></td></tr></table></figure></p><p>4.磁盘参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TOTAL=$(fdisk -l | grep Disk | awk -F <span class="string">'[ ,]'</span> <span class="string">'NR==1&#123;print $2,$3,$4,$5&#125;'</span>)</span><br><span class="line">PART_USE=$(df -h | grep <span class="string">"/dev/vda1"</span> | awk -F <span class="string">'[ %]+'</span> <span class="string">'&#123;print $1,$5,$6&#125;'</span>)</span><br></pre></td></tr></table></figure></p><p>5.查看网络连接情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo awk <span class="string">'&#123;print $1&#125;'</span> |sort|uniq -c|sort -nr |head -10 /var/<span class="built_in">log</span>/auth.log</span><br></pre></td></tr></table></figure><p>6.按连接数查看客户端ip，根据ip分组计数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -ntu | awk <span class="string">'&#123;print $5&#125;'</span> | cut -d: -f1 | sort | uniq -c</span><br><span class="line">      1 100.100.30.25</span><br><span class="line">      2 112.213.179.149</span><br><span class="line">      1 173.255.234.138</span><br><span class="line">      1 47.52.207.198</span><br><span class="line">      1 47.93.222.200</span><br></pre></td></tr></table></figure></p><p><strong>其他参考</strong></p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNTM5Njk3Mw==&amp;mid=2247486313&amp;idx=1&amp;sn=8dc03304760321212b19b4528d117236&amp;chksm=9b1c0bebac6b82fd0efd966c4bf6a43e0c9d38fbdd6c19441f061e811e454b6232f412daec7f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Shell分析服务器日志，解锁各种新姿势</a></li></ul><h3 id="检测服务是否启动成功"><a href="#检测服务是否启动成功" class="headerlink" title="检测服务是否启动成功"></a>检测服务是否启动成功</h3><p><strong>示例</strong>：检测ssh服务是否启动成功，有多种方法，这里只列举一种。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat service.sh </span><br><span class="line"><span class="comment"># 检查服务状态的脚本</span></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># ss -anu 查看所有udp连接</span></span><br><span class="line">PORT_C=$(ss -anu | grep -c 123)</span><br><span class="line">PS_C=$(ps -ef | grep sshd | grep -vc grep)</span><br><span class="line"><span class="comment"># if中-o  布尔运算中的或运算  只要一个为true则都为true</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$PORT_C</span> -eq 0 -o <span class="variable">$PS_C</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"sshd启动失败"</span> | mail -s <span class="string">"ssh服务"</span> annecoding@163.com</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"ssh启动成功"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><p>执行脚本，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./service.sh </span><br><span class="line">ssh启动成功</span><br></pre></td></tr></table></figure></p><h3 id="检查主机存活状态"><a href="#检查主机存活状态" class="headerlink" title="检查主机存活状态"></a>检查主机存活状态</h3><p>1.将错误次数存放在数组里面,以此来判断主机存活状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查主机存活状态</span></span><br><span class="line">$ cat hostacting.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">IP_LIST=<span class="string">"114.112.114.114 1.2.4.8"</span></span><br><span class="line"><span class="keyword">for</span> IP <span class="keyword">in</span> <span class="variable">$IP_LIST</span>;<span class="keyword">do</span></span><br><span class="line">        NUM=1</span><br><span class="line">        <span class="keyword">while</span> [ <span class="variable">$NUM</span> -le 3 ]</span><br><span class="line">        <span class="keyword">do</span> </span><br><span class="line">                <span class="keyword">if</span> ping -c 1 <span class="variable">$IP</span> &gt; /dev/null;<span class="keyword">then</span></span><br><span class="line">                        <span class="built_in">echo</span> <span class="string">"<span class="variable">$IP</span> Ping is successful."</span></span><br><span class="line">                        <span class="built_in">break</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                <span class="comment"># ping三次，统计失败的次数</span></span><br><span class="line">                        FAIL_COUNT[<span class="variable">$NUM</span>]=<span class="variable">$IP</span></span><br><span class="line">                        <span class="built_in">let</span> NUM++</span><br><span class="line">                <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"fail_count（数组元素个数为//3）: <span class="variable">$&#123;#FAIL_COUNT[*]&#125;</span>"</span></span><br><span class="line">        <span class="comment"># echo "failcount1（数组元素为//IP地址）: $&#123;FAIL_COUNT[1]&#125;"</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$&#123;#FAIL_COUNT[*]&#125;</span> -eq 3 ];<span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;FAIL_COUNT[1]&#125;</span> Ping is failure!!!"</span></span><br><span class="line">                <span class="comment"># 清空数组</span></span><br><span class="line">                <span class="built_in">unset</span> FAIL_COUNT[*]</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>执行脚本，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./hostacting.sh   </span><br><span class="line"><span class="comment"># fail_count（数组元素个数为//3）: 3</span></span><br><span class="line">114.112.114.114 Ping is failure!!!</span><br><span class="line">1.2.4.8 Ping is successful. </span><br><span class="line"><span class="comment"># fail_count（数组元素个数为//3）: 0</span></span><br></pre></td></tr></table></figure></p><p>2.通过计数判断主机存活状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat hostacting1.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">IP_LIST=<span class="string">"114.114.114.114 124.123.12.134"</span></span><br><span class="line"><span class="keyword">for</span> IP <span class="keyword">in</span> <span class="variable">$IP_LIST</span>;<span class="keyword">do</span></span><br><span class="line">        FAIL_COUNT=0</span><br><span class="line">        <span class="keyword">for</span>((i=1;i&lt;=3;i++));<span class="keyword">do</span></span><br><span class="line">                <span class="keyword">if</span> ping -c 1 <span class="variable">$IP</span> &gt;/dev/null;<span class="keyword">then</span></span><br><span class="line">                        <span class="built_in">echo</span> <span class="string">"<span class="variable">$IP</span> Ping is successful."</span></span><br><span class="line">                <span class="built_in">break</span></span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                        <span class="built_in">let</span> FAIL_COUNT++</span><br><span class="line">                <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$FAIL_COUNT</span> -eq 3 ];<span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"<span class="variable">$IP</span> Ping is failure!!!"</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>执行脚本，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./hostacting1.sh </span><br><span class="line">114.114.114.114 Ping is successful.</span><br><span class="line">124.123.12.134 Ping is failure!!!</span><br></pre></td></tr></table></figure></p><p>3.通过跳出循环的方式来判断主机存活状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cat hostacting2.sh </span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="function"><span class="title">ping_success_status</span></span>()&#123;</span><br><span class="line">        <span class="keyword">if</span> ping -c 1 <span class="variable">$IP</span> &gt;/dev/null;<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$IP</span> Ping is successful."</span></span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line">IP_LIST=<span class="string">"114.114.114.114 123.13.13.23"</span></span><br><span class="line"><span class="keyword">for</span> IP <span class="keyword">in</span> <span class="variable">$IP_LIST</span>;<span class="keyword">do</span></span><br><span class="line">        ping_success_status</span><br><span class="line">        ping_success_status</span><br><span class="line">        ping_success_status</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$IP</span> Ping is failure!!!"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>执行脚本，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./hostacting2.sh   </span><br><span class="line">114.114.114.114 Ping is successful.</span><br><span class="line">123.13.13.23 Ping is successful.</span><br></pre></td></tr></table></figure></p><h3 id="使用vmstat工具来分析CPU的统计信息"><a href="#使用vmstat工具来分析CPU的统计信息" class="headerlink" title="使用vmstat工具来分析CPU的统计信息"></a>使用vmstat工具来分析CPU的统计信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cat cpu.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">DATE=$(date +%F<span class="string">" "</span>%H:%M)</span><br><span class="line">IP=$(ifconfig | grep inet | grep -v 127.0.0.1 | grep -v inet6 | awk -F <span class="string">" "</span> <span class="string">'&#123;print $2&#125;'</span> )</span><br><span class="line">MAIL=<span class="string">"annecoding@163.com"</span></span><br><span class="line"><span class="comment"># 如果vmstat不存在</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">which</span> vmstat &amp;&gt;/dev/null;<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"vmstat command no found,Please install procps package."</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># NR==3 取第三行</span></span><br><span class="line">US=$(vmstat | awk <span class="string">'NR==3&#123;print $13&#125;'</span>)</span><br><span class="line">SY=$(vmstat | awk <span class="string">'NR==3&#123;print $14&#125;'</span>)</span><br><span class="line">IDLE=$(vmstat | awk <span class="string">'NR==3&#123;print $15&#125;'</span>)</span><br><span class="line">WAIT=$(vmstat | awk <span class="string">'NR==3&#123;print $16&#125;'</span>)</span><br><span class="line">USE=$((<span class="variable">$US</span>+<span class="variable">$SY</span>))</span><br><span class="line"><span class="comment"># echo "use:$USE"</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$USE</span> -ge 0 ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"</span></span><br><span class="line"><span class="string">        Date: <span class="variable">$DATE</span></span></span><br><span class="line"><span class="string">        Host: <span class="variable">$IP</span></span></span><br><span class="line"><span class="string">        Problem: CPU utilization <span class="variable">$USE</span></span></span><br><span class="line"><span class="string">        "</span> | mail -s <span class="string">"CPU Monitor"</span> <span class="variable">$MAIL</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>执行脚本，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./cpu.sh </span><br><span class="line"></span><br><span class="line">        Date: 2019-08-20 09:01</span><br><span class="line">        Host: 172.17.104.191</span><br><span class="line">        Problem: CPU utilization 0</span><br></pre></td></tr></table></figure></p><h3 id="使用free分析内存信息"><a href="#使用free分析内存信息" class="headerlink" title="使用free分析内存信息"></a>使用free分析内存信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cat memory.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 格式化日期 后面不能有空格</span></span><br><span class="line">DATE=$(date +%F<span class="string">" "</span>%H:%M)</span><br><span class="line">MAIL=<span class="string">"annecoding@163.com"</span></span><br><span class="line"><span class="comment"># 获取IP地址</span></span><br><span class="line">IP=$(ifconfig | grep inet | grep -v 127.0.0.1 | grep -v inet6 | awk -F <span class="string">' '</span> <span class="string">'&#123;print $2&#125;'</span>)</span><br><span class="line"><span class="comment"># awk '/Mem/' 模式匹配  匹配包含Mem的一行</span></span><br><span class="line">TOTAL=$(free -m | awk <span class="string">'/Mem/&#123;print $2&#125;'</span>)</span><br><span class="line">USE=$(free -m | awk <span class="string">'/Mem/&#123;print $3+$6&#125;'</span>)</span><br><span class="line">FREE=$((<span class="variable">$TOTAL</span>-<span class="variable">$USE</span>))</span><br><span class="line"><span class="comment"># 内存小于1.0G输出信息</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$FREE</span> -lt 1024 ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"</span></span><br><span class="line"><span class="string">Date: <span class="variable">$DATE</span></span></span><br><span class="line"><span class="string">Host: <span class="variable">$IP</span></span></span><br><span class="line"><span class="string">Problem:Total=<span class="variable">$TOTAL</span>,Use=<span class="variable">$USE</span>,Free=<span class="variable">$FREE</span></span></span><br><span class="line"><span class="string">"</span> | mail -s <span class="string">"Memory Monitor"</span> <span class="variable">$MAIL</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>执行脚本，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./memory.sh </span><br><span class="line">Date: 2019-08-20 09:02</span><br><span class="line">Host: 172.17.104.191</span><br><span class="line">Problem:Total=1839,Use=890,Free=949</span><br></pre></td></tr></table></figure></p><h3 id="监控磁盘利用"><a href="#监控磁盘利用" class="headerlink" title="监控磁盘利用"></a>监控磁盘利用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cat fdisk.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">DATE=$(date +%F<span class="string">" "</span>%H:%M)</span><br><span class="line"><span class="comment"># grep -v 表示取反匹配</span></span><br><span class="line">IP=$(ifconfig | grep inet | grep -v 127.0.0.1 | grep -v inet6 | awk -F <span class="string">' '</span> <span class="string">'&#123;print $2&#125;'</span>)</span><br><span class="line"><span class="comment"># MAIL="example@email.com"</span></span><br><span class="line">TOTAL=$(fdisk -l | grep Disk | awk -F <span class="string">'[ ,]'</span> <span class="string">'NR==1&#123;print $2,$3,$4,$5&#125;'</span>)</span><br><span class="line">PART_USE=$(df -h | grep <span class="string">"/dev/vda1"</span> | awk -F <span class="string">'[ %]+'</span> <span class="string">'&#123;print $1,$5,$6&#125;'</span>)</span><br><span class="line">PART=$(<span class="built_in">echo</span> <span class="variable">$PART_USE</span> | cut -d <span class="string">" "</span> -f1)</span><br><span class="line">USE=$(<span class="built_in">echo</span> <span class="variable">$PART_USE</span> | cut -d <span class="string">" "</span> -f2)</span><br><span class="line">MOUNT=$(<span class="built_in">echo</span> <span class="variable">$PART_USE</span> | cut -d <span class="string">" "</span> -f3)</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$USE</span> -gt 3 ];<span class="keyword">then</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"</span></span><br><span class="line"><span class="string">        Date: <span class="variable">$DATE</span></span></span><br><span class="line"><span class="string">        Host: <span class="variable">$IP</span></span></span><br><span class="line"><span class="string">        Total: <span class="variable">$TOTAL</span></span></span><br><span class="line"><span class="string">        Problem: <span class="variable">$PART</span>'已使用:'<span class="variable">$USE</span>%</span></span><br><span class="line"><span class="string">        "</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>执行脚本，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./fdisk.sh </span><br><span class="line"></span><br><span class="line">        Date: 2019-08-20 11:20</span><br><span class="line">        Host: 172.17.104.191</span><br><span class="line">        Total: /dev/vda: 42.9 GB </span><br><span class="line">        Problem: /dev/vda1<span class="string">'已使用:'</span>5%</span><br></pre></td></tr></table></figure></p><h3 id="判断url可用性"><a href="#判断url可用性" class="headerlink" title="判断url可用性"></a>判断url可用性</h3><p>1.判断三次URL可用性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ cat check_url.sh </span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="function"><span class="title">check_url</span></span>()&#123;</span><br><span class="line">        <span class="comment"># curl</span></span><br><span class="line">        <span class="comment"># -o 把输出写到文件中 </span></span><br><span class="line">        <span class="comment"># --connect-timeout 设置最大请求时间</span></span><br><span class="line">        <span class="comment"># -s 静默模式，不输出任何东西</span></span><br><span class="line">        <span class="comment"># -w 什么输出完成后</span></span><br><span class="line">        <span class="comment"># $1 函数取第一个参数，这里取$URL</span></span><br><span class="line">        HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w <span class="string">"%&#123;http_code&#125;"</span>  <span class="variable">$1</span>)</span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$HTTP_CODE</span> -eq 200 ];<span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Suprise:<span class="variable">$URL</span> Access success."</span></span><br><span class="line">                <span class="built_in">continue</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line">URL_LIST=<span class="string">"www.baidu.com  www.google.com www.1211111111111.com"</span></span><br><span class="line"><span class="keyword">for</span> URL <span class="keyword">in</span> <span class="variable">$URL_LIST</span> ;<span class="keyword">do</span></span><br><span class="line">        check_url <span class="variable">$URL</span></span><br><span class="line">        check_url <span class="variable">$URL</span></span><br><span class="line">        check_url <span class="variable">$URL</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Warning: <span class="variable">$URL</span> Access failure!"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>执行脚本，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./check_url.sh </span><br><span class="line">Suprise:www.baidu.com Access success.</span><br><span class="line">Warning: www.google.com Access failure!</span><br><span class="line">Warning: www.1211111111111.com Access failure!</span><br></pre></td></tr></table></figure></p><p>2.通过将错误保存在数组判断url存活<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ cat check_url1.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">URL_LIST=<span class="string">"www.baidu.com www.1233333311111.com  www.sougou.com"</span></span><br><span class="line"><span class="keyword">for</span> URL <span class="keyword">in</span> <span class="variable">$URL_LIST</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">        FAIL_COUNT=0</span><br><span class="line">        <span class="keyword">for</span>((i=1;i&lt;=3;i++))</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">                HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w <span class="string">"%&#123;http_code&#125;"</span> <span class="variable">$URL</span>)</span><br><span class="line">                <span class="keyword">if</span> [ <span class="variable">$HTTP_CODE</span> -ne 200 ];<span class="keyword">then</span></span><br><span class="line">                        <span class="built_in">let</span> FAIL_COUNT++</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">echo</span> <span class="string">"Suprise: <span class="variable">$URL</span> access successful."</span></span><br><span class="line">                        <span class="built_in">break</span></span><br><span class="line">                <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$FAIL_COUNT</span> -eq 3 ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Warning: <span class="variable">$URL</span> access failure!"</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>执行脚本，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./check_url1.sh</span><br><span class="line">Suprise: www.baidu.com access successful.</span><br><span class="line">Warning: www.1233333311111.com access failure!</span><br><span class="line">Suprise: www.sougou.com access successful.</span><br></pre></td></tr></table></figure></p><p>3.通过将错误保存到变量来判断</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ cat check_url2.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">URL_LIST=<span class="string">"www.sougou.com www.anne1111111.com www.baidu.com"</span></span><br><span class="line"><span class="keyword">for</span> URL <span class="keyword">in</span> <span class="variable">$URL_LIST</span>;<span class="keyword">do</span> </span><br><span class="line">        NUM=1</span><br><span class="line">        <span class="keyword">while</span> [ <span class="variable">$NUM</span> -le 3 ];<span class="keyword">do</span></span><br><span class="line">                HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w <span class="string">"%&#123;http_code&#125;"</span> <span class="variable">$URL</span>)</span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$HTTP_CODE</span> -ne 200 ];<span class="keyword">then</span></span><br><span class="line">                <span class="comment"># 创建数组，以$NUM为下标,$URL为传入数组的元素</span></span><br><span class="line">                FAIL_COUNT[<span class="variable">$NUM</span>]=<span class="variable">$URL</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"array_value:<span class="variable">$&#123;FAIL_COUNT[*]&#125;</span>"</span></span><br><span class="line">                <span class="built_in">let</span> NUM++</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Suprise: <span class="variable">$URL</span> access success."</span></span><br><span class="line">                <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$&#123;#FAIL_COUNT[*]&#125;</span> -eq 3 ];<span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Warning: <span class="variable">$URL</span> access failure!"</span></span><br><span class="line">                <span class="comment"># 清空数组</span></span><br><span class="line">                <span class="built_in">unset</span> FAIL_COUNT[*] </span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>执行脚本，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./check_url2.sh  </span><br><span class="line">Suprise: www.sougou.com access success.</span><br><span class="line"><span class="comment"># array_value:www.anne1111111.com</span></span><br><span class="line"><span class="comment"># array_value:www.anne1111111.com www.anne1111111.com</span></span><br><span class="line"><span class="comment"># array_value:www.anne1111111.com www.anne1111111.com www.anne1111111.com</span></span><br><span class="line">Warning: www.anne1111111.com access failure!</span><br><span class="line">Suprise: www.baidu.com access success.</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;读取有效的电话号码&quot;&gt;&lt;a href=&quot;#读取有效的电话号码&quot; class=&quot;headerlink&quot; title=&quot;读取有效的电话号码&quot;&gt;&lt;/a&gt;读取有效的电话号码&lt;/h3&gt;&lt;p&gt;给定一个包含电话号码列表（一行一个电话号码）的文本文件 &lt;code&gt;file.txt&lt;/code&gt;，写一个 bash 脚本输出所有有效的电话号码。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Centos" scheme="https://annecoding.github.io/tags/Centos/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>linux基础知识精选系列</title>
    <link href="https://annecoding.github.io/2019/05/10/linux%E5%9F%BA%E7%A1%80/"/>
    <id>https://annecoding.github.io/2019/05/10/linux基础/</id>
    <published>2019-05-10T01:26:39.000Z</published>
    <updated>2019-08-25T09:34:30.178Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>本篇文章主要是一些关于linux操作系统、linux诞生等一些背景知识及简单介绍。以及一些linux基础操作命令。<br><a id="more"></a></p><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><h3 id="操作系统简介"><a href="#操作系统简介" class="headerlink" title="操作系统简介"></a>操作系统简介</h3><p>我通过以下四点介绍什么操作系统：</p><ul><li>操作系统（Operation System，简称OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石；</li><li>操作系统本质上是运行在计算机上的软件程序 ；</li><li>为用户提供一个与系统交互的操作界面 ；</li><li>操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。</li></ul><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5cei5yjfoj30hs0d5jrf.jpg" alt="img"></p><h3 id="操作系统简单分类"><a href="#操作系统简单分类" class="headerlink" title="操作系统简单分类"></a>操作系统简单分类</h3><ul><li><strong>Windows:</strong> 目前最流行的个人桌面操作系统 ，不做多的介绍，大家都清楚。 </li><li><strong>Unix：</strong> 最早的多用户、多任务操作系统 .按照操作系统的分类，属于分时操作系统。Unix 大多被用在服务器、工作站，现在也有用在个人计算机上。它在创建互联网、计算机网络或客户端/服务器模型方面发挥着非常重要的作用。</li><li><strong>Linux:</strong> Linux是一套免费使用和自由传播的类Unix操作系统.Linux存在着许多不同的Linux版本，但它们都使用了 <strong>Linux内核</strong> 。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。严格来讲，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统。</li></ul><h3 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h3><p>我们上面已经介绍到了Linux，我们这里只强调三点。</p><ul><li><strong>类Unix系统：</strong> Linux是一种自由、开放源码的类似Unix的操作系统 </li><li><strong>Linux内核：</strong> 严格来说，Linux这个词本身只表示Linux内核 </li><li><strong>Linux之父：</strong> 一个编程领域的传奇式人物。他是Linux内核的最早作者，随后发起了这个开源项目，担任Linux内核的首要架构师与项目协调者，是当今世界最著名的电脑程序员、黑客之一。他还发起了Git这个开源项目，并为主要的开发者。 </li></ul><h3 id="Linux诞生简介"><a href="#Linux诞生简介" class="headerlink" title="Linux诞生简介"></a>Linux诞生简介</h3><ul><li>1991年，芬兰的业余计算机爱好者Linus Torvalds编写了一款类似Minix的系统（基于微内核架构的类Unix操作系统）被ftp管理员命名为Linux 加入到自由软件基金的GNU计划中;</li><li>Linux以一只可爱的企鹅作为标志，象征着敢作敢为、热爱生活。</li></ul><h3 id="Linux的分类"><a href="#Linux的分类" class="headerlink" title="Linux的分类"></a>Linux的分类</h3><p><strong>Linux根据原生程度，分为两种：</strong></p><p><strong>内核版本：</strong> Linux不是一个操作系统，严格来讲，Linux只是一个操作系统中的内核。内核是什么？内核建立了计算机软件与硬件之间通讯的平台，内核提供系统服务，比如文件管理、虚拟内存、设备I/O等；</p><p><strong>发行版本：</strong> 一些组织或公司在内核版基础上进行二次开发而重新发行的版本。Linux发行版本有很多种（ubuntu和CentOS用的都很多，初学建议选择CentOS），如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g5cen2ffghj30r60d0400.jpg" alt="image-20190725212731888"></p><h3 id="Linux文件系统简介"><a href="#Linux文件系统简介" class="headerlink" title="Linux文件系统简介"></a>Linux文件系统简介</h3><p><strong>在Linux操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong></p><p>也就是说在LINUX系统中有一个重要的概念：<strong>一切都是文件</strong>。其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来，所以这个概念也就传承了下来。在UNIX系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。</p><h3 id="文件类型与目录结构"><a href="#文件类型与目录结构" class="headerlink" title="文件类型与目录结构"></a>文件类型与目录结构</h3><p><strong>Linux支持5种文件类型 ：</strong></p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g5ceo6d7hsj30w40jiwq8.jpg" alt="image-20190725212839830"></p><p><strong>Linux的目录结构如下：</strong></p><p>Linux文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g5ceowfanjj30wy0cwjv9.jpg" alt="image-20190725212921239"></p><p><strong>常见目录说明：</strong></p><ul><li><strong>/bin：</strong> 存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里；</li><li><strong>/etc：</strong>  存放系统管理和配置文件；</li><li><strong>/home：</strong>  存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示；</li><li><strong>/usr ：</strong> 用于存放系统应用程序；</li><li><strong>/opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；</li><li><strong>/proc：</strong>  虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li><li><strong>/root：</strong>    超级用户（系统管理员）的主目录（特权阶级^o^）；</li><li><strong>/sbin:</strong>    存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；</li><li><strong>/dev：</strong>    用于存放设备文件；</li><li><strong>/mnt：</strong>    系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li><li><strong>/boot：</strong>    存放用于系统引导时使用的各种文件；</li><li><strong>/lib ：</strong>      存放着和系统运行相关的库文件 ；</li><li><strong>/tmp：</strong>    用于存放各种临时文件，是公用的临时文件存储点；</li><li><strong>/var：</strong>    用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li><li><strong>/lost+found：</strong>    这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。</li></ul><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><p>下面将主要介绍Linux基本命令。</p><p>推荐一个Linux命令快查网站，非常不错，大家如果遗忘某些命令或者对某些命令不理解都可以在这里得到解决。</p><p>Linux命令大全：<a href="http://man.linuxde.net/" target="_blank" rel="noopener">http://man.linuxde.net/</a><br>linux命令速查：<a href="https://wangchujiang.com/linux-command/" target="_blank" rel="noopener">https://wangchujiang.com/linux-command/</a></p><h3 id="命令切换命令"><a href="#命令切换命令" class="headerlink" title="命令切换命令"></a>命令切换命令</h3><ul><li><strong>cd usr：</strong> 切换到该目录下usr目录 </li><li><strong>cd ..（或cd../）：</strong> 切换到上一层目录 </li><li><strong>cd /：</strong> 切换到系统根目录 </li><li><strong>cd ~：</strong> 切换到用户主目录 </li><li><strong>cd -：</strong> 切换到上一个所在目录 </li></ul><h3 id="命令的操作命令（增删改查）"><a href="#命令的操作命令（增删改查）" class="headerlink" title="命令的操作命令（增删改查）"></a>命令的操作命令（增删改查）</h3><p>1.<strong>mkdir 目录名称</strong>：增加目录</p><p>2.<strong>ls或者ll</strong>（<code>ll</code>是<code>ls -l</code>的缩写，<code>ll</code>命令以看到该目录下的所有目录和文件的详细信息）：查看目录信息</p><p>3.<strong>find 目录 参数</strong>：寻找目录（查）</p><p>示例： </p><ul><li><p>列出当前目录及子目录下所有文件和文件夹: <code>find .</code></p></li><li><p>在/home目录下查找以.txt结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code></p></li><li><p>同上，但忽略大小写:<code>find /home -iname &quot;*.txt&quot;</code></p></li><li><p>当前目录及子目录下查找所有以<code>.txt</code>和<code>.pdf</code>结尾的文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . \( -name <span class="string">"*.txt"</span> -o -name <span class="string">"*.pdf"</span> \)或find . -name <span class="string">"*.txt"</span> -o -name <span class="string">"*.pdf"</span></span><br></pre></td></tr></table></figure></li></ul><p>4.<strong>mv 目录名称 新目录名称</strong>：修改目录的名称（改） </p><p>注意：<code>mv</code>的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。</p><p><code>mv</code>命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到<code>mv</code>命令的另一个用法。</p><p>5.<strong>mv 目录名称 目录的新位置</strong>：移动目录的位置—剪切（改） </p><p>注意：<code>mv</code>语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外<code>mv</code>与<code>cp</code>的结果不同，<code>mv</code>好像文件“搬家”，文件个数并未增加。而<code>cp</code>对文件进行复制，文件个数增加了。</p><p>6.<strong>cp -r 目录名称 目录拷贝的目标位置</strong>：拷贝目录（改），-r代表递归拷贝 </p><p>注意：<code>cp</code>命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写<code>-r</code>递归</p><p>7.<strong>rm [-rf] 目录</strong>: 删除目录（删） </p><p>注意：<code>rm</code>不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用<code>rm -rf</code>目录/文件/压缩包</p><h3 id="文件的操作命令（增删改查）"><a href="#文件的操作命令（增删改查）" class="headerlink" title="文件的操作命令（增删改查）"></a>文件的操作命令（增删改查）</h3><p>1.<strong>touch 文件名称</strong>: 文件的创建（增）</p><p>2.<strong>cat/more/less/tail文件名称</strong>  文件的查看（查）</p><ul><li><strong>cat</strong>：只能显示最后一屏内容</li><li><strong>more</strong>：可以显示百分比，回车可以向下一行， 空格可以向下一页，<code>q</code>可以退出查看</li><li><strong>less</strong>：可以使用键盘上的<code>PgUp</code>和<code>PgDn</code>向上 和向下翻页，<code>q</code>结束查看</li><li><strong>tail-10</strong> ：查看文件的后<code>10</code>行，<code>Ctrl+C</code>结束</li></ul><p>注意：命令 <code>tail -f</code>文件 可以对某个文件进行动态监控，例如<code>tomcat</code>的日志文件， 会随着程序的运行，日志会变化，可以使用<code>tail -f catalina-2016-11-11.log</code>监控 文 件的变化</p><p>3.<strong>vim 文件</strong>：修改文件的内容（改）</p><p>vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。 </p><p><strong>在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤：</strong> </p><p>vim 文件——&gt;进入文件—–&gt;命令模式——&gt;按<code>i</code>进入编辑模式—–&gt;编辑文件 ——-&gt;按<code>Esc</code>进入底行模式—–&gt;输入<code>:wq/q!</code>（输入<code>wq</code>代表写入内容并退出，即保存；输入<code>q!</code>代表强制退出不保存。）</p><p>其他常用模式：</p><ul><li><code>G</code>用于直接跳转到文件尾</li><li><code>ZZ</code>用于存盘退出Vi</li><li><code>ZQ</code>用于不存盘退出Vi</li><li><code>/和？</code>用于查找字符串</li><li><code>n</code>继续查找下一个</li><li><code>yy</code>复制一行</li><li><code>p</code>粘帖在下一行，P粘贴在前一行</li><li><code>dd</code>删除一行文本</li><li><code>x</code>删除光标所在的字符</li><li><code>u</code>取消上一次编辑操作（undo）</li></ul><p>4.<strong>rm -rf 文件</strong>：删除文件（删） 同目录删除：熟记 rm -rf文件 即可</p><h3 id="压缩文件的操作命令"><a href="#压缩文件的操作命令" class="headerlink" title="压缩文件的操作命令"></a>压缩文件的操作命令</h3><p><strong>1）打包并压缩文件：</strong></p><p>Linux中的打包文件一般是以<code>.tar</code>结尾的，压缩的命令一般是以<code>.gz</code>结尾的。</p><p>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般<code>.tar.gz</code>。命令：<code>tar -zcvf</code>打包压缩后的文件名 要打包压缩的文件,其中：</p><ul><li><p><code>z</code>：调用<code>gzip</code>压缩命令进行压缩</p></li><li><p><code>c</code>：打包文件</p></li><li><p><code>v</code>：显示运行过程</p></li><li><p><code>f</code>：指定文件名</p></li></ul><p>比如：加入test目录下有三个文件分别是 :<code>aaa.txt bbb.txt ccc.txt</code>,如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令：<code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code>或：<code>tar -zcvf test.tar.gz /test/</code></p><p><strong>2）解压压缩包：</strong></p><p>命令：<code>tar [-xvf] 压缩文件</code></p><p>其中：<code>x</code>：代表解压</p><p>示例：</p><p>1.将/test下的test.tar.gz解压到当前目录下可以使用命令：<code>tar -xvf test.tar.gz</code></p><p>2.将/test下的test.tar.gz解压到根目录/usr下:<code>tar -xvf xxx.tar.gz -C /usr</code>(-C代表指定解压的位置）</p><h3 id="Linux的权限命令"><a href="#Linux的权限命令" class="headerlink" title="Linux的权限命令"></a>Linux的权限命令</h3><p>操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在Linux中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。</p><p>分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。通过 <code>ls -l</code> 命令我们可以 查看某个目录下的文件或目录的权限</p><p>示例：在随意某个目录下<code>ls -l</code></p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g5cx60784uj30tg0bak0v.jpg" alt="image-20190726080834499"></p><p>第一列的内容的解释信息如下：</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5cx6tgachj30ou09oq6f.jpg" alt="image-20190726080921780"></p><p>下面将详细讲解文件的类型、Linux中权限以及文件有所有者、所在组、其它组具体是什么？</p><p>文件的类型：</p><ul><li><strong>d</strong>：代表目录</li><li><strong>-</strong>：代表文件</li><li><strong>l</strong>：代表链接（可以认为是window中的快捷方式）</li></ul><p>Linux中权限分为以下几种：</p><ul><li><strong>r</strong>：代表权限是可读，r也可以用数字4表示</li><li><strong>w</strong>：代表权限是可写，w也可以用数字2表示</li><li><strong>x</strong>：代表权限是可执行，x也可以用数字1表示</li></ul><p>文件和目录权限的区别：</p><p>对文件和目录而言，读写执行表示不同的意义。</p><p>对于文件：</p><table><thead><tr><th>权限名称</th><th>可执行操作</th></tr></thead><tbody><tr><td>r</td><td>可以使用cat查看文件的内容</td></tr><tr><td>w</td><td>可以修改文件的内容</td></tr><tr><td>x</td><td>可以将其运行为二进制文件</td></tr></tbody></table><p>对于目录：</p><table><thead><tr><th>权限名称</th><th>可执行操作</th></tr></thead><tbody><tr><td>r</td><td>可以查看目录下列表</td></tr><tr><td>w</td><td>可以创建和删除目录下文件</td></tr><tr><td>x</td><td>可以使用cd进入目录</td></tr></tbody></table><p><strong>在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。</strong></p><ul><li><p><strong>所有者</strong><br>一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用ls ‐ahl命令可以看到文件的所有者 也可以使用chown 用户名 文件名来修改文件的所有者 。</p></li><li><p><strong>文件所在组</strong><br>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组 用ls ‐ahl命令可以看到文件的所有组 也可以使用chgrp 组名 文件名来修改文件所在的组。</p></li><li><p><strong>其它组</strong><br>除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组<br>我们再来看看如何修改文件/目录的权限。<br><strong>修改文件/目录的权限的命令：chmod</strong><br>示例：修改/test下的aaa.txt的权限为属主有全部权限，属主所在的组有读写权限， 其他用户只有读的权限<br><strong>chmod u=rwx,g=rw,o=r aaa.txt</strong><br><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5d76hd4jlj30h607wq7v.jpg" alt="image-20190726135501237"><br>上述示例还可以使用数字表示：<code>chmod 764 aaa.txt</code></p></li></ul><p><strong>补充一个比较常用的东西:</strong></p><p>假如我们装了一个zookeeper，我们每次开机到要求其自动启动该怎么办？</p><p>1.新建一个脚本zookeeper</p><p>2.为新建的脚本zookeeper添加可执行权限，命令是:<code>chmod +x zookeeper</code></p><p>3.把zookeeper这个脚本添加到开机启动项里面，命令是：<code>chkconfig --add zookeeper</code></p><p>4.如果想看看是否添加成功，命令是：<code>chkconfig --list</code></p><h3 id="Linux用户管理"><a href="#Linux用户管理" class="headerlink" title="Linux用户管理"></a>Linux用户管理</h3><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><h3 id="Linux用户管理相关命令"><a href="#Linux用户管理相关命令" class="headerlink" title="Linux用户管理相关命令"></a>Linux用户管理相关命令</h3><ul><li><p><code>useradd 选项 用户名</code>:添加用户账号</p></li><li><p><code>userdel 选项 用户名</code>:删除用户帐号</p></li><li><p><code>usermod 选项 用户名</code>:修改帐号</p></li><li><p><code>passwd 用户名</code>:更改或创建用户的密码</p></li><li><p><code>passwd -S 用户名</code>:显示用户账号密码信息</p></li><li><p><code>passwd -d 用户名</code>: 清除用户密码</p></li></ul><p><strong>useradd</strong>命令用于Linux中创建的新的系统用户。<strong>useradd</strong>可用来建立用户帐号。帐号建好之后，再用<strong>passwd</strong>设定帐号的密码．而可用<strong>userdel</strong>删除帐号。使用<strong>useradd</strong>指令所建立的帐号，实际上是保存在<code>/etc/passwd</code>文本文件中。</p><p><strong>passwd</strong>命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p><h4 id="Linux系统用户组的管理"><a href="#Linux系统用户组的管理" class="headerlink" title="Linux系统用户组的管理"></a>Linux系统用户组的管理</h4><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对<code>/etc/group</code>文件的更新。</p><p>Linux系统用户组的管理相关命令:</p><ul><li><p><code>groupadd 选项 用户组</code> :增加一个新的用户组 </p></li><li><p><code>groupdel 用户组</code>:要删除一个已有的用户组 </p></li><li><p><code>groupmod 选项 用户组</code>: 修改用户组的属性</p></li></ul><p>其他常用命令</p><ul><li><code>pwd</code>：显示当前所在位置</li><li><code>grep</code> 要搜索的字符串 要搜索的文件 <code>--color</code>：搜索命令，–color代表高亮显示</li><li><p><code>ps -ef/ps aux</code>：这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<code>ps aux|grep redis</code>（查看包括redis字符串的进程）<br>注意：如果直接用 <strong>ps</strong>（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。</p></li><li><p><code>kill -9 进程的pid</code>：杀死进程（-9 表示强制终止。）<br>先用ps查找进程，然后用kill杀掉</p></li></ul><p><strong>网络通信命令：</strong></p><ul><li>查看当前系统的网卡信息：<code>ifconfig</code></li><li>查看与某台机器的连接情况：<code>ping</code></li><li>查看当前系统的端口使用：<code>netstat -ntlp</code>或者<code>ss -ntlp</code></li><li><p><strong>reboot：</strong>重开机。<br> <code>reboot -w</code>：做个重开机的模拟（只有纪录并不会真的重开机）。</p></li><li><p><strong>shutdown</strong> 关机命令</p></li><li><p><code>shutdown -h now</code>：指定现在立即关机；<br><code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code>:指定5分钟后关机，同时送出警告信息给登入用户。</p><ul><li>-c 取消前一个关机命令</li><li>-h 关机</li><li>-r 重启<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shutdown -r 06:00</span><br><span class="line">shutdown -c</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>init</strong>命令</p><ul><li>关机：<code>init 0</code></li><li>重启：<code>init 6</code></li></ul></li><li><p><strong>init</strong>系统的运行级别</p><ul><li>0 关机</li><li>1 但用户</li><li>2 不完全多用户，不包含NFS服务</li><li>3 完全多用户</li><li>4 未分配</li><li>5 图形界面</li><li>6 重启</li></ul></li></ul><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="系统启动"><a href="#系统启动" class="headerlink" title="系统启动"></a>系统启动</h4><p>1.BIOS</p><ul><li>计算机通电后，第一件事就是读取刷入ROM芯片的开机程序，这个程序叫做 <strong>(Basic Input/Output System)</strong></li></ul><p>2.硬件自检</p><ul><li>BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做 <strong>“硬件自检”</strong>（Power-On Self-Test)</li><li>如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。</li><li>如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。</li></ul><p>3.启动顺序</p><ul><li>硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。</li><li>这时，BIOS需要知道，<strong>“下一阶段的启动程序”</strong>具体存放在哪一个设备</li><li>BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做 <strong>“启动顺序”</strong>（Boot Sequence）</li><li>BIOS按照 <strong>“启动顺序”</strong>，把控制权转交给排在第一位的储存设备。</li><li>这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给 <strong>“启动顺序”</strong>中的下一个设备。</li><li>这最前面的512个字节，就叫做 <strong>“主引导记录”</strong>（Master boot record，缩写为MBR）</li></ul><p>4.主引导记录的结构</p><ul><li><strong>主引导记录</strong>只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。<ul><li>第1-446字节：是用来记录系统的启动信息的,调用操作系统的机器码</li><li>第447-510字节(64个字节)：分区表（Partition table），分区表的作用，是将硬盘分成若干个区</li><li>第511-512字节：主引导记录签名（0x55和0xAA）</li></ul></li></ul><p>5.分区表</p><ul><li><strong>磁盘分区</strong>是使用分区编辑器在磁盘上划分几个逻辑部分</li><li>磁盘一旦划分成多个分区，不同类的目录与文件可以存储进不同的分区内</li><li><strong>主引导记录</strong> 因此必须知道将控制权转交给哪个区</li><li>分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做”主分区”<ul><li>第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。</li><li>第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。</li><li>第5个字节：主分区类型，比如FAT32、NTFS等。</li><li>第6-8个字节：主分区最后一个扇区的物理位置。</li><li>第9-12字节：该主分区第一个扇区的逻辑地址。</li><li>第13-16字节：主分区的扇区总数。</li></ul></li></ul><p>6.硬盘启动</p><ul><li>计算机的控制权就要转交给硬盘的某个分区了</li><li>四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做 <strong>“卷引导记录”</strong>（Volume boot record，缩写为VBR）</li></ul><p>7.操作系统</p><ul><li>控制权转交给操作系统后，操作系统的内核首先被载入内存。</li><li>以Linux系统为例，先载入<code>/boot</code>目录下面的<code>kernel</code>。内核加载成功后，第一个运行的程序是<code>/sbin/init</code>。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代</li><li>然后，<code>init</code>线程加载系统的各个模块，比如窗口程序和网络程序，直至执行<code>/bin/login</code>程序，跳出登录界面，等待用户输入用户名和密码。</li></ul><blockquote><p>转载自：<br><a href="https://mp.weixin.qq.com/s/-eANH2n_IDo6ojyP3RdeDA" target="_blank" rel="noopener">linux基础（一）</a><br><a href="https://mp.weixin.qq.com/s/C8kv8itPU1wHYGaH3tG9z" target="_blank" rel="noopener">linux基础（二）</a><br><a href="https://juejin.im/post/5c9319c2e51d450d597ea3ff" target="_blank" rel="noopener">前端linux基础，这一篇就够了</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;本篇文章主要是一些关于linux操作系统、linux诞生等一些背景知识及简单介绍。以及一些linux基础操作命令。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
