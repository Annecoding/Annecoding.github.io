<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://annecoding.github.io/"/>
  <updated>2019-11-21T03:57:52.460Z</updated>
  <id>https://annecoding.github.io/</id>
  
  <author>
    <name>Annecoding&#39;s</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Annecoding&#39;s Studio.</title>
    <link href="https://annecoding.github.io/2019/11/21/%E7%AB%99%E7%82%B9%E7%9B%AE%E5%BD%95/"/>
    <id>https://annecoding.github.io/2019/11/21/站点目录/</id>
    <published>2019-11-21T03:37:57.000Z</published>
    <updated>2019-11-21T03:57:52.460Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>本站点目录所有系列基本由难到易，由浅入…..哦本人才疏学浅依然是……浅…..方便个人进行知识梳理亦方便他人学习指教。本站目录将持续更新，敬请期待！</p><a id="more"></a><h2 id="本站目录"><a href="#本站目录" class="headerlink" title="本站目录"></a>本站目录</h2><h3 id="linux入门系列"><a href="#linux入门系列" class="headerlink" title="linux入门系列"></a>linux入门系列</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ul><li><a href="https://annecoding.github.io/2019/03/24/linux基础/">linux基础精选系列</a></li><li><a href="https://annecoding.github.io/2019/03/25/Linux学习笔记/">Linux个人学习笔记整理</a></li><li><a href="https://annecoding.github.io/2019/03/27/linux常用命令/">linux常用命令整理·精选</a></li><li><a href="https://annecoding.github.io/2019/03/23/rpm命令/">rpm命令使用</a></li></ul><h4 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h4><ul><li><a href="https://annecoding.github.io/2019/03/22/linxu下vi编辑器的使用/">生产环境下最快速学会vi编辑器的使用</a></li><li><a href="https://annecoding.github.io/2019/03/22/linxu下vi编辑器的配置/">linxu下vi编辑器的配置</a></li></ul><h4 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h4><ul><li><a href="https://annecoding.github.io/2019/03/18/linux_centos网卡配置/">centos网卡配置</a></li><li><a href="https://annecoding.github.io/2019/07/20/ubuntu修改IP地址/">ubuntu修改IP地址</a></li></ul><h4 id="端口开放"><a href="#端口开放" class="headerlink" title="端口开放"></a>端口开放</h4><ul><li><a href="https://annecoding.github.io/2019/03/18/linux%E7%AB%AF%E5%8F%A3%E5%BC%80%E6%94%BE/">linux系统下端口的开放</a></li></ul><h4 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h4><ul><li><a href="https://annecoding.github.io/2019/03/18/linux_nodejs%E5%AE%89%E8%A3%85/">linux下最详细安装nodejs及配置</a></li><li><a href="https://annecoding.github.io/2019/03/19/nginx%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/">Linux系统Nginx安装及反向代理配置</a></li><li><a href="https://annecoding.github.io/2019/05/15/项目上线流程/">linux下项目上线流程</a></li><li><a href="https://annecoding.github.io/2019/08/22/Centos使用mailx告警邮件配置/">Centos使用mailx告警邮件配置</a></li></ul><h3 id="linux进阶学习"><a href="#linux进阶学习" class="headerlink" title="linux进阶学习"></a>linux进阶学习</h3><h4 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h4><ul><li><a href="https://annecoding.github.io/2019/07/20/linux系统扫描命令和安全防范笔记/">linux系统扫描命令和安全防范笔记</a></li></ul><h4 id="shell知识碎片"><a href="#shell知识碎片" class="headerlink" title="shell知识碎片"></a>shell知识碎片</h4><ul><li><a href="https://annecoding.github.io/2019/06/10/linux中玩转awk/">linux中玩转awk技巧分享</a></li><li><a href="https://annecoding.github.io/2019/06/11/linux中玩转sed/">linux中玩转sed技巧分享</a></li><li><a href="https://annecoding.github.io/2019/08/13/shell中切分文件名和扩展名/">shell中切分文件名和扩展名</a></li></ul><h4 id="shell实例"><a href="#shell实例" class="headerlink" title="shell实例"></a>shell实例</h4><ul><li><a href="https://annecoding.github.io/2019/05/15/shell脚本练习/">shell脚本实例入门精选系列</a></li><li><a href="https://annecoding.github.io/2019/06/15/linux下占用cpu和内存很高的进程/">linux下占用cpu和内存top10</a></li><li><a href="https://annecoding.github.io/2019/08/30/linux查看网卡实时流量/">linux查看网卡实时流量</a></li><li><a href="https://annecoding.github.io/2019/07/25/监控多台服务器利用率/">监控多台服务器利用率</a></li><li><a href="https://annecoding.github.io/2019/08/28/shell脚本实现centos系统初始化配置/">shell脚本实现centos系统初始化配置</a></li><li><a href="https://annecoding.github.io/2019/08/29/批量创建用户并设置随机密码/">批量创建用户并设置随机密码</a></li><li><a href="https://annecoding.github.io/2019/08/29/一键查看服务器资源利用率/">一键查看服务器资源利用率</a></li><li><a href="https://annecoding.github.io/2019/09/04/linux使用expect批量执行主机命令/">linux使用expect批量执行主机命令</a></li><li><a href="https://annecoding.github.io/2019/09/23/nginx访问日志分析/">nginx访问日志分析</a></li></ul><h3 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h3><ul><li><a href="https://annecoding.github.io/2019/03/18/git使用/">Git命令的使用及总结</a></li></ul><h3 id="Docker部署系列"><a href="#Docker部署系列" class="headerlink" title="Docker部署系列"></a>Docker部署系列</h3><ul><li><a href="https://annecoding.github.io/2019/03/19/docker安装jenkins/#利用Docker来部署jenkins的部署过程">利用Docker来部署jenkins的部署过程</a></li></ul><h3 id="Vue学习系列"><a href="#Vue学习系列" class="headerlink" title="Vue学习系列"></a>Vue学习系列</h3><ul><li><a href="https://annecoding.github.io/2019/03/21/vue学习/">vue.js初使用</a></li><li><a href="https://annecoding.github.io/2019/04/16/vue组件/">vue组件学习</a></li><li><a href="https://annecoding.github.io/2019/04/16/vue路由/">vue路由学习</a></li><li><a href="https://annecoding.github.io/2019/04/17/vue-blog项目/">vue-myblog项目实现</a></li><li><a href="https://annecoding.github.io/2019/04/25/vcustomers_demo/">Vue后台用户管理系统</a></li></ul><h3 id="Mac使用系列"><a href="#Mac使用系列" class="headerlink" title="Mac使用系列"></a>Mac使用系列</h3><ul><li><a href="https://annecoding.github.io/2019/07/20/linux安装hping添加环境变量/">Linux安装hping添加环境变量</a></li><li><a href="https://annecoding.github.io/2019/07/24/mtr网络分析工具安装/">mtr网络分析工具安装</a></li></ul><h3 id="Hexo使用系列"><a href="#Hexo使用系列" class="headerlink" title="Hexo使用系列"></a>Hexo使用系列</h3><ul><li><a href="https://annecoding.github.io/2019/05/20/hexo img 403/">hexo图片显示问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;本站点目录所有系列基本由难到易，由浅入…..哦本人才疏学浅依然是……浅…..方便个人进行知识梳理亦方便他人学习指教。本站目录将持续更新，敬请期待！&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>nginx访问日志分析</title>
    <link href="https://annecoding.github.io/2019/09/23/nginx%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"/>
    <id>https://annecoding.github.io/2019/09/23/nginx访问日志分析/</id>
    <published>2019-09-23T08:42:34.000Z</published>
    <updated>2019-09-25T06:55:47.320Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p><strong>nginx</strong>的log日志分为<strong>access log</strong>和<strong>error log</strong>。其中<strong>access log</strong>记录了哪些用户，哪些页面以及用户浏览器、ip和其他的访问信息。<strong>error log</strong>则是记录服务器错误日志。</p><a id="more"></a><h3 id="nginx日志格式配置"><a href="#nginx日志格式配置" class="headerlink" title="nginx日志格式配置"></a>nginx日志格式配置</h3><p>在nginx的<strong>nginx.conf</strong>配置文件找到：<strong>log_format</strong> 这里就是日志的格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                  <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                  <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br></pre></td></tr></table></figure><p><strong>常见的日志变量</strong></p><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>$remote_addr,$http_x_forwarded_for</td><td>记录客户端IP地址</td></tr><tr><td>$remote_user</td><td>记录客户端用户名称，默认为空</td></tr><tr><td>$request</td><td>记录请求的URL和HTTP协议(GET,POST,DEL等)</td></tr><tr><td>$time_local</td><td>通用日志格式下的本地时间，记录访问时间</td></tr><tr><td>$status</td><td>记录请求状态</td></tr><tr><td>$body_bytes_sent</td><td>发送给客户端的字节数，不包括响应头的大小，该变量与Apache模块mod_log_config里的“%B”参数兼容。</td></tr><tr><td>$http_referer</td><td>记录从哪个页面链接访问过来的</td></tr><tr><td>$http_user_agent</td><td>记录客户端浏览器相关信息</td></tr><tr><td>$http_x_forwarded_for</td><td>当前端有代理服务器时，设置web节点记录客户端地址的配置，此参数生效的前提是代理服务器也要进行相关的http_x_forwarded_for设置</td></tr><tr><td>$bytes_sent</td><td>发送给客户端的总字节数</td></tr><tr><td>$connection</td><td>连接的序列号</td></tr><tr><td>$connection_requests</td><td>当前通过一个连接获得的请求数量</td></tr><tr><td>$msec</td><td>日志写入时间，单位为秒，精度是毫秒</td></tr><tr><td>$pipe</td><td>如果请求是通过HTTP流水线(pipelined)发送，pipe值为“p”，否则为“.”</td></tr><tr><td>$http_host</td><td>请求地址，即浏览器中你输入的地址（IP或域名）</td></tr><tr><td>$request_body</td><td>记录POST数据</td></tr><tr><td>$request_length</td><td>请求的长度（包括请求行，请求头和请求正文）</td></tr><tr><td>$request_time</td><td>请求处理时间，单位为秒，精度毫秒，从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止</td></tr><tr><td>$time_iso8601</td><td>ISO8601标准格式下的本地时间</td></tr><tr><td>$upstream_status</td><td>upstream状态，成功是200</td></tr><tr><td>$upstream_addr</td><td>后台upstream的地址，即真正提供服务的主机地址</td></tr><tr><td>$upstream_response_time</td><td>请求过程中，upstream响应时间</td></tr></tbody></table><p><strong>access日志格式如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">111.222.222.222 - - [16/Apr/2018:16:18:15 +0800] <span class="string">"GET / HTTP/1.1"</span> 200 612 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36"</span></span><br><span class="line">111.222.222.222 - - [16/Apr/2018:16:18:16 +0800] <span class="string">"GET /favicon.ico HTTP/1.1"</span> 404 571 <span class="string">"http://39.107.204.206/"</span> <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36"</span></span><br></pre></td></tr></table></figure><p>1.客户端（用户）IP地址<br>2.访问时间<br>3.请求的url（目标url地址）的host和http协议<br>4.请求状态(状态码，200表示成功，404表示页面不存在，301表示永久重定向等)<br>5.请求页面大小，默认为B（byte）<br>6.来源页面，即从哪个页面转到本页，专业名称叫做“referer”<br>7.用户浏览器的其他信息，浏览器版本、浏览器类型等</p><h3 id="常用日志分析示例"><a href="#常用日志分析示例" class="headerlink" title="常用日志分析示例"></a>常用日志分析示例</h3><p>1.根据IP地址统计访问页码状态码数量TOP5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据IP地址、状态码和访问路径统计并排序找出top5</span></span><br><span class="line">$ awk <span class="string">'&#123;a[$1" "$7" "$9]++&#125;END&#123;for(v in a)&#123;if(a[v]&gt;10)print v,a[v]&#125;&#125;'</span> access.log | sort -k4 -nr | head -5</span><br><span class="line">185.234.217.54 /user/index.jsp 302 96701</span><br><span class="line">222.165.230.7 /user/index.jsp 302 76652</span><br><span class="line">210.27.176.184 /wls-wsat/index.jsp 302 45952</span><br><span class="line">61.162.236.77 /cgi-bin/index.jsp 302 2733</span><br></pre></td></tr></table></figure><p>2.根据时间段统计访问最多的IP地址TOP5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'$4&gt;="[16/Apr/2018:16:43:16" &amp;&amp; $4&lt;="[16/Apr/2018:22:43:16" &#123;a[$1]++&#125;END&#123;for(i in a)print i,a[i]&#125;'</span> access.log | sort -k2 -nr | head -10</span><br><span class="line">111.222.222.222 522</span><br><span class="line">66.102.6.249 26</span><br><span class="line">66.102.6.247 26</span><br><span class="line">66.102.6.245 25</span><br><span class="line">64.233.172.151 2</span><br></pre></td></tr></table></figure><p>3.根据状态码进行请求次数排序，cut实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配第9列为数字的选项，用正则来实现</span></span><br><span class="line">$ awk <span class="string">'$9 ~/^[0-9]&#123;3&#125;/&#123;print $9&#125;'</span> access.log | sort | uniq -c | sort -r </span><br><span class="line">93648 200</span><br><span class="line">3078 404</span><br><span class="line">307128 302</span><br><span class="line">3016 304</span><br><span class="line">2510 400</span><br><span class="line"> 868 173</span><br><span class="line"> 263 499</span><br><span class="line">  15 500</span><br><span class="line">   6 502</span><br><span class="line">   6 413</span><br><span class="line">   4 408</span><br><span class="line">   2 403</span><br><span class="line">   1 405</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ cat access.log | cut -d <span class="string">'"'</span> -f3 | cut -d <span class="string">' '</span> -f2 | sort | uniq -c | sort -r </span><br><span class="line">93648 200</span><br><span class="line">8883 400</span><br><span class="line">3078 404</span><br><span class="line">307130 302</span><br><span class="line">3016 304</span><br><span class="line"> 263 499</span><br><span class="line">  15 500</span><br><span class="line">   6 502</span><br><span class="line">   6 413</span><br><span class="line">   4 408</span><br><span class="line">   2 403</span><br><span class="line">   1 405</span><br></pre></td></tr></table></figure><p>4.统计总请求数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wc -l  access.log |awk <span class="string">'&#123;print $1&#125;'</span></span><br><span class="line">416252</span><br></pre></td></tr></table></figure><p>5.统计访问最多的独立IP TOP5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'&#123;a[$1]++&#125;END&#123;for(i in a)print i,a[i]&#125;'</span> access.log| sort -k2 -nr |head -5</span><br><span class="line">185.234.217.54 96703</span><br><span class="line">222.165.230.7 77701</span><br><span class="line">210.27.176.184 45953</span><br><span class="line">1.202.116.228 8386</span><br><span class="line">1.202.117.42 7524</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ awk <span class="string">'&#123;print $1&#125;'</span> access.log|sort |uniq -c |sort -nr |head -5</span><br><span class="line">96703 185.234.217.54</span><br><span class="line">77701 222.165.230.7</span><br><span class="line">45953 210.27.176.184</span><br><span class="line">8386 1.202.116.228</span><br><span class="line">7524 1.202.117.42</span><br></pre></td></tr></table></figure><p>6.每秒客户端请求数 TOP5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log|cut -d <span class="string">'"'</span> -f2 | cut -d <span class="string">' '</span> -f1 |sort |uniq -c|sort -r |head -3</span><br><span class="line">41793 POST</span><br><span class="line">365183 GET</span><br><span class="line">2064 HEAD</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># 以空格和双引号的一半为分隔符，取请求数，不然有双引号影响判断</span></span><br><span class="line">$ awk -F <span class="string">'[" ]'</span> <span class="string">'&#123;a[$7]++&#125;END&#123;for(i in a)print i,a[i]&#125;'</span> access.log| sort -k2 -nr | head -3</span><br><span class="line">GET 365183</span><br><span class="line">POST 41793</span><br><span class="line">HEAD 2064</span><br></pre></td></tr></table></figure><p>7.访问最频繁IP TOP5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'&#123;a[$1]++&#125;END&#123;for(i in a)print i,a[i]&#125;'</span> access.log|sort -k2 -nr |head -5</span><br><span class="line">185.234.217.54 96703</span><br><span class="line">222.165.230.7 77701</span><br><span class="line">210.27.176.184 45953</span><br><span class="line">1.202.116.228 8386</span><br><span class="line">1.202.117.42 7524</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ awk <span class="string">'&#123;print $1&#125;'</span> access.log|sort |uniq -c |sort -nr |head -5</span><br><span class="line">96703 185.234.217.54</span><br><span class="line">77701 222.165.230.7</span><br><span class="line">45953 210.27.176.184</span><br><span class="line">8386 1.202.116.228</span><br><span class="line">7524 1.202.117.42</span><br></pre></td></tr></table></figure><p>8.访问最频繁的URL TOP5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'&#123;a[$7]++&#125;END&#123;for(i in a)print i,a[i]&#125;'</span> access.log |sort -k2 -nr |head -5</span><br><span class="line">/user/index.jsp 173382</span><br><span class="line">/wls-wsat/index.jsp 46197</span><br><span class="line">/ 24163</span><br><span class="line">/phpMyAdmin/scripts/index.jsp 12507</span><br><span class="line">/phpMyAdmin-3.0.1.1/scripts/index.jsp 7564</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ awk <span class="string">'&#123;print $7&#125;'</span> access.log|sort|uniq -c|sort -nr|head -5</span><br><span class="line">173382 /user/index.jsp</span><br><span class="line">46197 /wls-wsat/index.jsp</span><br><span class="line">24163 /</span><br><span class="line">12507 /phpMyAdmin/scripts/index.jsp</span><br><span class="line">7564 /phpMyAdmin-3.0.1.1/scripts/index.jsp</span><br></pre></td></tr></table></figure><p>9.HTTP状态码(非200)统计 TOP5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># awk中if使用正则，if( info ~ /test/)，这里是只取数字，排除其他干扰</span></span><br><span class="line"><span class="comment"># DATEPATTERN="^[0-9]&#123;4&#125;-[0-9]&#123;1,2&#125;-[0-9]&#123;1,2&#125;$"</span></span><br><span class="line"><span class="comment"># shell中使用正则，if[[ info =~ $DATEPATTERN ]]，两种使用有区别，分情况使用</span></span><br><span class="line">$ awk <span class="string">'&#123;if ( $9 != 200 &amp;&amp; $9 ~ /^[0-9]&#123;3&#125;/ )&#123;print $9&#125;&#125;'</span> access.log|sort|uniq -c|sort -nr|head -5</span><br><span class="line">307128 302</span><br><span class="line">3078 404</span><br><span class="line">3016 304</span><br><span class="line">2510 400</span><br><span class="line"> 868 173</span><br></pre></td></tr></table></figure><p>10.分析请求数大于50000的源IP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意if需要再加一层&#123;&#125;</span></span><br><span class="line">$ awk <span class="string">'&#123;a[$1]++&#125;END&#123;for(i in a) &#123;if(a[i]&gt;50000)print i,a[i]&#125;&#125;'</span> access.log|sort -k2 -nr</span><br><span class="line">185.234.217.54 96703</span><br><span class="line">222.165.230.7 77701</span><br></pre></td></tr></table></figure><p>11.显示返回404状态码的url</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'($9 ~ /404/)'</span> access.log | awk <span class="string">'&#123;print $7&#125;'</span> | sort | uniq -c | sort -r |head -5</span><br><span class="line">1426 http://www.baidu.com/cache/global/img/gs.gif</span><br><span class="line"> 354 /favicon.ico</span><br><span class="line"> 169 http://www.qq.com/404/search_children.js</span><br><span class="line"> 128 /</span><br><span class="line">  89 /phpmyadmin/favicon.ico</span><br></pre></td></tr></table></figure><p>12.响应大于5秒的URL TOP5（这个本次并未统计）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'&#123;if ($7 &gt; 5)&#123;print $6&#125;&#125;'</span> access.log|sort|uniq -c|sort -nr |head -5</span><br></pre></td></tr></table></figure><h3 id="Web服务流量名词介绍"><a href="#Web服务流量名词介绍" class="headerlink" title="Web服务流量名词介绍"></a>Web服务流量名词介绍</h3><p><strong>网站并发连接数：定义为网站服务器在单位时间内能够处理的最大连接数。</strong>示例：某网站的并发是5000.意味着单位时间内（理解为1秒或数秒内），正在处理的连接数，正在建立的连接数，加起来一共是5000个。</p><p><strong>IP：即Internet Protocol</strong>，一般指独立IP数，独立IP数是指不同IP地址的计算机访问网站时被计的总次数。一般一天00:00-24:00内相同IP地址只被计算一次。</p><p><strong>PV：即Page View</strong>，中文翻译为页面浏览，即页面浏览量或点击量，不管客户端是否相同，也不管IP和网站页面是否相同，用户只要访问网站页面就会计算PV，一次计为一个PV</p><p><strong>UV：即Unique Visitor</strong>，同一个客户端（PC或移动端）访问网站被计为一个访客。一天（00:00-24:00）内相同的客户端访问同一个网站只统计一次UV。UV一般是以客户端Cookie等技术作为统计依据的，实际统计会有误差。</p><p><strong>IP，PV，UV的区别在哪？</strong></p><p>举例说明：假设某个公司有10个员工，都访问了<strong><a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a></strong>这个网站。每个人平均浏览了5个页面，但是公司的对外出口是一个公网IP。所以对于<strong><a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a></strong>这个网站而言，只会计算1个独立IP访问。但是因为有10个人在访问      <strong><a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a></strong>这个网站，并且平均都访问了5次，因此，对于<strong><a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a></strong>这个网站而言，PV数就是10x5=50个PV，而因为有10个人访问，就是10个不同的客户端访问，因此，UV（独立访客）为10。</p><p>因此上例结果为IP数为1个，PV数为50个，UV为10个。通过这个结果，不难看出，一个网站的独立IP数量要比网站实际访问的PV数量小得多。通常情况下，网站的UV数也会大于独立IP数。</p><p>🔅 举个栗子：统计该服务器访问PV和UV</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PV</span></span><br><span class="line">$ awk <span class="string">'&#123;a[$7]++&#125;END&#123;print "PV:",length(a);for(v in a)&#123;if(a[v]&gt;10)print v,a[v]&#125;&#125;'</span> access.log |sort -k2 -nr | head</span><br><span class="line">/user/index.jsp 173382</span><br><span class="line">/wls-wsat/index.jsp 46197</span><br><span class="line">/ 24163</span><br><span class="line">PV: 13907</span><br><span class="line">/phpMyAdmin/scripts/index.jsp 12507</span><br><span class="line">/phpMyAdmin-3.0.1.1/scripts/index.jsp 7564</span><br><span class="line">/index.jsp 7306</span><br><span class="line">/services/json/management/modcard/getcard 5498</span><br><span class="line">400 5428</span><br><span class="line">/services/json/schema/setup/getconfiguration 3312</span><br><span class="line"><span class="comment"># UV</span></span><br><span class="line">$ awk <span class="string">'&#123;a[$1]++&#125;END&#123;print "UV:",length(a);for(v in a)&#123;if(a[v]&gt;10)print v,a[v]&#125;&#125;'</span> access.log |sort -k2 -nr | head</span><br><span class="line">185.234.217.54 96703</span><br><span class="line">222.165.230.7 77701</span><br><span class="line">210.27.176.184 45953</span><br><span class="line">UV: 16218</span><br><span class="line">1.202.116.228 8386</span><br><span class="line">1.202.117.42 7524</span><br><span class="line">111.222.222.222 7067</span><br><span class="line">1.202.50.170 6452</span><br><span class="line">124.126.27.107 5384</span><br><span class="line">1.202.1.189 5379</span><br></pre></td></tr></table></figure><blockquote><p><strong>部分参考链接如下</strong><br><a href="https://blog.csdn.net/bbwangj/article/details/82186162" target="_blank" rel="noopener">Nginx日志配置及日志分析脚本案例</a><br><a href="https://blog.51cto.com/13707680/2116001" target="_blank" rel="noopener">Nginx日志分析和参数详解</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;&lt;strong&gt;nginx&lt;/strong&gt;的log日志分为&lt;strong&gt;access log&lt;/strong&gt;和&lt;strong&gt;error log&lt;/strong&gt;。其中&lt;strong&gt;access log&lt;/strong&gt;记录了哪些用户，哪些页面以及用户浏览器、ip和其他的访问信息。&lt;strong&gt;error log&lt;/strong&gt;则是记录服务器错误日志。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="nginx" scheme="https://annecoding.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>linux使用expect批量执行主机命令</title>
    <link href="https://annecoding.github.io/2019/09/04/linux%E4%BD%BF%E7%94%A8expect%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C%E4%B8%BB%E6%9C%BA%E5%91%BD%E4%BB%A4/"/>
    <id>https://annecoding.github.io/2019/09/04/linux使用expect批量执行主机命令/</id>
    <published>2019-09-04T02:57:10.000Z</published>
    <updated>2019-09-04T06:00:41.086Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>现在有两台Linux主机A和B，如何从A主机ssh到B主机，然后在B主机上执行命令，如何使这个过程实现全程自动化？之前有用过<strong>ssh-copy-id免密钥</strong>的形式，这里是用第二种方式<strong>expect</strong>实现。</p><a id="more"></a><h3 id="expect是什么"><a href="#expect是什么" class="headerlink" title="expect是什么"></a>expect是什么</h3><p>expect是一个免费的编程工具，用来<strong>实现自动的交互式任务，而无需人为干预。</strong> 说白了，expect就是一套用来实现自动交互功能的软件。</p><p>在实际工作中，我们运行命令、脚本或程序时，这些命令、脚本或程序都需要从终端输入某些继续运行的指令，而这些输入都需要人为的手工进行。而<strong>利用expect，则可以根据程序的提示，模拟标准输入提供给程序，从而实现自动化交互执行。</strong> 这就是expect！！！</p><p>1.安装expect</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install expect -y</span><br></pre></td></tr></table></figure><p>2.使用expect，基本上都是和以下四个命令打交道：</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>send</td><td>用于向进程发送字符串</td></tr><tr><td>expect</td><td>从进程接收字符串</td></tr><tr><td>spawn</td><td>启动新的进程</td></tr><tr><td>interact</td><td>允许用户交互</td></tr></tbody></table><p><code>send</code>命令接收一个<strong>字符串参数</strong>，并将该参数发送到进程。</p><p><code>expect</code>命令和<code>send</code>命令相反，<code>expect</code>通常用来等待一个进程的反馈，我们根据进程的反馈，再发送对应的交互命令。</p><p><code>spawn</code>命令用来<strong>启动新的进程</strong>，<code>spawn</code>后的<code>send</code>和<code>expect</code>命令都是和使用<code>spawn</code>打开的进程进行交互。</p><p>interact命令用的其实不是很多，一般情况下使用<code>spawn</code>、<code>send</code>和<code>expect</code>命令就可以很好的完成我们的任务；但在一些特殊场合下还是需要使用<code>interact</code>命令的，<code>interact</code>命令主要用于退出自动化，进入人工交互。比如我们使用<code>spawn</code>、<code>send</code>和<code>expect</code>命令完成了ftp登陆主机，执行下载文件任务，但是我们希望在文件下载结束以后，仍然可以停留在ftp命令行状态，以便手动的执行后续命令，此时使用<code>interact</code>命令就可以很好的完成这个任务。</p><h3 id="ssh免密登录"><a href="#ssh免密登录" class="headerlink" title="ssh免密登录"></a>ssh免密登录</h3><p>1.实现ssh登录执行命令，脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">SERVER=<span class="string">"192.168.1.241"</span></span><br><span class="line">PASSWD=nf123456</span><br><span class="line">expect -c <span class="string">"</span></span><br><span class="line"><span class="string">        set timeout -1;</span></span><br><span class="line"><span class="string">        spawn ssh <span class="variable">$SERVER</span>;</span></span><br><span class="line"><span class="string">        expect &#123;</span></span><br><span class="line"><span class="string">                \"yes/no\" &#123; send \"yes\r\" ;exp_contine; &#125;</span></span><br><span class="line"><span class="string">                \"password:\" &#123; send \"<span class="variable">$PASSWD</span>\r\"; &#125;</span></span><br><span class="line"><span class="string">        &#125;;</span></span><br><span class="line"><span class="string">        expect \"]#\" &#123; send \"ls -la \r\" &#125;;</span></span><br><span class="line"><span class="string">        expect \"]#\" &#123; send \"exit \r\" &#125;;</span></span><br><span class="line"><span class="string">        expect eof;</span></span><br><span class="line"><span class="string">        "</span></span><br></pre></td></tr></table></figure><p>上面的shell功能和expect脚本实现的功能一致，都是通过ssh登录进去后输入，执行<code>ls -la</code>命令，其中</p><p><code>set timeout -1</code>设置超时时间</p><p><code>expect</code>后面需要加上-c</p><p><code>expect</code>命令用“双引号包围起来的，这点要注意，里面如果有”需要用\”转义</p><p><code>ls -la</code>代表命令结束后发送一个退出命令，一般需要加上，防止阻塞</p><p><code>expect eof</code>匹配spawn结束</p><p>2.ssh批量免密demo，脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">SERVERS=<span class="string">"192.168.1.241 192.168.1.242"</span></span><br><span class="line">PASSWD=<span class="string">"123456"</span></span><br><span class="line"><span class="keyword">function</span> sshcopyid</span><br><span class="line">&#123;</span><br><span class="line">        expect -c <span class="string">"</span></span><br><span class="line"><span class="string">                set timeout -1;</span></span><br><span class="line"><span class="string">                spawn ssh-copy-id <span class="variable">$1</span>;</span></span><br><span class="line"><span class="string">                expect &#123;</span></span><br><span class="line"><span class="string">                        \"yes/no\" &#123; send \"yes\r\" ;exp_contine; &#125;</span></span><br><span class="line"><span class="string">                        \"password:\" &#123; send \"<span class="variable">$PASSWD</span>\r\";exp_continue; &#125;</span></span><br><span class="line"><span class="string">                &#125;;</span></span><br><span class="line"><span class="string">                expect eof;</span></span><br><span class="line"><span class="string">        "</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> server <span class="keyword">in</span> <span class="variable">$SERVERS</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        sshcopyid <span class="variable">$server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="批量执行主机命令"><a href="#批量执行主机命令" class="headerlink" title="批量执行主机命令"></a>批量执行主机命令</h3><p>1.存储在host.info的主机信息如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat host.info </span><br><span class="line">192.168.1.3 root 22 111111</span><br></pre></td></tr></table></figure><p>2.linux下批量执行主机命令实现脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ cat batch_host.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 接收所传所有参数</span></span><br><span class="line">COMMAND=$*</span><br><span class="line">HOST_INFO=host.info</span><br><span class="line"><span class="comment"># 不匹配文件中的注释</span></span><br><span class="line"><span class="keyword">for</span> IP <span class="keyword">in</span> $(awk <span class="string">'/^[^#]/&#123;print $1&#125;'</span> <span class="variable">$HOST_INFO</span>);<span class="keyword">do</span></span><br><span class="line">        USER=$(awk -v ip=<span class="variable">$IP</span> <span class="string">'ip=$1&#123;print $2&#125;'</span> <span class="variable">$HOST_INFO</span>)</span><br><span class="line">        PORT=$(awk -v ip=<span class="variable">$IP</span> <span class="string">'ip=$1&#123;print $3&#125;'</span> <span class="variable">$HOST_INFO</span>)</span><br><span class="line">        PASS=$(awk -v ip=<span class="variable">$IP</span> <span class="string">'ip=$1&#123;print $4&#125;'</span> <span class="variable">$HOST_INFO</span>)</span><br><span class="line">        <span class="comment"># expect -c执行自身的语句</span></span><br><span class="line">        <span class="comment"># 因为外面有双引号，再次出现都需要转义</span></span><br><span class="line">        <span class="comment"># 执行完命令要退出</span></span><br><span class="line">        expect -c <span class="string">"</span></span><br><span class="line"><span class="string">                spawn ssh -p <span class="variable">$PORT</span> <span class="variable">$USER</span>@<span class="variable">$IP</span></span></span><br><span class="line"><span class="string">                expect &#123;</span></span><br><span class="line"><span class="string">                        \"(yes/no)\" &#123;send \"yes\r\"; exp_continue&#125;</span></span><br><span class="line"><span class="string">                        \"password:\" &#123;send \"<span class="variable">$PASS</span>\r\"; exp_continue&#125;</span></span><br><span class="line"><span class="string">                        \"<span class="variable">$USER</span>@*\" &#123;send \"<span class="variable">$COMMAND</span>\r exit\r\"; exp_continue&#125;</span></span><br><span class="line"><span class="string">                &#125;;</span></span><br><span class="line"><span class="string">        "</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"--------------------------------------------"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>其中<code>exp_continue</code>表示循环式匹配，通常匹配之后都会退出语句，但如果有<code>exp_continue</code>则可以不断循环匹配，输入多条命令，简化写法。</p><p>结合着expect <code>&quot;*password*&quot; {send &quot;$password\r&quot;}</code>这句代码来说说“模式-动作”。简单的说就是匹配到一个模式，就执行对应的动作；匹配到password字符串，就输入密码。</p><p><strong>执行结果如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ bash  test.sh <span class="string">'df -h'</span></span><br><span class="line">spawn ssh -p 22 root@192.168.1.3</span><br><span class="line">Last login: Tue Sep  3 05:05:47 2019 from 192.168.1.2</span><br><span class="line">[root@localhost ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root   14G  979M   13G   7% /</span><br><span class="line">devtmpfs                 3.9G     0  3.9G   0% /dev</span><br><span class="line">tmpfs                    3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs                    3.9G   49M  3.8G   2% /run</span><br><span class="line">tmpfs                    3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1                497M  125M  373M  25% /boot</span><br><span class="line">tmpfs                    783M     0  783M   0% /run/user/0</span><br><span class="line">[root@localhost ~]<span class="comment">#  exit</span></span><br><span class="line"><span class="built_in">logout</span></span><br><span class="line">Connection to 192.168.1.3 closed.</span><br><span class="line">df -h</span><br><span class="line"> <span class="built_in">exit</span></span><br><span class="line">--------------------------------------------</span><br></pre></td></tr></table></figure><blockquote><p>参考链接<br><a href="https://www.jellythink.com/archives/373" target="_blank" rel="noopener">linux expect命令详解</a><br><a href="https://www.cnblogs.com/nfcm/p/7899831.html" target="_blank" rel="noopener">linux下expect命令实现批量ssh免密</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;现在有两台Linux主机A和B，如何从A主机ssh到B主机，然后在B主机上执行命令，如何使这个过程实现全程自动化？之前有用过&lt;strong&gt;ssh-copy-id免密钥&lt;/strong&gt;的形式，这里是用第二种方式&lt;strong&gt;expect&lt;/strong&gt;实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Centos" scheme="https://annecoding.github.io/tags/Centos/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>linux查看网卡实时流量</title>
    <link href="https://annecoding.github.io/2019/08/30/linux%E6%9F%A5%E7%9C%8B%E7%BD%91%E5%8D%A1%E5%AE%9E%E6%97%B6%E6%B5%81%E9%87%8F/"/>
    <id>https://annecoding.github.io/2019/08/30/linux查看网卡实时流量/</id>
    <published>2019-08-30T12:24:52.000Z</published>
    <updated>2019-09-01T04:57:57.769Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>在工作中，我们经常需要查看服务器的实时网卡流量。通常，我们会通过这几种方式查看Linux服务器的实时网卡流量。</p><a id="more"></a><h3 id="sar命令"><a href="#sar命令" class="headerlink" title="sar命令"></a>sar命令</h3><p>sar命令包含在sysstat工具包中，提供系统的众多统计数据。其在不同的系统上命令有些差异，某些系统提供的sar支持基于网络接口的数据统计，也可以查看设备上每秒收发包的个数和流量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DEV显示网络接口信息</span></span><br><span class="line"><span class="comment"># 命令后面1 2 意思是：每一秒钟取1次值，取2次</span></span><br><span class="line">$ sar –n DEV  1 2</span><br></pre></td></tr></table></figure><p>另外，-n参数很有用，他有6个不同的开关：DEV | EDEV | NFS | NFSD | SOCK | ALL ，其代表的含义如下：</p><p>DEV显示网络接口信息。<br>EDEV显示关于网络错误的统计数据。<br>NFS统计活动的NFS客户端的信息。<br>NFSD统计NFS服务器的信息<br>SOCK显示套接字信息<br>ALL显示所有5个开关</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ sar -n DEV 1 2       </span><br><span class="line">Linux 3.10.0-514.26.2.el7.x86_64 (localhost)    08/31/2019      _x86_64_        (1 CPU)</span><br><span class="line"></span><br><span class="line">09:52:28 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">09:52:29 AM      eth0      2.02      1.01      0.13      0.16      0.00      0.00      0.00</span><br><span class="line">09:52:29 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">09:52:29 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">09:52:30 AM      eth0      1.02      1.02      0.07      0.23      0.00      0.00      0.00</span><br><span class="line">09:52:30 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">Average:        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">Average:         eth0      1.52      1.02      0.10      0.19      0.00      0.00      0.00</span><br><span class="line">Average:           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong><br>IFACE：LAN接口<br>rxpck/s：每秒钟接收的数据包<br>txpck/s：每秒钟发送的数据包<br>rxbyt/s：每秒钟接收的字节数<br>txbyt/s：每秒钟发送的字节数<br>rxcmp/s：每秒钟接收的压缩数据包<br>txcmp/s：每秒钟发送的压缩数据包<br>rxmcst/s：每秒钟接收的多播数据包<br>rxerr/s：每秒钟接收的坏数据包<br>txerr/s：每秒钟发送的坏数据包<br>coll/s：每秒冲突数<br>rxdrop/s：因为缓冲充满，每秒钟丢弃的已接收数据包数<br>txdrop/s：因为缓冲充满，每秒钟丢弃的已发送数据包数<br>txcarr/s：发送数据包时，每秒载波错误数<br>rxfram/s：每秒接收数据包的帧对齐错误数<br>rxfifo/s：接收的数据包每秒FIFO过速的错误数<br>txfifo/s：发送的数据包每秒FIFO过速的错误数</p><h3 id="实时监控脚本（1）"><a href="#实时监控脚本（1）" class="headerlink" title="实时监控脚本（1）"></a>实时监控脚本（1）</h3><p>ifconfig可以查看的是从连上网开始的流量总和，<code>cat /proc/net/dev</code>记录的值也是总流量，那么可以计算一下，实时流量=当前流量-上一秒的流量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat network.sh </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 传入网卡参数</span></span><br><span class="line">ethn=<span class="variable">$1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  RX_pre=$(cat /proc/net/dev | grep <span class="variable">$ethn</span> | sed <span class="string">'s/:/ /g'</span> | awk <span class="string">'&#123;print $2&#125;'</span>)</span><br><span class="line">  TX_pre=$(cat /proc/net/dev | grep <span class="variable">$ethn</span> | sed <span class="string">'s/:/ /g'</span> | awk <span class="string">'&#123;print $10&#125;'</span>)</span><br><span class="line">  sleep 1</span><br><span class="line">  RX_next=$(cat /proc/net/dev | grep <span class="variable">$ethn</span> | sed <span class="string">'s/:/ /g'</span> | awk <span class="string">'&#123;print $2&#125;'</span>)</span><br><span class="line">  TX_next=$(cat /proc/net/dev | grep <span class="variable">$ethn</span> | sed <span class="string">'s/:/ /g'</span> | awk <span class="string">'&#123;print $10&#125;'</span>)</span><br><span class="line"> </span><br><span class="line">  clear</span><br><span class="line">  <span class="comment"># echo -e激活转义符</span></span><br><span class="line">  <span class="comment"># 输出时间的标题</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">"\t RX `date +%k:%M:%S` TX"</span></span><br><span class="line"> </span><br><span class="line">  RX=$((<span class="variable">$&#123;RX_next&#125;</span>-<span class="variable">$&#123;RX_pre&#125;</span>))</span><br><span class="line">  TX=$((<span class="variable">$&#123;TX_next&#125;</span>-<span class="variable">$&#123;TX_pre&#125;</span>))</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> [[ <span class="variable">$RX</span> -lt 1024 ]];<span class="keyword">then</span></span><br><span class="line">    RX=<span class="string">"<span class="variable">$&#123;RX&#125;</span>B/s"</span></span><br><span class="line">  <span class="keyword">elif</span> [[ <span class="variable">$RX</span> -gt 1048576 ]];<span class="keyword">then</span></span><br><span class="line">    RX=$(<span class="built_in">echo</span> <span class="variable">$RX</span> | awk <span class="string">'&#123;print $1/1048576 "MB/s"&#125;'</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    RX=$(<span class="built_in">echo</span> <span class="variable">$RX</span> | awk <span class="string">'&#123;print $1/1024 "KB/s"&#125;'</span>)</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> [[ <span class="variable">$TX</span> -lt 1024 ]];<span class="keyword">then</span></span><br><span class="line">    TX=<span class="string">"<span class="variable">$&#123;TX&#125;</span>B/s"</span></span><br><span class="line">  <span class="keyword">elif</span> [[ <span class="variable">$TX</span> -gt 1048576 ]];<span class="keyword">then</span></span><br><span class="line">    TX=$(<span class="built_in">echo</span> <span class="variable">$TX</span> | awk <span class="string">'&#123;print $1/1048576 "MB/s"&#125;'</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    TX=$(<span class="built_in">echo</span> <span class="variable">$TX</span> | awk <span class="string">'&#123;print $1/1024 "KB/s"&#125;'</span>)</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="comment"># 输出流量</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$ethn</span> \t <span class="variable">$RX</span>   <span class="variable">$TX</span> "</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>执行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ./network.sh  eth0</span></span><br><span class="line">         RX 20:23:38 TX</span><br><span class="line">eth0     66B/s   0B/s </span><br><span class="line">         RX 20:23:39 TX</span><br><span class="line">eth0     132B/s   0B/s </span><br><span class="line">         RX 20:23:40 TX</span><br><span class="line">eth0     186B/s   194B/s </span><br><span class="line">         RX 20:23:41 TX</span><br><span class="line">eth0     240B/s   194B/s </span><br><span class="line">         RX 20:23:42 TX</span><br><span class="line">eth0     132B/s   0B/s </span><br><span class="line">         RX 20:23:43 TX</span><br><span class="line">eth0     240B/s   194B/s </span><br><span class="line">         RX 20:23:44 TX</span><br><span class="line">eth0     396B/s   4.19727KB/s </span><br><span class="line">         RX 20:23:45 TX</span><br><span class="line">eth0     276B/s   178B/s</span><br></pre></td></tr></table></figure></p><h3 id="实时监控脚本（2）"><a href="#实时监控脚本（2）" class="headerlink" title="实时监控脚本（2）"></a>实时监控脚本（2）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat network_flow.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 监控实时网卡流量</span></span><br><span class="line"><span class="comment"># $1 接收所传第一个参数 即要监控的网卡</span></span><br><span class="line">NIC=<span class="variable">$1</span></span><br><span class="line"><span class="comment"># echo -e "traffic in --- traffic out"</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>;<span class="keyword">do</span></span><br><span class="line">        <span class="comment"># $0 命令输出结果 ~ 匹配模式</span></span><br><span class="line">        OLD_IN=`awk <span class="string">'$0~"'</span><span class="variable">$NIC</span><span class="string">'"&#123;print $2&#125;'</span> /proc/net/dev`</span><br><span class="line">        OLD_OUT=`awk <span class="string">'$0~"'</span><span class="variable">$NIC</span><span class="string">'"&#123;print $10&#125;'</span> /proc/net/dev`</span><br><span class="line">        sleep 1</span><br><span class="line">        NEW_IN=`awk <span class="string">'$0~"'</span><span class="variable">$NIC</span><span class="string">'"&#123;print $2&#125;'</span> /proc/net/dev`</span><br><span class="line">        NEW_OUT=`awk <span class="string">'$0~"'</span><span class="variable">$NIC</span><span class="string">'"&#123;print $10&#125;'</span> /proc/net/dev`</span><br><span class="line">        clear</span><br><span class="line">        <span class="comment"># printf不换行 %s占位符</span></span><br><span class="line">        IN=$(<span class="built_in">printf</span> <span class="string">"%.1f%s"</span> <span class="string">"<span class="variable">$(($NEW_IN-$OLD_IN)</span>)"</span> <span class="string">"B/s"</span>)</span><br><span class="line">        OUT=$(<span class="built_in">printf</span> <span class="string">"%.1f%s"</span> <span class="string">"<span class="variable">$(($NEW_OUT-$OLD_OUT)</span>)"</span> <span class="string">"B/s"</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"       traffic in  `date +%k:%M:%S`  traffic out "</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$NIC</span>   <span class="variable">$IN</span>              <span class="variable">$OUT</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ./network_flow.sh eth0</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:02  traffic out </span><br><span class="line">eth0   732.0B/s              948.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:03  traffic out </span><br><span class="line">eth0   132.0B/s              0.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:04  traffic out </span><br><span class="line">eth0   132.0B/s              0.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:05  traffic out </span><br><span class="line">eth0   132.0B/s              0.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:06  traffic out </span><br><span class="line">eth0   186.0B/s              242.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:07  traffic out </span><br><span class="line">eth0   132.0B/s              0.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:08  traffic out </span><br><span class="line">eth0   132.0B/s              0.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:09  traffic out </span><br><span class="line">eth0   132.0B/s              0.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:10  traffic out </span><br><span class="line">eth0   240.0B/s              242.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:11  traffic out </span><br><span class="line">eth0   132.0B/s              0.0B/s</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;在工作中，我们经常需要查看服务器的实时网卡流量。通常，我们会通过这几种方式查看Linux服务器的实时网卡流量。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Centos" scheme="https://annecoding.github.io/tags/Centos/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>一键查看服务器资源利用率</title>
    <link href="https://annecoding.github.io/2019/08/29/%E4%B8%80%E9%94%AE%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%BA%90%E5%88%A9%E7%94%A8%E7%8E%87/"/>
    <id>https://annecoding.github.io/2019/08/29/一键查看服务器资源利用率/</id>
    <published>2019-08-29T09:09:22.000Z</published>
    <updated>2019-08-29T09:18:34.970Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>一般要查服务器资源利用率，我们会先从以下几个方面入手，比如cpu、内存、硬盘、tcp连接情况等。</p><a id="more"></a><p>这里以cpu、内存、硬盘、tcp连接情况来举例，实现如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">$ cat resource_utilization_rate.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 一键查看服务器资源利用率</span></span><br><span class="line"><span class="comment"># 可通过 cpu 内存 硬盘 tcp连接情况 ...等来查看</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">cpu</span></span>()&#123;</span><br><span class="line">        <span class="comment"># NUM=1</span></span><br><span class="line">        <span class="comment"># while [ $NUM -le 3 ];do</span></span><br><span class="line">                <span class="comment"># 相较于top vmstat 可免交互取静态数据，id,空间状态百分比</span></span><br><span class="line">                util=`vmstat |awk <span class="string">'&#123;if(NR==3)print 100-$15"%"&#125;'</span>`</span><br><span class="line">                <span class="comment"># us用户进程消耗cpu时间百分比</span></span><br><span class="line">                user=`vmstat |awk <span class="string">'&#123;if(NR==3)print $13"%"&#125;'</span>`</span><br><span class="line">                <span class="comment"># 系统内核进程消耗cpu时间百分比</span></span><br><span class="line">                sys=`vmstat |awk <span class="string">'&#123;if(NR==3)print $14"%"&#125;'</span>`</span><br><span class="line">                <span class="comment"># cpu资源等待I/O时间百分比</span></span><br><span class="line">                iowait=`vmstat |awk <span class="string">'&#123;if(NR==3)print $16"%"&#125;'</span>`</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"CPU - 使用率：<span class="variable">$util</span> ,等待磁盘IO响应使用率：<span class="variable">$iowait</span>"</span></span><br><span class="line">        <span class="comment">#echo "===========          ****         ================"</span></span><br><span class="line">        <span class="comment">#       let NUM++</span></span><br><span class="line">        <span class="comment">#       sleep 1</span></span><br><span class="line">        <span class="comment">#done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">memory</span></span>()&#123;</span><br><span class="line">        <span class="comment"># ` ` 等同于 $()</span></span><br><span class="line">        total=`free -h |awk <span class="string">'&#123;if(NR==2)print $2&#125;'</span>`</span><br><span class="line">        <span class="comment"># $NF表示取最后一列数据值</span></span><br><span class="line">        used=`free -h |awk <span class="string">'&#123;if(NR==2)print $2-$NF&#125;'</span>`</span><br><span class="line">        available=`free -h |awk <span class="string">'&#123;if(NR==2)print $NF&#125;'</span>`</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"内存 - 总大小：<span class="variable">$&#123;total&#125;</span>G ,已使用：<span class="variable">$&#123;used&#125;</span>G ,可利用：<span class="variable">$&#123;available&#125;</span>G"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">function</span> <span class="function"><span class="title">disk</span></span>()&#123;</span><br><span class="line">     <span class="comment"># 特殊符号/转义,只取第一列</span></span><br><span class="line">     fs=`df -h |awk <span class="string">'/^\/dev/&#123;print $1&#125;'</span>`</span><br><span class="line">     <span class="keyword">for</span> p <span class="keyword">in</span> <span class="variable">$fs</span>;<span class="keyword">do</span></span><br><span class="line">             <span class="comment"># 只有当第一列是磁盘Filesystem，输出最后一列</span></span><br><span class="line">             mounted=`df -h |awk <span class="string">'$1=="'</span><span class="variable">$p</span><span class="string">'"&#123;print $NF&#125;'</span>`</span><br><span class="line">             size=`df -h |awk <span class="string">'$1=="'</span><span class="variable">$p</span><span class="string">'"&#123;print $2&#125;'</span>`</span><br><span class="line">             used=`df -h |awk <span class="string">'$1=="'</span><span class="variable">$p</span><span class="string">'"&#123;print $3&#125;'</span>`</span><br><span class="line">             used_percent=`df -h |awk <span class="string">'$1=="'</span><span class="variable">$p</span><span class="string">'"&#123;print $5&#125;'</span>`</span><br><span class="line">             <span class="built_in">echo</span> <span class="string">"硬盘 - 挂载点：<span class="variable">$&#123;mounted&#125;</span> , 总大小：<span class="variable">$&#123;size&#125;</span> , 使用：<span class="variable">$&#123;used&#125;</span> , 使用率：<span class="variable">$&#123;used_percent&#125;</span>"</span></span><br><span class="line">     <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">tcp_status</span></span>()&#123;</span><br><span class="line"><span class="comment"># printf不换行 “:”以冒号分隔  ss第一列表示连接状态</span></span><br><span class="line">summary=`ss -antp |awk <span class="string">'&#123;status[$1]++&#125;END&#123;for(i in status) printf i ":" status[i]" "&#125;'</span>`</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"TCP - 连接状态：<span class="variable">$summary</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">cpu</span><br><span class="line">memory</span><br><span class="line">disk</span><br><span class="line">tcp_status</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./resource_utilization_rate.sh </span><br><span class="line">CPU - 使用率：0% ,等待磁盘IO响应使用率：0%</span><br><span class="line">内存 - 总大小：1.8GG ,已使用：0.2G ,可利用：1.6GG</span><br><span class="line">硬盘 - 挂载点：/ , 总大小：40G , 使用：1.9G , 使用率：5%</span><br><span class="line">TCP - 连接状态：LISTEN:3 ESTAB:3 State:1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;一般要查服务器资源利用率，我们会先从以下几个方面入手，比如cpu、内存、硬盘、tcp连接情况等。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>批量创建用户并设置随机密码</title>
    <link href="https://annecoding.github.io/2019/08/29/%E6%89%B9%E9%87%8F%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E8%AE%BE%E7%BD%AE%E9%9A%8F%E6%9C%BA%E5%AF%86%E7%A0%81/"/>
    <id>https://annecoding.github.io/2019/08/29/批量创建用户并设置随机密码/</id>
    <published>2019-08-29T09:08:31.000Z</published>
    <updated>2019-09-01T11:42:01.780Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>假如，在linux系统服务器上，要一次创建多个用户并设置密码，你有什么好办法吗？跟我来吧🔅</p><a id="more"></a><h3 id="批量创建用户"><a href="#批量创建用户" class="headerlink" title="批量创建用户"></a>批量创建用户</h3><p>使用shell脚本实现批量创建用户，实现方式如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ cat batch_create_user.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 批量创建用户</span></span><br><span class="line"><span class="comment"># $@接收输入的所有参数</span></span><br><span class="line">USER_LIST=<span class="variable">$@</span></span><br><span class="line"><span class="comment"># 将生成的用户名和密码存在文件里面，这样写默认user.txt存在当前路径下</span></span><br><span class="line">USER_FILE=user.txt</span><br><span class="line"><span class="keyword">for</span> USER <span class="keyword">in</span> <span class="variable">$USER_LIST</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 通过id来判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span> ! id <span class="variable">$USER</span> &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># 生产随机的8位字符串</span></span><br><span class="line">        PASS=$(<span class="built_in">echo</span> <span class="variable">$RANDOM</span> |md5sum |cut -c 1-8)</span><br><span class="line">        <span class="comment"># 创建用户</span></span><br><span class="line">        useradd <span class="variable">$USER</span></span><br><span class="line">        <span class="comment"># 将随机生成的密码分配给用户</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$PASS</span> |passwd --stdin <span class="variable">$USER</span> &amp;&gt;/dev/null</span><br><span class="line">        <span class="comment"># 生成的用户名和密码存入文件中</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$USER</span>   <span class="variable">$PASS</span>"</span> &gt;&gt; <span class="variable">$USER_FILE</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$USER</span> User create successful."</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$USER</span> User already exists!"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>执行结果如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./batch_create_user.sh coco zhangsan</span><br><span class="line">coco User create successful.</span><br><span class="line">zhangsan User create successful.</span><br><span class="line"><span class="comment"># 文件默认存放在当前目录下</span></span><br><span class="line">$ cat user.txt </span><br><span class="line">coco   69b7bc14</span><br><span class="line">zhangsan   fd343a4f</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;假如，在linux系统服务器上，要一次创建多个用户并设置密码，你有什么好办法吗？跟我来吧🔅&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本实现centos系统初始化配置</title>
    <link href="https://annecoding.github.io/2019/08/28/shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0centos%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>https://annecoding.github.io/2019/08/28/shell脚本实现centos系统初始化配置/</id>
    <published>2019-08-28T01:32:11.000Z</published>
    <updated>2019-08-28T04:48:03.309Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>Linux系统配置初始化，顾名思义，在我们有大量机器要做相同工作时，比如都要安装好某些软件，配置环境等，这时候，一个便捷实用的脚本就派上用场啦。</p><a id="more"></a><p><strong>背景：</strong>新购买100台服务器并已安装linux操作系统</p><p><strong>需求：</strong><br>1.设置时区并同步时间<br>2.禁用selinux<br>3.清空防火墙默认策略<br>4.历史命令显示操作时间<br>5.禁止root远程登录，这个要注意，禁止之前确保有普通账户可以sudo到root权限使用，不然切不到root账户<br>6.禁止定时任务发送邮件<br>7.设置最大打开文件数，默认比较少<br>8.减少swap使用，默认物理内存不够会使用swap来交换，速度慢，不建议使用<br>9.系统内核参数优化<br>10.安装系统性能分析工具及一些其他的</p><p><strong>实现脚本如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">$ cat server_initialize.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 设置时区为上海并每小时同步一次时间，默认时区为东八区</span></span><br><span class="line">ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"><span class="comment"># if判断是根据命令执行状态返回值$#?来判断是否执行成功，执行成功则为0，执行失败则为其他，一般为1</span></span><br><span class="line"><span class="keyword">if</span> ! crontab -l | grep ntpdate &amp;&gt;/dev/null; <span class="keyword">then</span> </span><br><span class="line">        <span class="comment"># | crontab通过管道符接收定时任务</span></span><br><span class="line">        (<span class="built_in">echo</span> <span class="string">"* 1 * * * ntpdate time.windows.com &gt;/dev/null 2&gt;&amp;1"</span>;crontab -l) | crontab</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用selinux</span></span><br><span class="line">sed -i <span class="string">'/SELINUX/&#123;s/permissive/disabled/&#125;'</span> /etc/selinux/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line"><span class="keyword">if</span> egrep <span class="string">"7.[0-9]"</span> /etc/redhat-release &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">        systemctl stop firewalld</span><br><span class="line">        systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"><span class="keyword">elif</span> egrep <span class="string">"6.[0-9]"</span> /etc/redhat-release &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">        service iptables stop</span><br><span class="line">        chkconfig iptables off</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 历史命令显示操作时间</span></span><br><span class="line"><span class="comment"># 方便后期审计，谁在什么时间操作</span></span><br><span class="line"><span class="keyword">if</span> ! grep HISTTIMEFORMAT /etc/bashrc &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'export HISTTIMEFORMAT="%F %T `whoami` "'</span> &gt;&gt; /etc/bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SSH超时时间</span></span><br><span class="line"><span class="comment"># 只有TMOUT可以控制ssh连接在空闲时间超时，自动断开连接的时间，数字单位为“秒”</span></span><br><span class="line"><span class="keyword">if</span> ! grep <span class="string">"TMOUT=1500"</span> /etc/profile &amp;&gt;/dev/null; <span class="keyword">then</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"export TMOUT=1500"</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁止root远程登录</span></span><br><span class="line"><span class="comment"># 操作之前授权其他账号或者将自己本机的key保存在系统，或者授权其他账户可以sudo到root账户</span></span><br><span class="line"><span class="comment"># sed -i 's/#PermitRootLogin yes/PermitRootLogin no/' /etc/ssh/sshd_config</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁止定时任务向root发送邮件</span></span><br><span class="line"><span class="comment"># 定时任务的错误等会给当前用户发送邮件，默认是当前用户，会在/var/mail很多小文件占用很大的磁盘空间</span></span><br><span class="line">sed -i <span class="string">'s/^MAILTO=root/MAILTO=""/'</span> /etc/crontab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置最大打开文件数</span></span><br><span class="line"><span class="comment"># 并发较高时，很容易会达到默认，很容易不可用，这里做个优化</span></span><br><span class="line"><span class="comment"># EOF直接将内容追加到文件中，需要在当前行起始位置，不能加空格</span></span><br><span class="line"><span class="keyword">if</span> ! grep <span class="string">"* soft nofile 65535"</span> /etc/security/limits.conf &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">        cat &gt;&gt; /etc/security/limits.conf &lt;&lt; EOF</span><br><span class="line">        * soft nofile 65535</span><br><span class="line">        * hard nofile 65535</span><br><span class="line">EOF</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统内核优化</span></span><br><span class="line"><span class="comment"># 默认数值可通过systcl -a查看</span></span><br><span class="line"><span class="comment"># net.core.netdev_max_backlog 决定了，网络设备接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。</span></span><br><span class="line"><span class="comment"># net.ipv4.tcp_syncookies = 1表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭。</span></span><br><span class="line"><span class="comment"># net.ipv4.tcp_fin_timeout =20表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。</span></span><br><span class="line">cat &gt;&gt; /etc/sysctl.conf &lt;&lt; EOF</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 20480</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 20480</span><br><span class="line">net.core.netdev_max_backlog = 262144</span><br><span class="line">net.ipv4.tcp_fin_timeout = 20</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 减少SWAP使用</span></span><br><span class="line"><span class="comment"># 权重值设置的越大，使用的可能越大。设置为0，尽可能不使用它。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"0"</span> &gt; /proc/sys/vm/swappiness</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装系统性能分析工具及其他</span></span><br><span class="line"><span class="comment"># htop 比top好用的工具</span></span><br><span class="line">yum install gcc make autoconf vim htop sysstat net-tools iostat iftop iotp lrzsz -y</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;Linux系统配置初始化，顾名思义，在我们有大量机器要做相同工作时，比如都要安装好某些软件，配置环境等，这时候，一个便捷实用的脚本就派上用场啦。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Centos使用mailx告警邮件配置</title>
    <link href="https://annecoding.github.io/2019/08/22/Centos%E4%BD%BF%E7%94%A8mailx%E5%91%8A%E8%AD%A6%E9%82%AE%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    <id>https://annecoding.github.io/2019/08/22/Centos使用mailx告警邮件配置/</id>
    <published>2019-08-22T01:09:19.000Z</published>
    <updated>2019-08-24T01:38:04.551Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>今天为大家介绍一个可以直接在 Linux 上使用 SMTP 发送邮件的程序：Mailx，这个程序可以帮助我们让服务器直接支持邮件发送，不用再在每个站点上都设置了。</p><a id="more"></a><p><strong>centos配置自带邮件服务器mailx发件配置</strong></p><h4 id="安装mailx程序"><a href="#安装mailx程序" class="headerlink" title="安装mailx程序"></a>安装mailx程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mailx</span><br></pre></td></tr></table></figure><p>🌟 安装之前，建议移除不再需要且可能会引起冲突的 postfix 或 sendmail 程序。</p><h4 id="修改发件人设置"><a href="#修改发件人设置" class="headerlink" title="修改发件人设置"></a>修改发件人设置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ vim + /etc/mail.rc </span><br><span class="line"><span class="built_in">set</span> nss-config-dir=/root/.certs</span><br><span class="line"><span class="built_in">set</span> smtp=<span class="string">"smtps://smtp.163.com:465"</span></span><br><span class="line"><span class="comment"># set smtp=smtp.163.com  默认25端口不放开</span></span><br><span class="line"><span class="built_in">set</span> from=<span class="string">"annecoding@163.com"</span></span><br><span class="line"><span class="built_in">set</span> smtp-auth=login</span><br><span class="line"><span class="built_in">set</span> smtp-auth-user=<span class="string">"annecoding@163.com"</span></span><br><span class="line"><span class="comment"># 不是密码，不是密码！！！获取网易163设置的客户端授权密码。</span></span><br><span class="line"><span class="built_in">set</span> smtp-auth-password=<span class="string">"xxxxxx"</span></span><br><span class="line"><span class="built_in">set</span> ssl-verify=ignore</span><br></pre></td></tr></table></figure><p>💡 一般邮件服务器会提供 smtp、smtps 和 smtp starttls 服务来发送邮件。smtp 最简单的，也最不安全的，不建议使用，最好使用 smtps 或者 smtp starttls 来发送邮件。</p><h4 id="测试发送"><a href="#测试发送" class="headerlink" title="测试发送"></a>测试发送</h4><p>可以发送出邮件，但是会报错，如下面这种情况。需要生成证书来解决此问题。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"TEST"</span> | mail -s <span class="string">"Title"</span> <span class="string">"annecoding@163.com"</span></span><br><span class="line">$ Error <span class="keyword">in</span> certificate: Peer<span class="string">'s certificate issuer is not recognized.</span></span><br></pre></td></tr></table></figure></p><h4 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h4><p>在本地新建目录生成证书<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /root/.certs/</span><br><span class="line">$ <span class="built_in">echo</span> -n | openssl s_client -connect smtp.163.com:465 | sed -ne <span class="string">'/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p'</span> &gt; ~/.certs/163.crt</span><br><span class="line">$ certutil -A -n <span class="string">"GeoTrust SSL CA"</span> -t <span class="string">"C,,"</span> -d ~/.certs -i ~/.certs/163.crt</span><br><span class="line">$ certutil -A -n <span class="string">"GeoTrust Global CA"</span> -t <span class="string">"C,,"</span> -d ~/.certs -i ~/.certs/163.crt</span><br><span class="line">$ certutil -L -d /root/.certs</span><br><span class="line"><span class="comment"># 信任证书</span></span><br><span class="line">$ <span class="built_in">cd</span> .certs</span><br><span class="line">$ certutil -A -n <span class="string">"GeoTrust SSL CA - G3"</span> -t <span class="string">"Pu,Pu,Pu"</span>  -d ./ -i 163.crt</span><br></pre></td></tr></table></figure></p><p>💡 参考上面的设置（如果要用qq邮箱，可以把所有的生成证书的163改为qq），同样可以使用 126，163 等邮箱在服务器上通过 SMTP 发送邮件。设置成功以后，服务器上的所有站点，或者其他程序、其他语言开发的站点，都可以直接发送邮件了，是不是很方便？</p><h4 id="再次修改mail-rc"><a href="#再次修改mail-rc" class="headerlink" title="再次修改mail.rc"></a>再次修改mail.rc</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/mail.rc</span><br><span class="line">$ <span class="built_in">set</span> nss-config-dir=/root/.certs/</span><br></pre></td></tr></table></figure><h4 id="测试发送-1"><a href="#测试发送-1" class="headerlink" title="测试发送"></a>测试发送</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mail -s发送邮件 -v可以显示发件的详细信息</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"邮件正文"</span> | mail -s <span class="string">"标题"</span> <span class="string">"annecoding@163.com"</span> </span><br><span class="line">$ mail -s <span class="string">"xxxx"</span> annecoding@163.com &lt; /root/cpu.sh</span><br></pre></td></tr></table></figure><blockquote><p>参考链接：</p><p><a href="https://www.wpzhiku.com/shi-yong-mailx-tong-guo-smtp-zai-centos-shang-fa-song-you-jian/" target="_blank" rel="noopener">使用 Mailx 通过 SMTP 在 Centos 上发送邮件，解决 WordPress 发送邮件问题</a></p><p> <a href="https://www.cnblogs.com/hqqq/p/6261419.html" target="_blank" rel="noopener">mialx配置qq邮箱发送邮件</a></p><p> <a href="https://help.mail.163.com/faqDetail.do?code=d7a5dc8471cd0c0e8b4b8f4f8e49998b374173cfe9171305fa1ce630d7f67ac2cda80145a1742516" target="_blank" rel="noopener">如何开启客户端授权码？</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;今天为大家介绍一个可以直接在 Linux 上使用 SMTP 发送邮件的程序：Mailx，这个程序可以帮助我们让服务器直接支持邮件发送，不用再在每个站点上都设置了。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Centos" scheme="https://annecoding.github.io/tags/Centos/"/>
    
      <category term="mailx" scheme="https://annecoding.github.io/tags/mailx/"/>
    
  </entry>
  
  <entry>
    <title>shell中切分文件名和扩展名</title>
    <link href="https://annecoding.github.io/2019/08/13/shell%E4%B8%AD%E5%88%87%E5%88%86%E6%96%87%E4%BB%B6%E5%90%8D%E5%92%8C%E6%89%A9%E5%B1%95%E5%90%8D/"/>
    <id>https://annecoding.github.io/2019/08/13/shell中切分文件名和扩展名/</id>
    <published>2019-08-13T08:22:49.000Z</published>
    <updated>2019-08-13T08:50:59.385Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>对于shell涉及的修改文件名的操作，我们可能需要提取某个文件名，或者提取某个文件的扩展名。get✔</p><a id="more"></a><h3 id="根据扩展名切分文件名"><a href="#根据扩展名切分文件名" class="headerlink" title="根据扩展名切分文件名"></a>根据扩展名切分文件名</h3><p>截取文件名称示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat file.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">file_jpg=<span class="string">"sample.jpg"</span></span><br><span class="line">name=<span class="variable">$&#123;file_jpg%.*&#125;</span></span><br><span class="line"><span class="built_in">echo</span> File name is:<span class="variable">$name</span></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./file.sh </span><br><span class="line">File name is:sample</span><br></pre></td></tr></table></figure><p>截取文件扩展名示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat file1.sh</span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">file_jpg=<span class="string">"sample.jpg"</span></span><br><span class="line">extension=<span class="variable">$&#123;file_jpg#*.&#125;</span></span><br><span class="line"><span class="built_in">echo</span> Extension is:<span class="variable">$extension</span></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./file1.sh</span><br><span class="line">Extension is:jpg</span><br></pre></td></tr></table></figure><p><code>${VAR%.*}</code>工作原理：</p><ul><li>从<code>$VAR</code>中删除位于<code>%</code>右侧的通配符（在上例中式<code>.*</code>），通配符从右向左进行匹配。</li><li>给<code>VAR</code>赋值，即<code>VAR=sample.jpg</code>，通配符从右向左匹配得到的内容是<code>.jpg</code>，因此从<code>$VAR</code>中删除匹配结果，得到输出结果sample。</li></ul><p>💡 那么，有没有考虑过，要是文件名有很多后缀呢<code>cute.a.b.c.d.txt</code>？要是提取的变量为域名<code>www.google.com</code>呢？有的是办法，往下看~</p><p><strong>%属于非贪婪匹配，它从右向左找出匹配通配符的最短结果。还有另一个操作符%%，它于%相似，但行为模式确是贪婪的，它会匹配符合通配符的最长结果。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明变量var</span></span><br><span class="line">$ var=hack.fun.book.txt</span><br><span class="line"><span class="comment"># 执行从右向左非贪婪匹配，得到的匹配结果为.txt,删除了.txt之后文件名，可以得到具体的文件名</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var%.*&#125;</span></span><br><span class="line">hack.fun.book</span><br><span class="line"><span class="comment"># 执行从右向左贪婪匹配，得到结果.fun.book.txt,删除了.fun.book.txt</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var%%.*&#125;</span></span><br><span class="line">hack</span><br></pre></td></tr></table></figure><p><code>${VAR#*.}</code>工作原理：</p><ul><li>从<code>$VAR</code>中删除位于<code>#</code>右侧的通配符（上个栗子中使用的<code>*.</code>），从左到右匹配字符串。</li><li>和<code>#</code>对应的贪婪操作是<code>##</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从右到左进行非贪婪匹配，得到匹配结果hack，从指定变量中删除匹配结果</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var#*.&#125;</span></span><br><span class="line">fun.book.txt</span><br><span class="line"><span class="comment"># 从右到左进行非贪婪匹配，得到匹配结果hack.fun.book，删除匹配结果后得到扩展名</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var##*.&#125;</span></span><br><span class="line">txt</span><br></pre></td></tr></table></figure><p>💡总结</p><p><strong>文件名中可能包含多个.字符，所以呢</strong></p><p><strong>对于文件名：相较于%%，%更适合于提取文件名。%执行的是非贪婪匹配，只会删除扩展名。</strong></p><p><strong>对于扩展名：相较于#，##更适合于从中提取扩展名。##执行的是贪婪匹配，因此能准确的提取扩展名。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;对于shell涉及的修改文件名的操作，我们可能需要提取某个文件名，或者提取某个文件的扩展名。get✔&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>监控多台服务器利用率</title>
    <link href="https://annecoding.github.io/2019/07/25/%E7%9B%91%E6%8E%A7%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%A9%E7%94%A8%E7%8E%87/"/>
    <id>https://annecoding.github.io/2019/07/25/监控多台服务器利用率/</id>
    <published>2019-07-25T02:12:15.000Z</published>
    <updated>2019-09-01T04:57:52.968Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>通常，我们可以在linux主机ssh通过密码<strong>交互登录</strong>到远程其他主机。但是，我们在脚本里面不想用交互呢？当然了，ssh给我们提供了一个强大的工具。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">环境：192.168.1.2（监控主机） 192.168.1.3（被监控主机） 192.168.1.4（被监控主机）</span><br></pre></td></tr></table></figure><p>现在要做的是在ssh主机之间免密钥登录，这样才能方便我们下一步使用脚本在直接在本机连接远程主机执行命令。其实就是在监控主机上面生成公钥，然后放到被监控主机上，类似于我们登录github把自己本机的公钥放在github服务器上面一样，这样我们ssh连接的时候就不用总输入密码了。</p><h3 id="免密钥登录"><a href="#免密钥登录" class="headerlink" title="免密钥登录"></a>免密钥登录</h3><p>1.产生公钥对<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在本地机器上使用ssh-keygen产生公钥私钥对</span></span><br><span class="line"><span class="comment"># 在/root根目录下，一直默认，默认存在当前目录下.ssh里面（ll -a）</span></span><br><span class="line">$ ssh-keygen</span><br></pre></td></tr></table></figure></p><p>2.将本机公钥复制到远程要免密登录的机器中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用ssh-copy-id将公钥id_rsa.pub复制到远程机器中，第一次需要输入密码</span></span><br><span class="line"><span class="comment"># 默认将192.168.1.2的公钥存放在/root根目录下的.ssh里面authorized_keys</span></span><br><span class="line">$ ssh root@192.168.1.3</span><br><span class="line">$ ssh root@192.168.1.4</span><br></pre></td></tr></table></figure></p><p>3.免密连接远程主机执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh root@192.168.1.3</span><br><span class="line">$ ssh root@192.168.1.4 <span class="string">'df -h'</span></span><br></pre></td></tr></table></figure></p><h3 id="监控服务器利用率"><a href="#监控服务器利用率" class="headerlink" title="监控服务器利用率"></a>监控服务器利用率</h3><p>好了，现在基础环境已经做好了，磁盘使用情况可以用<code>df -h</code>来查询，脚本实现如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ cat disk_availabile.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 监控多台服务器利用率</span></span><br><span class="line"><span class="comment"># 将需要监控的服务器信息存储在host.info中，IP地址 用户 端口号</span></span><br><span class="line">HOST_INFO=host.info</span><br><span class="line"><span class="comment"># 逐行匹配，不匹配注释（以#开头）</span></span><br><span class="line"><span class="keyword">for</span> IP <span class="keyword">in</span> $(awk <span class="string">'/^[^#]/&#123;print $1&#125;'</span> <span class="variable">$HOST_INFO</span>);<span class="keyword">do</span></span><br><span class="line"> <span class="comment"># awk -v 在shell中使用变量，以ip为基准匹配，匹配到了取出用户</span></span><br><span class="line">        USER=`awk -v ip=<span class="variable">$IP</span> <span class="string">'ip==$1&#123;print $2&#125;'</span> <span class="variable">$HOST_INFO</span>`</span><br><span class="line">        PORT=`awk -v ip=<span class="variable">$IP</span> <span class="string">'ip==$1&#123;print $3&#125;'</span> <span class="variable">$HOST_INFO</span>`</span><br><span class="line">        TMP_FILE=/tmp/disk.tmp</span><br><span class="line">        <span class="comment"># 将连接到远程主机的信息暂时存入文件中</span></span><br><span class="line">        ssh -p <span class="variable">$PORT</span> <span class="variable">$USER</span>@<span class="variable">$IP</span> <span class="string">'df -h'</span> &gt; <span class="variable">$TMP_FILE</span></span><br><span class="line">        <span class="comment"># 取出挂载点并添加分隔符=  </span></span><br><span class="line">        <span class="comment"># int($5) 去除百分比以方便后面做判断 /=5</span></span><br><span class="line">        USE_PART_LIST=`awk <span class="string">'BEGIN&#123;OFS="="&#125;/^\/dev/&#123;print $NF,int($5)&#125;'</span> <span class="variable">$TMP_FILE</span>`</span><br><span class="line">        <span class="comment"># 取挂载点和利用率</span></span><br><span class="line">        <span class="keyword">for</span> USE_RATE <span class="keyword">in</span> <span class="variable">$USE_PART_LIST</span>;<span class="keyword">do</span></span><br><span class="line">                <span class="comment"># 挂载点 匹配到=右边的 /</span></span><br><span class="line">                PART_NAME=<span class="variable">$&#123;USE_RATE%=*&#125;</span></span><br><span class="line">                <span class="comment"># 使用率 匹配到=左边的 5</span></span><br><span class="line">                USE_RATE=<span class="variable">$&#123;USE_RATE#*=&#125;</span></span><br><span class="line">                <span class="keyword">if</span> [ <span class="variable">$USE_RATE</span> -ge 80 ]; <span class="keyword">then</span></span><br><span class="line">                        <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$IP</span> \n Warning: <span class="variable">$PART_NAME</span> Partition usage <span class="variable">$USE_RATE</span>%!"</span></span><br><span class="line">                <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat host.info </span><br><span class="line">192.168.1.3 root 22</span><br><span class="line">$ ./disk_availabile.sh</span><br><span class="line">192.168.1.3 </span><br><span class="line"> Warning: / Partition usage 86%!</span><br><span class="line">192.168.1.3 </span><br><span class="line"> Warning: /dev/sda2 Partition usage 88%!</span><br><span class="line">192.168.1.4</span><br><span class="line"> Warning: / Partition usage 89%!</span><br><span class="line">192.168.1.4 </span><br><span class="line"> Warning: /dev/vda1 Partition usage 92%!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;通常，我们可以在linux主机ssh通过密码&lt;strong&gt;交互登录&lt;/strong&gt;到远程其他主机。但是，我们在脚本里面不想用交互呢？当然了，ssh给我们提供了一个强大的工具。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Centos" scheme="https://annecoding.github.io/tags/Centos/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>mtr网络分析工具安装</title>
    <link href="https://annecoding.github.io/2019/07/24/mtr%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/"/>
    <id>https://annecoding.github.io/2019/07/24/mtr网络分析工具安装/</id>
    <published>2019-07-24T08:00:54.000Z</published>
    <updated>2019-08-03T01:19:07.801Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>遇到了安装完成mtr以后命令不能使用的情况，因为环境变量的配置问题！！！</p><a id="more"></a><p>mtr网络分析工具安装</p><p>1.首先保证安装brew工具</p><p>2.执行<code>brew cask mtr</code>进行软件安装</p><p>3.配置PATH变量 <code>vim ~/.bash_profile</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/sbin</span><br></pre></td></tr></table></figure><p>4.配置文件生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><p>5.安装完以后在<code>usr/local/sbin</code>目录下，第一次执行可以执行，再打开窗口就不行，环境变量只生效了一次。</p><p>再次打开新的窗口就发现不能使用了，输入<code>mtr</code>命令发现不能运行，提示如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtr: mtr should not run suid</span><br></pre></td></tr></table></figure><p>再次查看环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 内容如下</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin:/usr/bin:/bin:/usr/sbin:/sbin</span><br></pre></td></tr></table></figure><p>果然，没有<code>usr/local/sbin</code></p><p>6.此时有两种解决方案： </p><p>第一种解决方案，建立软链接，将所安装的mtr指令软链接到系统找得到的目录下，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/sbin/mtr* /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure><p>第二种解决方案，修改/etc/paths的path文件，添加。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/paths </span><br><span class="line">在最后一行添加：/usr/<span class="built_in">local</span>/sbin，此修改重新启动程序便会生效。</span><br></pre></td></tr></table></figure><p>7.使用mtr命令必须是root权限，当然也可以修改目录权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mtr www.baidu.com</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;遇到了安装完成mtr以后命令不能使用的情况，因为环境变量的配置问题！！！&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="mtr" scheme="https://annecoding.github.io/tags/mtr/"/>
    
  </entry>
  
  <entry>
    <title>mac下如何修改环境变量</title>
    <link href="https://annecoding.github.io/2019/07/24/mac%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>https://annecoding.github.io/2019/07/24/mac下如何修改环境变量/</id>
    <published>2019-07-24T08:00:33.000Z</published>
    <updated>2019-07-28T01:39:28.265Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>mac下环境变量到底该修改哪个文件呢？？？黑人问号脸，所以，一起来揭穿它神秘的面纱吧。<br><a id="more"></a></p><p>mac下一般使用bash作为默认shell</p><p>mac系统的环境变量，加载顺序为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc</span><br></pre></td></tr></table></figure><p>当然<code>/etc/profile</code>和<code>/etc/paths</code>是系统级别的，系统启动就会加载，后面几个是当前用户级的环境变量。</p><p>后面3个按照从前往后的顺序读取，如果<code>/.bash_profile</code>文件存在，则后面的几个文件就会被忽略不读了，如果<code>~/.bash_profile</code>文件不存在，才会以此类推读取后面的文件。</p><p><code>~/.bashrc</code>没有上述规则，它是<code>bash shell</code>打开的时候载入的。</p><p>如果没特殊说明,设置PATH的语法都为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#中间用冒号隔开 </span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:------:&lt;PATH N&gt;</span><br></pre></td></tr></table></figure><h3 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h3><p>下面的几个文件设置是全局的,修改时需要root权限</p><p>1、<code>/etc/paths</code> （全局建议修改这个文件 ）</p><p>编辑 <code>/etc/paths</code>，将环境变量添加到<code>/etc/paths</code>文件中 ，一行一个路径</p><p>Hint：输入环境变量时，不用一个一个地输入，只要拖动文件夹到 Terminal 里就可以了。</p><p>2、<code>/etc/profile</code>（建议不修改这个文件 ）全局（公有）配置，不管是哪个用户，登录时都会读取该文件。</p><p>3、<code>/etc/bashrc</code>（一般在这个文件中添加系统级环境变量）全局（公有）配置，bash shell执行时，不管是何种方式，都会读取此文件。</p><p>4、这条是什么鬼，先放着hhh~~~~👻</p><p>1.创建一个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo touch /etc/paths.d/mysql</span><br></pre></td></tr></table></figure><p>2.用 vim 打开这个文件（如果是以 open -t 的方式打开，则不允许编辑）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/paths.d/mysql</span><br></pre></td></tr></table></figure><p>3.编辑该文件，键入路径并保存（关闭该 Terminal 窗口并重新打开一个，就能使用 mysql 命令了）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/mysql/bin</span><br></pre></td></tr></table></figure><p>据说，这样可以自己生成新的文件，不用把变量全都放到 paths 一个文件里，方便管理。</p><h3 id="单个用户设置"><a href="#单个用户设置" class="headerlink" title="单个用户设置"></a>单个用户设置</h3><p>1、<code>~/.bash_profile</code> （任意一个文件中添加用户级环境变量）</p><p>（注：Linux 里面是<code>.bashrc</code> 而 Mac 是 <code>.bash_profile</code>）</p><p>若<code>bash shell</code>是以login方式执行时，才会读取此文件。该文件仅仅执行一次!默认情况下,他设置一些环境变量</p><p>设置命令别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> ll=’ls -la’</span><br></pre></td></tr></table></figure><p>设置环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/opt/<span class="built_in">local</span>/bin:/opt/<span class="built_in">local</span>/sbin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>2、<code>~/.bashrc</code>同上</p><p>如果想立刻生效，则可执行下面的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source 相应的文件</span><br></pre></td></tr></table></figure><p>一般环境变量更改后，重启程序后生效。</p><blockquote><p>参考：</p><p><a href="https://segmentfault.com/q/1010000008484965/a-1020000008485621" target="_blank" rel="noopener">MAC OS中修改环境变量到底应该修改哪个文件</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;mac下环境变量到底该修改哪个文件呢？？？黑人问号脸，所以，一起来揭穿它神秘的面纱吧。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mac" scheme="https://annecoding.github.io/categories/Mac/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Mac" scheme="https://annecoding.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>linux安装hping添加环境变量</title>
    <link href="https://annecoding.github.io/2019/07/20/linux%E5%AE%89%E8%A3%85hping%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>https://annecoding.github.io/2019/07/20/linux安装hping添加环境变量/</id>
    <published>2019-07-20T11:06:59.000Z</published>
    <updated>2019-07-24T09:03:16.493Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>当我试图去安装hping的时候，出现了一些些问题，明明已经安装，但是却不能使用，后来发现是环境变量没有配置上。<br><a id="more"></a></p><p>在mac下通过brew安装hping<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install hping</span><br></pre></td></tr></table></figure></p><p>查看已安装列表…找到如下一列<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew list</span><br><span class="line">.... ... .... hping ... .... ...</span><br></pre></td></tr></table></figure></p><p>然而,当我运行hping时…<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hping</span><br><span class="line">zsh: <span class="built_in">command</span> not found: hping</span><br></pre></td></tr></table></figure></p><p>再次查看安装信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ brew info hping</span><br><span class="line">hping: stable 3.20051105</span><br><span class="line">http://www.hping.org/</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/hping/3.20051105 (9 files, 196K) *</span><br><span class="line">  Built from <span class="built_in">source</span></span><br><span class="line">From: https://github.com/Homebrew/homebrew/blob/master/Library/Formula/hping.rb</span><br></pre></td></tr></table></figure></p><p>emmm…得出结论，安装了hping却不能使用<br>将<code>/usr/local/sbin</code>添加到<code>$PATH</code>,<br>因为hping二进制文件安装在<code>/usr/local/sbin</code>中,而不是安装在<code>/usr/local/bin</code>中。</p><p><strong>解决方案</strong></p><p>在终端中输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/sbin</span><br></pre></td></tr></table></figure></p><p>哦对了 等号之间不能有空格</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;当我试图去安装hping的时候，出现了一些些问题，明明已经安装，但是却不能使用，后来发现是环境变量没有配置上。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mac" scheme="https://annecoding.github.io/categories/Mac/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="hping" scheme="https://annecoding.github.io/tags/hping/"/>
    
      <category term="Mac" scheme="https://annecoding.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu修改IP地址</title>
    <link href="https://annecoding.github.io/2019/07/20/ubuntu%E4%BF%AE%E6%94%B9IP%E5%9C%B0%E5%9D%80/"/>
    <id>https://annecoding.github.io/2019/07/20/ubuntu修改IP地址/</id>
    <published>2019-07-20T10:59:03.000Z</published>
    <updated>2019-07-28T01:42:55.801Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>ubuntu修改静态ip地址需要单独设置DNS，这个要注意一下哦。<br><a id="more"></a></p><h3 id="ubuntu修改ip地址"><a href="#ubuntu修改ip地址" class="headerlink" title="ubuntu修改ip地址"></a>ubuntu修改ip地址</h3><h4 id="ubuntu16-04修改IP地址"><a href="#ubuntu16-04修改IP地址" class="headerlink" title="ubuntu16.04修改IP地址"></a>ubuntu16.04修改IP地址</h4><p>1、修改网卡配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sudo  vi /etc/network/interfaces</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到其中以下几行进行修改</span></span><br><span class="line">auto ens123</span><br><span class="line">iface ens123 inet static</span><br><span class="line">        address 10.10.133.233</span><br><span class="line">        netmask 255.255.255.0</span><br><span class="line">        network 10.10.133.0</span><br><span class="line">        broadcast 10.10.133.255</span><br><span class="line">        gateway 10.10.133.254</span><br><span class="line">        <span class="comment"># dns-* options are implemented by the resolvconf package, if installed</span></span><br><span class="line">        dns-nameservers 8.8.8.8</span><br></pre></td></tr></table></figure><p>2、修改DNS配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi + /etc/resolvconf/resolv.conf.d/head</span><br><span class="line"><span class="comment"># 在文件最后添加一句话</span></span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>3、重启网卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo /etc/init.d/networking restart</span><br></pre></td></tr></table></figure><h4 id="ubuntu18-04修改ip地址"><a href="#ubuntu18-04修改ip地址" class="headerlink" title="ubuntu18.04修改ip地址"></a>ubuntu18.04修改ip地址</h4><p>1、修改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/netplan/50-cloud-init.yaml</span><br><span class="line"><span class="comment"># 修改以下内容</span></span><br><span class="line">network:</span><br><span class="line">    ethernets:</span><br><span class="line">        eth0:</span><br><span class="line">            addresses:</span><br><span class="line">            - 192.168.15.72/20</span><br><span class="line">            gateway4: 192.168.12.2</span><br><span class="line">            nameservers:</span><br><span class="line">                addresses:</span><br><span class="line">                - 223.5.5.5</span><br><span class="line">                search: []</span><br><span class="line">            optional: <span class="literal">true</span></span><br><span class="line">    version: 2</span><br></pre></td></tr></table></figure><p>2、使配置生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netplan apply</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;ubuntu修改静态ip地址需要单独设置DNS，这个要注意一下哦。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://annecoding.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>linux系统扫描命令和安全防范笔记</title>
    <link href="https://annecoding.github.io/2019/07/20/linux%E7%B3%BB%E7%BB%9F%E6%89%AB%E6%8F%8F%E5%91%BD%E4%BB%A4%E5%92%8C%E5%AE%89%E5%85%A8%E9%98%B2%E8%8C%83%E7%AC%94%E8%AE%B0/"/>
    <id>https://annecoding.github.io/2019/07/20/linux系统扫描命令和安全防范笔记/</id>
    <published>2019-07-20T09:21:31.000Z</published>
    <updated>2019-07-28T01:40:42.649Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>本文主要介绍了一些常用的网络扫描工具以及安全防范，了解更多命令的使用。<br><a id="more"></a></p><h3 id="linux系统扫描命令和安全防范笔记"><a href="#linux系统扫描命令和安全防范笔记" class="headerlink" title="linux系统扫描命令和安全防范笔记"></a><strong>linux系统扫描命令和安全防范笔记</strong></h3><p>通过网络入侵来窃取敏感信息</p><p>通过网络扫描获取运营商核心设备的管理权限</p><h3 id="网络入侵方式"><a href="#网络入侵方式" class="headerlink" title="网络入侵方式"></a><strong>网络入侵方式</strong></h3><p>踩点-网络扫描-差点-提权</p><p><strong>常用命令</strong></p><p>tracert/traceroute、namp、nc</p><h3 id="主机扫描命令fping"><a href="#主机扫描命令fping" class="headerlink" title="主机扫描命令fping"></a><strong>主机扫描命令fping</strong></h3><p>批量的给目标主机发送ping请求，测试主机的存活情况。</p><p>特点：并行发送，结果易读</p><p><strong>源码包编译过程</strong></p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g54yozizhcj30yg0lign8.jpg" alt="image-20190719105646797"></p><p>fping编译安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># wget https://fping.org/dist/fping-4.2.tar.gz</span></span><br><span class="line">[root@localhost ~]<span class="comment"># tar -xvf fping-4.2.tar.gz </span></span><br><span class="line">[root@localhost fping-4.2]<span class="comment"># ./configure &amp; make &amp; make install</span></span><br><span class="line">[root@localhost fping-4.2]<span class="comment"># fping -h  #查看帮助命令</span></span><br><span class="line">[root@localhost fping-4.2]<span class="comment"># fping -v</span></span><br><span class="line">fping: Version 4.2</span><br><span class="line">fping: comments to david@schweikert.ch</span><br></pre></td></tr></table></figure><h4 id="fping参数介绍"><a href="#fping参数介绍" class="headerlink" title="fping参数介绍"></a><strong>fping参数介绍</strong></h4><p>命令参数man、-h方式</p><p>常用参数：</p><p>-a 只显示出存活的主机(相反参数-u)</p><p>-l 循环ping</p><p>1、通过标准输入方式fping+IP1+IP2</p><p>-g 支持主机段的方式 192.168.1.1 192.168.1.255 192.168.1.0/24</p><p>2、通过读取一个文件中的IP内容</p><p>方式：fping -f filename</p><p>3、fping使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找存货的主机</span></span><br><span class="line">fping -a 10.10.163.233</span><br><span class="line"><span class="comment"># 可以查找某个网段内存活的主机</span></span><br><span class="line">fping  -g -a 10.10.163.1 10.10.163.254</span><br><span class="line"><span class="comment"># 查找某个网段内存活主机第二种写法</span></span><br><span class="line">fping -a -g 10.10.163.233/24</span><br></pre></td></tr></table></figure><h3 id="主机扫描命令hping"><a href="#主机扫描命令hping" class="headerlink" title="主机扫描命令hping"></a><strong>主机扫描命令hping</strong></h3><p>支持使用tcp/ip数据包组装、分析工具</p><p>linux下编译安装</p><p>如果遇到如下错误</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g556megt3vj30oi04et9c.jpg" alt="image-20190719153110732"></p><p>可通过安装下面库解决</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g556sceynmj30ji09274q.jpg" alt="image-20190719153652881"></p><p><a href="http://rpmfind.net/" target="_blank" rel="noopener">http://rpmfind.net/</a></p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g556pk21f9j30xy082do7.jpg" alt="image-20190719153414670"></p><h4 id="hping常用参数"><a href="#hping常用参数" class="headerlink" title="hping常用参数"></a><strong>hping常用参数</strong></h4><p>1、对特定的目标发起tcp探测（规避运营商防火墙、主机等对icmp包屏蔽）</p><p>-p 端口tcp</p><p>-S 设置TCP模式SYN包</p><p>2、伪造来源IP，模拟Ddos攻击</p><p>-a 伪造IP地址</p><p>3、hping使用 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo hping -p 22 -S 10.10.163.233</span><br><span class="line"></span><br><span class="line">sudo hping -p 22 -S 10.10.163.233 -a 10.10.163.235</span><br></pre></td></tr></table></figure><p> centos拒绝掉icmp包设置</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g56489gypsj30kg01mwei.jpg" alt="image-20190720105353473"></p><h3 id="路由扫描"><a href="#路由扫描" class="headerlink" title="路由扫描"></a><strong>路由扫描</strong></h3><p>作用：查询一个主机经过的路由的跳数、及数据延迟情况</p><p>常用工具：traceroute、mtr</p><p>mtr特点：能测出主机到每一个路由间的联通性。</p><p>traceroute连接原理。</p><p>linux下发送udp包（&gt;30000端口），windows发送icmp包。</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g564xl90vhj30pk0i23zb.jpg" alt="image-20190720111813791"></p><p>TTL，生存时间的值。发给第一跳，ttl-1=0，返回udp数据包。</p><p>扫描到几个路由器，发送几个ttl数据包。</p><h4 id="traceroute参数的使用"><a href="#traceroute参数的使用" class="headerlink" title="traceroute参数的使用"></a><strong>traceroute参数的使用</strong></h4><p> linux一般默认有，如果没有安装方式</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5657hwwdpj30mi03gjru.jpg" alt="image-20190720112746947"></p><p>1、默认使用的是udp协议(30000以上的端口)</p><p>2、支持使用TCP协议 -T(发送tcp协议) -p(基于tcp什么端口)</p><p>3、使用ICMP协议介绍 -I </p><p>4、traceroute使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">traceroute www.baidu.com</span><br><span class="line"><span class="comment"># -n 去掉解析</span></span><br><span class="line">traceroute -n www.baidu.com </span><br><span class="line"><span class="comment"># 使用icmp，window默认使用</span></span><br><span class="line">traceroute -In  www.imooc.com</span><br><span class="line"><span class="comment"># 使用tcp才能检测到最终跳数(一般会屏蔽icmp协议)</span></span><br><span class="line">traceroute -T -p 80 -n www.imooc.com</span><br></pre></td></tr></table></figure><h4 id="mtr使用"><a href="#mtr使用" class="headerlink" title="mtr使用"></a>mtr使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum install mtr -y</span><br><span class="line"><span class="comment"># 使用，原理和traceroute一样，可以看到到哪一跳丢包率更为严重</span></span><br><span class="line">mtr www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="批量主机扫描"><a href="#批量主机扫描" class="headerlink" title="批量主机扫描"></a><strong>批量主机扫描</strong></h3><p>目的：</p><p>1、批量主机存活扫描</p><p>2、针对主机服务扫描</p><p>作用：</p><p>1、能快捷的获取主机的存活状态</p><p>2、能更加细致、只能获取主机服务侦查情况</p><p><strong>典型命令</strong></p><p>1、nmap 基于端口扫描，特别强大</p><p>2、ncat 瑞士军刀</p><h4 id="nmap使用"><a href="#nmap使用" class="headerlink" title="nmap使用"></a><strong>nmap使用</strong></h4><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g56dmqgtktj30v60f8dhb.jpg" alt="image-20190720161913675"></p><p>tcp半开放，不建立完整的tcp，未建立完整的三次握手。</p><p>1、主机存活扫描</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 扫描主机存活状态,s检测用什么协议做侦测</span></span><br><span class="line">namp -sP 10.10.140.0/24</span><br></pre></td></tr></table></figure><p>2、主机端口开放扫描，默认扫描范围1-1024，以及一些常用的服务端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namp -sS 10.10.10.163.233</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g56dzj5o2kj30mq0ae400.jpg" alt="image-20190720163117782"></p><p>3、半开放指定端口扫描</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namp -sS -p 0-30000 10.10.163.233</span><br></pre></td></tr></table></figure><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g56e6peru2j30nw0a0t9w.jpg" alt="image-20190720163823202"></p><p>4、全开放连接参数，建立一次全握手，时间长</p><p>建立全握手，可以模拟用户的真实操作请求，需要服务端能检测到相关的日志，打印出相关记录信息。</p><p>建议日常使用半扫描模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sT -p 0-30000 10.10.163.233</span><br></pre></td></tr></table></figure><p> 5、udp协议扫描方式</p><p>扫描udp，响应比较慢、可能特别慢。会限制icmp不可达返回的次数。不建议使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sU 10.10.163.233</span><br></pre></td></tr></table></figure><h4 id="ncat使用"><a href="#ncat使用" class="headerlink" title="ncat使用"></a><strong>ncat使用</strong></h4><p>查看某个路由开放哪些端口80 23</p><p>通过shell交互更改数据 ，可进行任意操作</p><p>nc -lvp 2005 监听端口</p><p><strong>nc好处</strong></p><p>1、不会频繁通过界面登录留下痕迹</p><p>2、登录非常方便</p><p>3、不会被侦测设备侦测到</p><p>-w 设置的超市时间</p><p>-z 一个输入输出模式</p><p>-v 显示命令执行过程</p><p>1、基于tcp协议(默认)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看22端口开放情况</span></span><br><span class="line">nc -zv 10.10.163.233 22</span><br><span class="line"><span class="comment"># 查看一些端口开放 超时2s</span></span><br><span class="line">nc -zv -w2 10.10.163.233 1-50</span><br></pre></td></tr></table></figure><p>2、基于udp协议 -u  </p><p>回应时间长，不建议使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看一些端口开放 超时2s</span></span><br><span class="line">nc -zv -u -w2 10.10.163.233 1-50</span><br></pre></td></tr></table></figure><h3 id="预防策略"><a href="#预防策略" class="headerlink" title="预防策略"></a><strong>预防策略</strong></h3><p>在linux进行防御。</p><p>常见攻击方法：</p><p>1、SYN攻击</p><p>2、DDoS攻击</p><p>3、恶意扫描</p><p>什么是SYN攻击？</p><p>利用TCP协议缺陷进行，导致系统服务停止响应，网络带宽跑满或者响应缓慢。</p><p>什么是DDoS攻击？</p><p>分布式拒绝访问服务攻击。</p><p>正常服务在同一时间接到了很多个类似于正常服务的请求，也有可能是完全正常的请求，导致服务响应不过来。</p><p>SYN攻击一般会伴随着DDoS攻击进行</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g56eutfdydj30qq0ikgmc.jpg" alt="image-20190720170129641"></p><p>SYN攻击原理，eg可以利用hping伪造源ip，发送给假的主机，得不到第三次请求。目标机器不断发送重试，不停回应包，就会导致网络带宽占满。</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g56f1z4xe1j30og0iuq3m.jpg" alt="image-20190720170357218"></p><ul><li><p>减少重试次数</p></li><li><p>可以增加backlog</p></li><li><p>禁止三次握手，SYN cookies技术</p></li></ul><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g56f1r9lamj30m40c40x8.jpg" alt="image-20190720170816652"></p><p>linux下其他预防策略</p><p>1、防火墙上面做相关设置</p><p>2、linux下面可以关闭icmp协议请求</p><p>3、通过iptables防止扫描</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g56f53ibkej30xc0bqmyd.jpg" alt="image-20190720171122849"></p><blockquote><p>学习笔记整理自慕课网以下课程:<br>linux系统扫描命令和安全防范笔记</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;本文主要介绍了一些常用的网络扫描工具以及安全防范，了解更多命令的使用。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="hping" scheme="https://annecoding.github.io/tags/hping/"/>
    
      <category term="traceroute" scheme="https://annecoding.github.io/tags/traceroute/"/>
    
      <category term="Nmap" scheme="https://annecoding.github.io/tags/Nmap/"/>
    
      <category term="Ncap" scheme="https://annecoding.github.io/tags/Ncap/"/>
    
      <category term="fping" scheme="https://annecoding.github.io/tags/fping/"/>
    
  </entry>
  
  <entry>
    <title>linux下占用cpu和内存top10</title>
    <link href="https://annecoding.github.io/2019/06/15/linux%E4%B8%8B%E5%8D%A0%E7%94%A8cpu%E5%92%8C%E5%86%85%E5%AD%98%E5%BE%88%E9%AB%98%E7%9A%84%E8%BF%9B%E7%A8%8B/"/>
    <id>https://annecoding.github.io/2019/06/15/linux下占用cpu和内存很高的进程/</id>
    <published>2019-06-15T06:00:21.000Z</published>
    <updated>2019-09-01T04:58:41.496Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>服务器访问变慢，那么到底是什么进程导致服务器资源变慢呢？我们可以根据cpu、内存等查看占用资源较高的进程。</p><a id="more"></a><p>可以通过ps命令的相关操作来查看。这里分别找出最高占用cpu和内存的10个进程，实现脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat cpu_memory_top.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 查看占用cpu、内存过高的进程</span></span><br><span class="line"><span class="comment"># 占用cpu内存过高的前十个进程</span></span><br><span class="line"><span class="comment"># -e 显示所有程序 -o 使用用户自定义格式 --sort排序</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"--------    cpu top10   ---------"</span></span><br><span class="line">ps -eo user,pid,pcpu,pmem,args --sort=-pcpu |head -n 10</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"--------  memory top10  ---------"</span></span><br><span class="line">ps -eo user,pid,pcpu,pmem,args --sort=-pmem |head -n 10</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ ./cpu_memory_top.sh   </span><br><span class="line">--------    cpu top10   ---------</span><br><span class="line">USER       PID %CPU %MEM COMMAND</span><br><span class="line">root      1066  0.3  0.6 /usr/<span class="built_in">local</span>/aegis/aegis_client/aegis_10_69/AliYunDun</span><br><span class="line">root         1  0.0  0.1 /usr/lib/systemd/systemd --switched-root --system --deserialize 21</span><br><span class="line">root         2  0.0  0.0 [kthreadd]</span><br><span class="line">root         3  0.0  0.0 [ksoftirqd/0]</span><br><span class="line">root         5  0.0  0.0 [kworker/0:0H]</span><br><span class="line">root         7  0.0  0.0 [migration/0]</span><br><span class="line">root         8  0.0  0.0 [rcu_bh]</span><br><span class="line">root         9  0.0  0.0 [rcu_sched]</span><br><span class="line">root        10  0.0  0.0 [watchdog/0]</span><br><span class="line">--------  memory top10  ---------</span><br><span class="line">USER       PID %CPU %MEM COMMAND</span><br><span class="line">root       683  0.0  1.8 /sbin/dhclient -H localhost -1 -q -lf /var/lib/dhclient/dhclient--eth0.lease -pf /var/run/dhclient-eth0.pid eth0</span><br><span class="line">root       328  0.0  1.5 /usr/lib/systemd/systemd-journald</span><br><span class="line">root       765  0.0  0.8 /usr/bin/python -Es /usr/sbin/tuned -l -P</span><br><span class="line">polkitd    458  0.0  0.6 /usr/lib/polkit-1/polkitd --no-debug</span><br><span class="line">root      1066  0.3  0.6 /usr/<span class="built_in">local</span>/aegis/aegis_client/aegis_10_69/AliYunDun</span><br><span class="line">root       767  0.0  0.4 /usr/sbin/rsyslogd -n</span><br><span class="line">root     11661  0.0  0.3 sshd: root@notty</span><br><span class="line">root     11752  0.0  0.2 sshd: root@pts/0</span><br><span class="line">root      2166  0.0  0.2 /usr/sbin/aliyun-service</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;服务器访问变慢，那么到底是什么进程导致服务器资源变慢呢？我们可以根据cpu、内存等查看占用资源较高的进程。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Centos" scheme="https://annecoding.github.io/tags/Centos/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>linux中玩转sed技巧分享</title>
    <link href="https://annecoding.github.io/2019/06/11/linux%E4%B8%AD%E7%8E%A9%E8%BD%ACsed/"/>
    <id>https://annecoding.github.io/2019/06/11/linux中玩转sed/</id>
    <published>2019-06-11T10:51:19.000Z</published>
    <updated>2019-09-01T11:39:38.161Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p><code>sed</code>命令应用广泛，使用简单，是快速文本处理的利器。它其实没多少技巧，背诵、使用是最合适的学习渠道，属于硬技能。但它又很复杂，因为高级功能太多。本篇不去关注sed的高级功能，仅对常用的一些操作，进行说明。<br><a id="more"></a></p><h3 id="sed使用"><a href="#sed使用" class="headerlink" title="sed使用"></a>sed使用</h3><p>sed编辑器被称作流编辑器，它和vim这种的交互式文本编辑器不同，是根据命令来处理数据流中的数据。会执行下列操作：</p><ul><li>一次从输入中读取一行数据（重复该操作直到全部行被读取完）</li><li>根据编辑器命令匹配数据</li><li>按照命令修改数据流中的数据</li><li>将新数据输出到STDOUT(标准输出)</li></ul><p>其中sed命令的可以从命令行中输入，也可以从一个命令文件中读取。</p><p><strong>sed</strong>命令的格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用格式</span></span><br><span class="line">$ sed options script file</span><br><span class="line"><span class="comment"># 添加script中指定的命令</span></span><br><span class="line">$ sed -e script </span><br><span class="line"><span class="comment"># 添加file中指定的命令</span></span><br><span class="line">$ sed -f file </span><br><span class="line"><span class="comment"># 不产生命令输出，使用print命令来完成输出</span></span><br><span class="line"><span class="comment"># -n 这个参数是--quiet或者--silent的意思。表明忽略执行过程的输出，只输出我们的结果即可。</span></span><br><span class="line">$ sed -n</span><br></pre></td></tr></table></figure><h3 id="替换命令s"><a href="#替换命令s" class="headerlink" title="替换命令s"></a>替换命令s</h3><p><code>s</code>命令会用斜线间指定的<strong>第二个</strong>文本字符串来<strong>替换第一个</strong>文本字符串模式。</p><p>1.用big test替换了test。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"This is a test"</span> | sed <span class="string">'s/test/big test/'</span></span><br><span class="line">This is a big <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>2.用<strong>cat</strong>替换整个文件中的<strong>dog</strong></p><p>示例文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat data1.txt</span><br><span class="line">The quick brown fox jumps over the lazy dog.</span><br><span class="line">The quick brown fox jumps over the lazy dog.</span><br><span class="line">The quick brown fox jumps over the lazy dog.</span><br><span class="line">The quick brown fox jumps over the lazy dog.</span><br></pre></td></tr></table></figure><p>使用sed命令进行替换：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'s/dog/cat/'</span> data1.txt</span><br><span class="line">The quick brown fox jumps over the lazy cat.</span><br><span class="line">The quick brown fox jumps over the lazy cat.</span><br><span class="line">The quick brown fox jumps over the lazy cat.</span><br><span class="line">The quick brown fox jumps over the lazy cat.</span><br></pre></td></tr></table></figure><p>🌟 重要的是，要记住，<strong>sed编辑器并不会修改文本文件的数据</strong>。它只会将修改后的数据发送到STDOUT。<strong>如果你查看原来的文本文件，它仍然保留着原始数据。</strong></p><p>3.在命令行使用多个编辑器命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e <span class="string">'s/brown/green/; s/dog/cat/'</span> data1.txt</span><br><span class="line">The quick green fox jumps over the lazy cat.</span><br><span class="line">The quick green fox jumps over the lazy cat.</span><br><span class="line">The quick green fox jumps over the lazy cat.</span><br><span class="line">The quick green fox jumps over the lazy cat.</span><br></pre></td></tr></table></figure><p>4.从文件中读取编辑器命令</p><p>如果有大量要处理的sed命令，那么将它们放进一个单独的文件中通常会更方便一些。<br>可以在sed命令中用<code>-f</code>选项来指定文件。</p><p>示例sed编辑器脚本文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat script1.sed</span><br><span class="line">s/brown/green/</span><br><span class="line">s/fox/elephant/</span><br><span class="line">s/dog/cat/</span><br></pre></td></tr></table></figure><p>执行sed编辑器脚本文件，按照脚本文件替换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed -f script1.sed data1.txt</span><br><span class="line">The quick green elephant jumps over the lazy cat.</span><br><span class="line">The quick green elephant jumps over the lazy cat.</span><br><span class="line">The quick green elephant jumps over the lazy cat.</span><br><span class="line">The quick green elephant jumps over the lazy cat.</span><br></pre></td></tr></table></figure><h3 id="更多替换选项"><a href="#更多替换选项" class="headerlink" title="更多替换选项"></a>更多替换选项</h3><h4 id="替换标记"><a href="#替换标记" class="headerlink" title="替换标记"></a>替换标记</h4><p>替换命令在替换多行中的文本时能正常工作，但默认情况下它只替换每行中出现的第一处。要让替换命令能够替换一行中不同地方出现的文本必须使用替换标记（substitution flag）。</p><p>替换标记会在替换命令字符串之后设置。格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s/pattern/replacement/flags</span><br></pre></td></tr></table></figure><p>有4种可用的替换标记：</p><ul><li>数字，表明新文本将替换第几处模式匹配的地方；</li><li>g，表明新文本将会替换所有匹配的文本；</li><li>p，表明原先行的内容要打印出来；</li><li>w file，将替换的结果写到文件中。</li></ul><p>示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sed编辑器只替换每行中第二次出现的匹配模式</span></span><br><span class="line">$ sed <span class="string">'s/test/trial/2'</span> data4.txt</span><br><span class="line">This is a <span class="built_in">test</span> of the trial script.</span><br><span class="line">This is the second <span class="built_in">test</span> of the trial script. </span><br><span class="line"><span class="comment"># g替换标记使你能替换文本中匹配模式所匹配的每处地方</span></span><br><span class="line">$ sed <span class="string">'s/test/trial/g'</span> data4.txt</span><br><span class="line">This is a trial of the trial script.</span><br><span class="line">This is the second trial of the trial script. </span><br><span class="line"><span class="comment"># p替换标记会打印与替换命令中指定的模式匹配的行。-n选项将禁止sed编辑器输出。</span></span><br><span class="line"><span class="comment"># p -n只输出被替换命令修改过的行。</span></span><br><span class="line">$ cat data5.txt</span><br><span class="line">This is a <span class="built_in">test</span> line.</span><br><span class="line">This is a different line.</span><br><span class="line">$ sed -n <span class="string">'s/test/trial/p'</span> data5.txt</span><br><span class="line">This is a trial line. </span><br><span class="line"><span class="comment"># w替换标记会产生同样的输出，不过会将输出保存到指定文件中。</span></span><br><span class="line">$ sed <span class="string">'s/test/trial/w test.txt'</span> data5.txt</span><br><span class="line">This is a trial line.</span><br><span class="line">This is a different line.</span><br><span class="line">$ cat test.txt</span><br><span class="line">This is a trial line.</span><br></pre></td></tr></table></figure><p>🌟  sed并没有对文件内容进行改变，因此如果要写回文件，可以使用重定向。</p><p>1.通过重定向写入新文件，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">"s/dog/cat/g"</span> data1.txt &gt; data1new.txt</span><br></pre></td></tr></table></figure><p>或者使用<code>-i</code>参数直接修改文件内容，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -i <span class="string">"s/dog/cat/g"</span> data1.txt</span><br></pre></td></tr></table></figure><p>2.在每一行前面添加内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'s/^/#/g'</span> data1.txt</span><br><span class="line"><span class="comment">#the quick brown fox jumps over the lazy dog.</span></span><br><span class="line"><span class="comment">#the quick brown fox jumps over the lazy dog.</span></span><br><span class="line"><span class="comment">#the quick brown fox jumps over the lazy dog.</span></span><br><span class="line"><span class="comment">#the quick brown fox jumps over the lazy dog.</span></span><br></pre></td></tr></table></figure><p>3.在每一行最后添加内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'s/$/---/g'</span> data1.txt</span><br><span class="line">the quick brown fox jumps over the lazy dog.---</span><br><span class="line">the quick brown fox jumps over the lazy dog.---</span><br><span class="line">the quick brown fox jumps over the lazy dog.---</span><br><span class="line">the quick brown fox jumps over the lazy dog.---</span><br></pre></td></tr></table></figure><p>顺便介绍一下正则表达式的一些最基本的东西：</p><ul><li><code>^</code> 表示一行的开头。如：<code>/^#/</code> 以#开头的匹配。</li><li><code>$</code> 表示一行的结尾。如：<code>/}$/</code> 以}结尾的匹配。</li><li><code>\&lt;</code> 表示词首。 如：<code>\&lt;abc</code> 表示以 abc 为首的詞。</li><li><code>\&gt;</code> 表示词尾。 如：<code>abc\&gt;</code> 表示以 abc 結尾的詞。</li><li><code>.</code> 通配符，表示几乎任意字符，除了换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号 … 中的每个点，此处省略了无数个字（什么情况都可能发生）。</li><li><code>?</code>表示某个字符出现了0次或1次。</li><li><code>*</code>表示某个字符出现了0次或多次。</li><li><code>+</code>表示某个字符出现了1次或多次。</li><li><code>[ ]</code> 字符集合。 如：<code>[abc]</code> 表示匹配a或b或c，还有 <code>[a-zA-Z]</code> 表示匹配所有的26个字符。如果其中有^表示反，如 <code>[^a]</code> 表示非a的字符。还有<code>[0-9]</code> 匹配括号中的任何一个字符。</li><li><code>{m}</code>前面的匹配重复m次，<code>{m,n}</code> 前面的匹配重复m到n次</li></ul><p>💡 强大到无往不利的正则表达式简单示例，比如去除下面html中的tags:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;This&lt;/b&gt; is what &lt;span style=<span class="string">"text-decoration: underline;"</span>&gt;I&lt;/span&gt; meant. Understand?</span><br></pre></td></tr></table></figure></p><p>sed命令实现：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果你这样搞的话，就会有问题，贪婪模式，匹配(&lt;)到(&gt;)之间的所有内容</span></span><br><span class="line">$ sed <span class="string">'s/&lt;.*&gt;//g'</span> html.txt</span><br><span class="line"> meant. Understand</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 要解决上面的那个问题，就得像下面这样。</span></span><br><span class="line"><span class="comment"># 其中的'[^&gt;]' 指定了除了&gt;的字符重复0次或多次。</span></span><br><span class="line">$ sed <span class="string">'s/&lt;[^&gt;]*&gt;//g'</span> html.txt</span><br><span class="line">This is what I meant. Understand?</span><br></pre></td></tr></table></figure></p><p>💡 <strong>其他有趣示例</strong></p><p>1.输出长度不小于50个字符的行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="string">'/^.&#123;50&#125;/p'</span></span><br></pre></td></tr></table></figure><p>2.统计文件中有每个单词出现了多少次</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'s/ /\n/g'</span> file | sort | uniq -c</span><br></pre></td></tr></table></figure><p>3.查找目录中的py文件，删掉所有行级注释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find ./ -name <span class="string">"*.py"</span> | xargs sed  -i.bak <span class="string">'/^[ ]*#/d'</span></span><br></pre></td></tr></table></figure><p>4.查看第5-7行和10-13行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n -e <span class="string">'5,7p'</span> -e <span class="string">'10,13p'</span> file</span><br></pre></td></tr></table></figure><p>5.仅输出ip地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip route show | sed -n <span class="string">'/src/p'</span> | sed -e <span class="string">'s/  */ /g'</span> | cut -d<span class="string">' '</span> -f9</span><br></pre></td></tr></table></figure><h3 id="使用地址"><a href="#使用地址" class="headerlink" title="使用地址"></a>使用地址</h3><p>默认情况下，在sed编辑器中使用的命令会作用于文本数据的所有行。如果只想将命令作用于特定行或某些行，则必须用行寻址（line addressing）。</p><h4 id="数字方式寻址"><a href="#数字方式寻址" class="headerlink" title="数字方式寻址"></a>数字方式寻址</h4><p>sed编辑器会将文本流中的第一行编号为1，然后继续按顺序为接下来的行分配行号。</p><p>1.只修改第二行的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'2s/dog/cat/'</span> data1.txt</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br></pre></td></tr></table></figure><p>2.修改第二行和第三行，使用行地址区间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'2,3s/dog/cat/'</span> data1.txt</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br></pre></td></tr></table></figure><p>3.也可以匹配从文本中某行开始到结束的所有行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'2,$s/dog/cat/'</span> data1.txt</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br></pre></td></tr></table></figure><h4 id="使用文本过滤器"><a href="#使用文本过滤器" class="headerlink" title="使用文本过滤器"></a>使用文本过滤器</h4><p>sed编辑器允许指定文本模式来过滤出命令要作用的行。格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/pattern/<span class="built_in">command</span></span><br></pre></td></tr></table></figure><p>必须用正斜线将要指定的pattern封起来。sed编辑器会将该命令作用到包含指定文本模式的行上。</p><p>举个栗子🌰来说明一下吧，在<code>/etc/passwd</code>中只修改用户Samantha的默认shell，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ grep Samantha /etc/passwd</span><br><span class="line">Samantha:x:502:502::/home/Samantha:/bin/bash</span><br><span class="line">$ sed <span class="string">'/Samantha/s/bash/csh/'</span> /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">[...]</span><br><span class="line">Christine:x:501:501:Christine B:/home/Christine:/bin/bash</span><br><span class="line">Samantha:x:502:502::/home/Samantha:/bin/csh</span><br><span class="line">Timothy:x:503:503::/home/Timothy:/bin/bash</span><br></pre></td></tr></table></figure><h3 id="删除行"><a href="#删除行" class="headerlink" title="删除行"></a>删除行</h3><p>使用删除命令d对文本进行删除操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有文本</span></span><br><span class="line">sed <span class="string">'d'</span> data1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除单行</span></span><br><span class="line">sed <span class="string">'2d'</span> data1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除行区间[2,3]</span></span><br><span class="line">sed <span class="string">'2,3d'</span> data1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除行区间[2,endline]</span></span><br><span class="line">sed <span class="string">'2,$d'</span> data1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除匹配文本aa的行</span></span><br><span class="line">sed <span class="string">'/aa/d'</span> data1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除两个匹配文本之间的文本 匹配到1和3的行之间的文本全部被删除</span></span><br><span class="line">sed <span class="string">'/1/,/3/d'</span> data1.txt</span><br></pre></td></tr></table></figure><h3 id="插入、附加文本"><a href="#插入、附加文本" class="headerlink" title="插入、附加文本"></a>插入、附加文本</h3><p>1.插入命令<code>i</code>在指定行前增加新行</p><p>2.附加命令<code>a</code>在指定行后增加新行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 追加</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"Test Line 2"</span> | sed <span class="string">'a\Test Line 1'</span></span><br><span class="line">Test Line 2</span><br><span class="line">Test Line 1 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"Test Line 2"</span> | sed <span class="string">'i\Test Line 1'</span></span><br><span class="line">Test Line 1</span><br><span class="line">Test Line 2</span><br></pre></td></tr></table></figure><h3 id="修改行"><a href="#修改行" class="headerlink" title="修改行"></a>修改行</h3><p>使用<code>c</code>命令来修改一行数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改第三行文本</span></span><br><span class="line">$ sed <span class="string">'3c\</span></span><br><span class="line"><span class="string">This is a changed line of text.'</span> data1.txt</span><br><span class="line">the quick brown fox jumps over the lazy dog.</span><br><span class="line">the quick brown fox jumps over the lazy dog.</span><br><span class="line">This is a changed line of text.</span><br><span class="line">the quick brown fox jumps over the lazy dog.</span><br></pre></td></tr></table></figure><h3 id="转换命令"><a href="#转换命令" class="headerlink" title="转换命令"></a>转换命令</h3><p>命令格式<code>sed &#39;y/inchar/outchar&#39;</code></p><p>将inchar中的字符一一对应地转换成outchar的字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"This 1 is a test of 1 try."</span> | sed <span class="string">'y/123/456/'</span></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">This 4 is a <span class="built_in">test</span> of 4 try.</span><br></pre></td></tr></table></figure><p>💡 如你在输出中看到的，inchars模式中指定字符的<strong>每个实例都会被替换成outchars模式中</strong><br><strong>相同位置的那个字符。</strong></p><h3 id="打印命令"><a href="#打印命令" class="headerlink" title="打印命令"></a>打印命令</h3><p>1.打印数据文本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"this is a test"</span> | sed <span class="string">'p'</span></span><br><span class="line">this is a <span class="built_in">test</span></span><br><span class="line">this is a <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>2.打印包含匹配文本模式的行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line"><span class="comment"># 模式匹配</span></span><br><span class="line">$ sed -n <span class="string">'/number 3/p'</span> data6.txt</span><br><span class="line">This is line number 3. </span><br><span class="line"><span class="comment"># 从一个模式到另一个模式</span></span><br><span class="line">$ sed -n <span class="string">'/number 2/,/number 3/p'</span> data6.txt</span><br><span class="line">this is line number 2.</span><br><span class="line">this is line number 3.</span><br></pre></td></tr></table></figure><p>3.快速打印数据流中的某些行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="string">'2,3p'</span> data6.txt</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br></pre></td></tr></table></figure><p>4.从第一行打印匹配3成功的那一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="string">'1,/3/p'</span> data6.txt</span><br><span class="line">this is line number 1.</span><br><span class="line">this is line number 2.</span><br><span class="line">this is line number 3.</span><br></pre></td></tr></table></figure><blockquote><p>参考链接：<br><a href="https://coolshell.cn/articles/9104.html" target="_blank" rel="noopener">SED 简明教程</a><br><a href="https://juejin.im/post/5ce5190b5188252dbb08baa8" target="_blank" rel="noopener">Linux生产环境上，最常用的一套“Sed“技巧</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;&lt;code&gt;sed&lt;/code&gt;命令应用广泛，使用简单，是快速文本处理的利器。它其实没多少技巧，背诵、使用是最合适的学习渠道，属于硬技能。但它又很复杂，因为高级功能太多。本篇不去关注sed的高级功能，仅对常用的一些操作，进行说明。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="sed" scheme="https://annecoding.github.io/tags/sed/"/>
    
  </entry>
  
  <entry>
    <title>linux中玩转awk技巧分享</title>
    <link href="https://annecoding.github.io/2019/06/10/linux%E4%B8%AD%E7%8E%A9%E8%BD%ACawk/"/>
    <id>https://annecoding.github.io/2019/06/10/linux中玩转awk/</id>
    <published>2019-06-10T01:22:36.000Z</published>
    <updated>2019-09-01T11:39:33.992Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p><strong>awk</strong>其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</p><a id="more"></a><h3 id="awk简明教程"><a href="#awk简明教程" class="headerlink" title="awk简明教程"></a>awk简明教程</h3><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑（擅长取行），awk（擅长取列）在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p><p>awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。</p><p><strong>awk</strong>简单来讲：<strong>取文件中的某列数据</strong>。</p><p>通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种</span></span><br><span class="line">awk <span class="string">'&#123;pattern + action&#125;'</span> &#123;filenames&#125;</span><br><span class="line"><span class="comment"># 第二种</span></span><br><span class="line">awk [可选的命令行选项] <span class="string">'BEGIN&#123;命令 &#125; pattern&#123; 命令 &#125; END&#123; 命令 &#125;'</span>  文件名</span><br></pre></td></tr></table></figure><p>关于第二种方式，解释如下：</p><p>1.<strong>BEGIN 开头部分</strong>，可选的。用来设置一些参数，输出一些表头，定义一些变量等。上面的命令仅打印了一行信息而已。</p><p>2.<strong>END 结尾部分</strong>，可选的。用来计算一些汇总逻辑，或者输出这些内容。上面的命令，使用简单的for循环，输出了数组rt中的内容。</p><p>3.<strong>Pattern 匹配部分</strong>，依然可选。用来匹配一些需要处理的行。上面的命令，只匹配tcp开头的行，其他的不进入处理。</p><p>4.<strong>Action 模块</strong>。主要逻辑体，按行处理，统计打印，都可以。</p><h3 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h3><p>1.首先保存一个示例文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat netstat </span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2036/sshd           </span><br><span class="line">tcp6       0      0 :::7500                 :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::7000                 :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::443                  :::*                    LISTEN      17767/./frps</span><br></pre></td></tr></table></figure><p>2.输出第一列和第四列</p><ul><li>其中<strong>单引号</strong>中被大括号括着的就是<strong>awk语句</strong>，<strong>只能被单引号包含</strong>。</li><li><code>$1..$n</code>表示<strong>第几列</strong>，<code>$0</code>表示<strong>整行</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'&#123;print $1,$4&#125;'</span> netstat </span><br><span class="line">Active (only</span><br><span class="line">Proto Local</span><br><span class="line">tcp 0.0.0.0:22</span><br><span class="line">tcp6 :::7500</span><br><span class="line">tcp6 :::80</span><br><span class="line">tcp6 :::7000</span><br><span class="line">tcp6 :::443</span><br><span class="line"></span><br><span class="line">$ cat /etc/passwd |awk  -F <span class="string">':'</span>  <span class="string">'&#123;print $1&#125;'</span>  </span><br><span class="line">root</span><br><span class="line">daemon</span><br><span class="line">bin</span><br><span class="line">sys</span><br></pre></td></tr></table></figure><h3 id="过滤记录"><a href="#过滤记录" class="headerlink" title="过滤记录"></a>过滤记录</h3><p>1.awk可以对其中的某些字段进行判断，通过与或非连接。awk 中的比较运算符用于比较字符串和或者数值，包括以下类型：</p><ul><li><code>&gt;</code> – 大于</li><li><code>&lt;</code> – 小于</li><li><code>&gt;=</code> – 大于等于</li><li><code>&lt;=</code> – 小于等于</li><li><code>==</code> – 等于</li><li><code>!=</code> – 不等于</li><li><code>some_value ~ / pattern/</code> – 如果 some_value 匹配模式 pattern，则返回 true</li><li><code>some_value !~ / pattern/</code> – 如果 some_value 不匹配模式 pattern，则返回 true</li></ul><p>如以下常用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'$1=="tcp" &amp;&amp; $6=="LISTEN" '</span> netstat  </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2036/sshd   </span><br><span class="line"><span class="comment"># 需要表头的话，可以引入内建变量NR</span></span><br><span class="line">$ awk <span class="string">'$1=="tcp" &amp;&amp; $6=="LISTEN" || NR==2 '</span> netstat  </span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2036/sshd </span><br><span class="line"><span class="comment"># NR也可以用来打印行号</span></span><br><span class="line">$ awk <span class="string">'$1=="tcp6" &#123; print NR,$0 &#125;'</span> netstat  </span><br><span class="line">4 tcp6       0      0 :::7500                 :::*                    LISTEN      17767/./frps        </span><br><span class="line">5 tcp6       0      0 :::80                   :::*                    LISTEN      17767/./frps        </span><br><span class="line">6 tcp6       0      0 :::7000                 :::*                    LISTEN      17767/./frps        </span><br><span class="line">7 tcp6       0      0 :::443                  :::*                    LISTEN      17767/./frps</span><br></pre></td></tr></table></figure><h3 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h3><p>程序已经定义好的变量，可以直接来使用，以下常见的变量。</p><table><thead><tr><th style="text-align:left">变量</th><th>释义</th></tr></thead><tbody><tr><td style="text-align:left"><code>$0</code></td><td>当前记录（这个变量中存放着整个行的内容）</td></tr><tr><td style="text-align:left"><code>$1~$n</code></td><td>当前记录的第n个字段，字段间由FS分隔</td></tr><tr><td style="text-align:left"><code>FS</code></td><td>输入字段分隔符 默认是空格或Tab</td></tr><tr><td style="text-align:left"><code>NF</code></td><td>当前记录中的字段个数，就是有多少列</td></tr><tr><td style="text-align:left"><code>NR</code></td><td>已经读出的记录数，就是行号，从1开始，如果有多个文件话，不断累加。</td></tr><tr><td style="text-align:left"><code>FNR</code></td><td>当前记录数，与NR不同的是，这个值会是各个文件自己的行号</td></tr><tr><td style="text-align:left"><code>RS</code></td><td>输入的记录分隔符， 默认为换行符</td></tr><tr><td style="text-align:left"><code>OFS</code></td><td>输出字段分隔符， 默认也是空格</td></tr><tr><td style="text-align:left"><code>ORS</code></td><td>输出的记录分隔符，默认为换行符</td></tr><tr><td style="text-align:left"><code>FILENAME</code></td><td>当前输入文件的名字</td></tr></tbody></table><p>❈ ❈ ❈   <strong>一般的开发语言，数组下标是以0开始的，但awk的列$是以1开始的，而0指的是原始字符串。</strong></p><p>1.输出表头、行号及特定列</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用内建变量NR、FNR输出行号以及表头</span></span><br><span class="line">$ awk <span class="string">'$3==0 &amp;&amp; $6=="LISTEN" || NR==2 &#123;print NR,FNR,$1,$3,$6&#125;'</span> netstat</span><br><span class="line">2 2 Proto Send-Q Foreign</span><br><span class="line">3 3 tcp 0 LISTEN</span><br><span class="line">4 4 tcp6 0 LISTEN</span><br><span class="line">5 5 tcp6 0 LISTEN</span><br><span class="line">6 6 tcp6 0 LISTEN</span><br><span class="line">7 7 tcp6 0 LISTEN</span><br></pre></td></tr></table></figure><p>2.使用分隔符来输出特定的行或者列，下面👇两个命令等价：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;FS=":"&#125; &#123;print $1, $7&#125;'</span> /etc/passwd | head -n 4</span><br><span class="line">root /bin/bash</span><br><span class="line">bin /sbin/nologin</span><br><span class="line">daemon /sbin/nologin</span><br><span class="line">adm /sbin/nologin</span><br><span class="line"></span><br><span class="line"><span class="comment"># -F指定域分隔符为':'</span></span><br><span class="line">$ cat /etc/passwd |awk  -F <span class="string">':'</span>  <span class="string">'&#123;print $1"\t"$7&#125;'</span> | head -n 4</span><br><span class="line">root    /bin/bash</span><br><span class="line">bin     /sbin/nologin</span><br><span class="line">daemon  /sbin/nologin</span><br><span class="line">adm     /sbin/nologin</span><br></pre></td></tr></table></figure><p>❈ ❈ ❈  如果要是用多个分隔符，可以使用下面方式来指定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F <span class="string">'[;:]'</span></span><br></pre></td></tr></table></figure><p>3.自定义以<code>\t</code>作为分隔符输出的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F: <span class="string">'&#123;print $1,$7&#125;'</span> OFS=<span class="string">"\t"</span> /etc/passwd | head -n 4</span><br><span class="line">root    /bin/bash</span><br><span class="line">bin     /sbin/nologin</span><br><span class="line">daemon  /sbin/nologin</span><br><span class="line">adm     /sbin/nologin</span><br></pre></td></tr></table></figure><h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><p>1.像<strong>grep</strong>一样匹配相关字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只匹配80的字符</span></span><br><span class="line">$ awk <span class="string">'/80/'</span> netstat</span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      17767/./frps  </span><br><span class="line"><span class="comment"># 匹配80、或者7000、或者tcp6的相关字符</span></span><br><span class="line">$ awk <span class="string">'/80|7000|tcp6/'</span> netstat  </span><br><span class="line">tcp6       0      0 :::7500                 :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::7000                 :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::443                  :::*                    LISTEN      17767/./frps</span><br></pre></td></tr></table></figure><p>2.精确的匹配某个字段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $4匹配第四列的数据</span></span><br><span class="line">$ awk <span class="string">'$4 ~/80|7000/ &#123;print $0&#125;'</span> netstat </span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::7000                 :::*                    LISTEN      17767/./frps   </span><br><span class="line"><span class="comment"># 搜索包含System关键字的行并输出</span></span><br><span class="line">$ cat -n /etc/passwd | gawk -F: <span class="string">'/System/&#123;print $1" "$5&#125;'</span></span><br><span class="line">    17  dbus System message bus</span><br></pre></td></tr></table></figure><p> ❈ ❈ ❈  <strong>其实 <code>~</code>表示模式开始。<code>/ /</code>中是模式。这就是一个正则表达式的匹配。</strong></p><p>对此模式取反的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串匹配取反</span></span><br><span class="line">$ awk <span class="string">'!/80/'</span> netstat                      </span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2036/sshd           </span><br><span class="line">tcp6       0      0 :::7500                 :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::7000                 :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::443                  :::*                    LISTEN      17767/./frps </span><br><span class="line"><span class="comment"># 精确匹配取反</span></span><br><span class="line">$ awk <span class="string">'$4 !~/80|7000/ &#123;print $0&#125;'</span> netstat    </span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2036/sshd           </span><br><span class="line">tcp6       0      0 :::7500                 :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::443                  :::*                    LISTEN      17767/./frps</span><br></pre></td></tr></table></figure><h3 id="拆分文件"><a href="#拆分文件" class="headerlink" title="拆分文件"></a>拆分文件</h3><p>1.指定某列为分类符，使用<strong>重定向</strong>就可以导出到不同的文件中，例如下列语句通过第1列进行分割：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照第1列拆分文件，第一列有tcp、tcp6两种类型</span></span><br><span class="line"><span class="comment"># 所以按照类型命名，当前目录下会多两个文件</span></span><br><span class="line">$ awk <span class="string">'NR!=2&#123;print &gt; $1&#125;'</span> netstat  </span><br><span class="line">$ cat tcp</span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2036/sshd           </span><br><span class="line">$ ls</span><br><span class="line">netstat  tcp  tcp6</span><br></pre></td></tr></table></figure><p>2.也可以把<strong>指定的列</strong>追加<code>&gt;&gt;</code>到文件，追加不会覆盖源文件，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'NR!=1&#123;print $4,$7 &gt;&gt; $1&#125;'</span> netstat</span><br><span class="line">$ cat tcp</span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2036/sshd           </span><br><span class="line">0.0.0.0:22 2036/sshd</span><br></pre></td></tr></table></figure><p>3.也可以使用复杂的表达式（例如if-else-if语句，awk是个脚本解释器）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'NR!=1&#123;if($4 ~ /80|443/) print &gt; "1.txt";         </span></span><br><span class="line"><span class="string">else if($4 ~/7000/) print &gt; "2.txt";</span></span><br><span class="line"><span class="string">else print &gt; "3.txt" &#125;'</span> netstat</span><br><span class="line">$ ls ?.txt</span><br><span class="line">1.txt  2.txt  3.txt    </span><br><span class="line">$ cat 1.txt</span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      17767/./frps        </span><br><span class="line">tcp6       0      0 :::443                  :::*                    LISTEN      17767/./frps </span><br><span class="line">$ cat 2.txt</span><br><span class="line">tcp6       0      0 :::7000                 :::*                    LISTEN      17767/./frps </span><br><span class="line"><span class="comment"># 其中NR!=1，不取第一行数据</span></span><br><span class="line"><span class="comment"># 这是第一行数据Active Internet connections (only servers)</span></span><br><span class="line"><span class="comment"># else print &gt; "3.txt" 匹配的是非前两列匹配到的其他内容，注意if和else if要对相同列数据进行操作，不然可能输出内容有问题</span></span><br><span class="line">$ cat 3.txt</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2036/sshd           </span><br><span class="line">tcp6       0      0 :::7500                 :::*                    LISTEN      17767/./frps</span><br></pre></td></tr></table></figure><h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>1.统计某个文件夹下的文件占用的字节数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l |awk <span class="string">'BEGIN &#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print "[end]size is ", size&#125;'</span></span><br><span class="line">[end]size is  8657198</span><br></pre></td></tr></table></figure><p> 如果以M为单位显示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l |awk <span class="string">'BEGIN &#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print "[end]size is ", size/1024/1024,"M"&#125;'</span> </span><br><span class="line">[end]size is  8.25889 M</span><br></pre></td></tr></table></figure><p>注意，统计不包括文件夹的子目录。</p><p>2.统计以.txt为后缀的文件总大小：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ll *.txt | awk <span class="string">'&#123;sum+=$5&#125; END &#123;print sum&#125;'</span></span><br><span class="line">769.9</span><br></pre></td></tr></table></figure><p>3.统计文件夹下的文件数目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -lha | gawk <span class="string">'BEGIN &#123;count=0&#125; &#123;count++&#125; END &#123; print "File Count:"count&#125;'</span> </span><br><span class="line">File Count:41</span><br></pre></td></tr></table></figure><p>4.统计外网连接数，根据ip分组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -ant | awk <span class="string">'/^tcp/&#123;print $5&#125;'</span> | awk -F: <span class="string">'!/^:/&#123;print $1&#125;'</span> | sort | uniq -c</span><br><span class="line"><span class="comment"># sort 将重复的行集中在一起</span></span><br><span class="line"><span class="comment"># uniq 对文本行进行去重 -c 统计重复次数</span></span><br><span class="line"><span class="comment"># 可实现对文本行按重复次数进行排序 默认是升序  -r 降序</span></span><br><span class="line">$ sort 1.txt | uniq -c | sort -rn</span><br></pre></td></tr></table></figure><p>5.统计第6列连接状态总共出现了几次</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'NR!=1&#123;a[$6]++;&#125; END &#123;for (i in a) print i ", " a[i];&#125;'</span> netstat </span><br><span class="line">LISTEN, 5</span><br><span class="line">Foreign, 1</span><br></pre></td></tr></table></figure><p>6.统计每个用户的进程占用了多少内存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps aux | awk <span class="string">'NR!=1&#123;a[$1]+=$6;&#125; END &#123;for(i in a) print i "," a[i]"KB"; &#125;'</span></span></span><br><span class="line">dbus,1492KB</span><br><span class="line">polkitd,10972KB</span><br><span class="line">ntp,2104KB</span><br><span class="line">root,138580KB</span><br></pre></td></tr></table></figure><h3 id="awk脚本"><a href="#awk脚本" class="headerlink" title="awk脚本"></a>awk脚本</h3><p>在上面我们可以看到一个<strong>END</strong>关键字。<strong>END</strong>的意思是“处理完所有的行的标识”，即然说到了<strong>END</strong>就有必要介绍一下BEGIN，这两个关键字意味着<strong>执行前</strong>和<strong>执行后</strong>的意思，语法如下：</p><ul><li><strong>BEGIN</strong>{ 这里面放的是执行前的语句 }</li><li><strong>END</strong> { 这里面放的是处理完所有的行后要执行的语句 }</li><li>{ 这里面放的是处理每一行时要执行的语句 }</li></ul><p>so，举个栗子🌰</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat score </span><br><span class="line">Marry   2143 78 84 77</span><br><span class="line">Jack    2321 66 78 45</span><br><span class="line">Tom     2122 48 77 71</span><br><span class="line">Mike    2537 87 97 95</span><br><span class="line">Bob     2415 40 57 62</span><br></pre></td></tr></table></figure><p>awk脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cat cal.awk </span><br><span class="line"><span class="comment">#!/bin/awk -f</span></span><br><span class="line"><span class="comment">#运行前</span></span><br><span class="line">BEGIN &#123;</span><br><span class="line">    math = 0</span><br><span class="line">    english = 0</span><br><span class="line">    computer = 0</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n"</span></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"---------------------------------------------\n"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#运行中</span></span><br><span class="line">&#123;</span><br><span class="line">    math+=<span class="variable">$3</span></span><br><span class="line">    english+=<span class="variable">$4</span></span><br><span class="line">    computer+=<span class="variable">$5</span></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"%-6s %-6s %4d %8d %8d %8d\n"</span>, <span class="variable">$1</span>, <span class="variable">$2</span>, <span class="variable">$3</span>,<span class="variable">$4</span>,<span class="variable">$5</span>, <span class="variable">$3</span>+<span class="variable">$4</span>+<span class="variable">$5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#运行后</span></span><br><span class="line">END &#123;</span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"---------------------------------------------\n"</span></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"  TOTAL:%10d %8d %8d \n"</span>, math, english, computer</span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"AVERAGE:%10.2f %8.2f %8.2f\n"</span>, math/NR, english/NR, computer/NR</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -f调用脚本</span></span><br><span class="line">$ awk -f cal.awk score     </span><br><span class="line">NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL</span><br><span class="line">---------------------------------------------</span><br><span class="line">Marry  2143     78       84       77      239</span><br><span class="line">Jack   2321     66       78       45      189</span><br><span class="line">Tom    2122     48       77       71      196</span><br><span class="line">Mike   2537     87       97       95      279</span><br><span class="line">Bob    2415     40       57       62      159</span><br><span class="line">---------------------------------------------</span><br><span class="line">  TOTAL:       319      393      350 </span><br><span class="line">AVERAGE:     63.80    78.60    70.00</span><br></pre></td></tr></table></figure><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>awk脚本与环境变量的交互，使用-v参数（定义变量）和ENVIRON，使用ENVIRON的环境变量需要export。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ x=5</span><br><span class="line">$ y=10</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$x</span></span><br><span class="line">5</span><br><span class="line">$ <span class="built_in">export</span> y</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$x</span> <span class="variable">$y</span></span><br><span class="line">5 10</span><br><span class="line">$ awk -v val=<span class="variable">$x</span> <span class="string">'&#123;print $1,$2,$3,$4+val,$5+ENVIRON["y"]&#125;'</span> OFS=<span class="string">"\t"</span> score </span><br><span class="line">Marry   2143    78      89      87</span><br><span class="line">Jack    2321    66      83      55</span><br><span class="line">Tom     2122    48      82      81</span><br><span class="line">Mike    2537    87      102     105</span><br><span class="line">Bob     2415    40      62      72</span><br></pre></td></tr></table></figure><h3 id="有趣示例"><a href="#有趣示例" class="headerlink" title="有趣示例"></a>有趣示例</h3><p>1.从file文件中找出长度大于20的行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'length&gt;=21'</span> score </span><br><span class="line">Marry   2143 78 84 77</span><br><span class="line">Jack    2321 66 78 45</span><br><span class="line">Tom     2122 48 77 71</span><br><span class="line">Mike    2537 87 97 95</span><br><span class="line">Bob     2415 40 57 62</span><br></pre></td></tr></table></figure><p>2.按连接数查看客户端ip，根据ip分组计数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -ntu | awk <span class="string">'&#123;print $5&#125;'</span> | cut -d: -f1 | sort | uniq -c</span><br><span class="line">      1 100.100.30.25</span><br><span class="line">      2 112.213.179.149</span><br><span class="line">      1 173.255.234.138</span><br><span class="line">      1 47.52.207.198</span><br><span class="line">      1 47.93.222.200</span><br><span class="line">      1 60.247.88.82</span><br><span class="line">      1 77.247.110.219</span><br><span class="line">      1 80.1.15.172</span><br><span class="line">      7 80.82.70.187</span><br><span class="line">      1 89.248.174.198</span><br><span class="line">      1 Address</span><br><span class="line">      1 servers)</span><br><span class="line"><span class="comment"># cut用法</span></span><br><span class="line"><span class="comment"># -d ：自定义分隔符，默认为制表符。</span></span><br><span class="line"><span class="comment"># -f ：与-d一起使用，指定显示哪个区域。</span></span><br></pre></td></tr></table></figure><p>3.打印九九乘法表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ seq 9 | sed <span class="string">'H;g'</span> | awk -v RS=<span class="string">''</span> <span class="string">'&#123;for(i=1;i&lt;=NF;i++)printf("%dx%d=%d%s", i, NR, i*NR, i==NR?"\n":"\t")&#125;'</span></span><br><span class="line">1x1=1</span><br><span class="line">1x2=2   2x2=4</span><br><span class="line">1x3=3   2x3=6   3x3=9</span><br><span class="line">1x4=4   2x4=8   3x4=12  4x4=16</span><br><span class="line">1x5=5   2x5=10  3x5=15  4x5=20  5x5=25</span><br><span class="line">1x6=6   2x6=12  3x6=18  4x6=24  5x6=30  6x6=36</span><br><span class="line">1x7=7   2x7=14  3x7=21  4x7=28  5x7=35  6x7=42  7x7=49</span><br><span class="line">1x8=8   2x8=16  3x8=24  4x8=32  5x8=40  6x8=48  7x8=56  8x8=64</span><br><span class="line">1x9=9   2x9=18  3x9=27  4x9=36  5x9=45  6x9=54  7x9=63  8x9=72  9x9=81</span><br></pre></td></tr></table></figure><blockquote><p>参考链接:<br><a href="https://coolshell.cn/articles/9070.html" target="_blank" rel="noopener">AWK 简明教程</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;&lt;strong&gt;awk&lt;/strong&gt;其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="awk" scheme="https://annecoding.github.io/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>hexo图片显示问题</title>
    <link href="https://annecoding.github.io/2019/05/20/hexo%20img%20403/"/>
    <id>https://annecoding.github.io/2019/05/20/hexo img 403/</id>
    <published>2019-05-20T03:19:37.000Z</published>
    <updated>2019-07-25T00:08:26.530Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>解决markdown图片不显示，返回403 forbidden。</p><a id="more"></a><p>在文章中引用外链图片时不显示，但是本身外链（图床）图片又是可以打开的，错误如下图所示：<br><img src="http://images2015.cnblogs.com/blog/415042/201604/415042-20160419175110210-69232656.png" alt></p><p><img src="http://www.manongjc.com/images/cnblogs/153579233815357B3A9v2338.png" alt><br>只需要在文件头部添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>关于meta referrer，有如下可设置的值：<br><img src="https://images2017.cnblogs.com/blog/985078/201802/985078-20180208084932873-358057556.png" alt></p><blockquote><p>参考链接如下：<br><a href="https://github.com/xcodebuild/hexo-asset-image" target="_blank" rel="noopener">关于hexo-asset-image</a><br><a href="http://www.manongjc.com/article/9294.html" target="_blank" rel="noopener">hexo图片不显示</a><br><a href="https://www.cnblogs.com/awzf/p/9811386.html" target="_blank" rel="noopener">img标签forbidden问题</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;解决markdown图片不显示，返回403 forbidden。&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://annecoding.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://annecoding.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>linux下项目上线流程</title>
    <link href="https://annecoding.github.io/2019/05/15/%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E6%B5%81%E7%A8%8B/"/>
    <id>https://annecoding.github.io/2019/05/15/项目上线流程/</id>
    <published>2019-05-15T07:48:23.317Z</published>
    <updated>2019-07-28T01:43:11.512Z</updated>
    
    <content type="html"><![CDATA[<p>项目上线流程</p><p>1.选择服务器，比如CentOS、ubuntu等。</p><p>2.选择Web服务器，比如Nginx、Apache、Tomcat等。</p><p>3.独立域名购买，比如阿里云、腾讯云等。<br><a id="more"></a></p><h3 id="web服务器构建"><a href="#web服务器构建" class="headerlink" title="web服务器构建"></a>web服务器构建</h3><p>linux下安装nginx，yum下没有nginx源，在epel-release下有<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先安装epel-release源</span></span><br><span class="line">yum install epel-release</span><br><span class="line"><span class="comment"># 安装nginx</span></span><br><span class="line">yum install nginx</span><br></pre></td></tr></table></figure></p><p>可输入下面命令查看是否安装成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br></pre></td></tr></table></figure></p><p>安装编辑器vim<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install vim</span><br></pre></td></tr></table></figure></p><p>安装scp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install openssh-client</span><br></pre></td></tr></table></figure></p><h3 id="网站上传到服务器"><a href="#网站上传到服务器" class="headerlink" title="网站上传到服务器"></a>网站上传到服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># local_dir为本地目录数据</span></span><br><span class="line">scp -r local_dir user@ip:/remote_dir</span><br><span class="line"><span class="comment"># 示例如下  当下目录所有数据上传到远程目录/root/www</span></span><br><span class="line">scp -r ./* root@ip:/root/www</span><br></pre></td></tr></table></figure><h3 id="域名购买及解析-阿里云直接用新手引导"><a href="#域名购买及解析-阿里云直接用新手引导" class="headerlink" title="域名购买及解析(阿里云直接用新手引导)"></a>域名购买及解析(阿里云直接用新手引导)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">添加www和@记录</span><br><span class="line"></span><br><span class="line">记录值：公网IP地址</span><br></pre></td></tr></table></figure><p>如以上操作步骤无误，便可根据购买的域名访问相关网站。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目上线流程&lt;/p&gt;
&lt;p&gt;1.选择服务器，比如CentOS、ubuntu等。&lt;/p&gt;
&lt;p&gt;2.选择Web服务器，比如Nginx、Apache、Tomcat等。&lt;/p&gt;
&lt;p&gt;3.独立域名购买，比如阿里云、腾讯云等。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Centos" scheme="https://annecoding.github.io/tags/Centos/"/>
    
  </entry>
  
</feed>
