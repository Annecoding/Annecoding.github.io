<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://annecoding.github.io/"/>
  <updated>2020-03-01T11:02:18.759Z</updated>
  <id>https://annecoding.github.io/</id>
  
  <author>
    <name>Annecoding&#39;s</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux下实现SSH免密登录并禁止密码登录</title>
    <link href="https://annecoding.github.io/2020/01/20/linux%E4%B8%8Bssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
    <id>https://annecoding.github.io/2020/01/20/linux下ssh免密登录/</id>
    <published>2020-01-20T10:03:13.000Z</published>
    <updated>2020-03-01T11:02:18.759Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>在远程管理linux系统基本上都要使用到<strong>SSH</strong>，原因很简单：<strong>Telnet</strong>、<strong>FTP</strong>等传输方式是‍以明文传送用户认证信息，本质上是<strong>不安全的</strong>，存在被网络窃听的危险。</p><p><strong>SSH（Secure Shell）</strong>目前较可靠，是专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题，透过<strong>SSH可以对所有传输的数据进行加密</strong>，也能够防止DNS欺骗和IP欺骗。</p><a id="more"></a><h3 id="1-生成秘钥"><a href="#1-生成秘钥" class="headerlink" title="1.生成秘钥"></a>1.生成秘钥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>默认会在用户目录下生成一个公钥和私钥</p><h3 id="2-将公钥设置为该服务器的登录公钥"><a href="#2-将公钥设置为该服务器的登录公钥" class="headerlink" title="2.将公钥设置为该服务器的登录公钥"></a>2.将公钥设置为该服务器的登录公钥</h3><ul><li><code>.ssh</code> 目录的权限必须是0700</li><li><code>.ssh/authorized_keys</code> 文件权限必须是0600</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line"><span class="comment"># 权限设为600</span></span><br><span class="line">$ sudo chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h3 id="3-设置ssh，禁止密码登录，改用私钥登录"><a href="#3-设置ssh，禁止密码登录，改用私钥登录" class="headerlink" title="3.设置ssh，禁止密码登录，改用私钥登录"></a>3.设置ssh，禁止密码登录，改用私钥登录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/ssh/sshd_config</span><br><span class="line">StrictModes no <span class="comment">#这个选项会自动的把 想要登录的机器的SSH pub key 添加到 /root/.ssh/know_hosts 中。</span></span><br><span class="line">RSAAuthentication yes    <span class="comment"># 启用 RSA 认证，默认为yes</span></span><br><span class="line">PubkeyAuthentication yes   <span class="comment"># 启用公钥认证，默认为yes</span></span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys <span class="comment"># PublicKey文件路径</span></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcejv7ov5sj30t809yjt6.jpg" alt="7399690D-B02C-4B4B-9E85-2D41EBBF3C4B"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PasswordAuthentication no <span class="comment"># 禁止密码验证登录</span></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcejwdi3bhj30z603241v.jpg" alt="image-20200301172259183"></p><h3 id="4-重启ssh服务"><a href="#4-重启ssh服务" class="headerlink" title="4.重启ssh服务"></a>4.重启ssh服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart sshd.service</span><br><span class="line">$ service sshd restart</span><br><span class="line"><span class="comment"># ubuntu1 14.04</span></span><br><span class="line">$ service ssh restart</span><br></pre></td></tr></table></figure><h3 id="5-使用公钥登录"><a href="#5-使用公钥登录" class="headerlink" title="5.使用公钥登录"></a>5.使用公钥登录</h3><p>下载公钥id_rsa.pub，到要登录服务器的客户端，在使用SecureCRT、xShell等工具登录的时候选择该公钥登录即可。</p><h3 id="6-补充"><a href="#6-补充" class="headerlink" title="6.补充"></a>6.补充</h3><p>关于免密登录失败，可尝试以下方式。</p><p>1.StrictModes配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/ssh/sshd_config</span><br><span class="line">StrictModes no</span><br></pre></td></tr></table></figure><p>修改为no,默认为yes.如果不修改用key登陆是出现server refused our key（如果StrictModes为yes必需保证存放公钥的文件夹的拥有与登陆用户名是相同的）。</p><p>“StrictModes”设置ssh在接收登录请求之前是否检查用户家目录和rhosts文件的权限和所有权。</p><p>2.StrictHostKeyChecking配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/ssh/sshd_config</span><br><span class="line"><span class="comment"># StrictHostKeyChecking ask 修改为 </span></span><br><span class="line">StrictHostKeyChecking no</span><br></pre></td></tr></table></figure><p><code>StrictHostKeyChecking</code>如果设为<code>no</code>，这个选项会自动的把想要登录的机器的<code>SSH pub key</code> 添加到<code>/root/.ssh/know_hosts</code>中。</p><p><code>StrictHostKeyChecking</code>如果设为<code>yes</code>，ssh将不会自动把计算机的密匙加入<code>$HOME/.ssh/known_hosts</code>文件，且一旦计算机的密匙发生了变化，就拒绝连接。</p><p><strong>ssh连接的认证原理</strong></p><p>公钥：用于加密，存在于服务器<br>私钥：用于解密，存在于客户机</p><p><strong>认证流程：</strong></p><p>1.客户端向服务器发出连接请求<br>2.服务器查看客户端公钥（~/.ssh/authorized_keys）该客户机（客户机标志：用户@Host）对应的公钥<br>3.服务器验证公钥合法，则产生一条随机数（challenge），用公钥加密发送给客户端<br>4.客户端用私钥解密回传服务器端<br>5.随机数一致，认证通过</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;在远程管理linux系统基本上都要使用到&lt;strong&gt;SSH&lt;/strong&gt;，原因很简单：&lt;strong&gt;Telnet&lt;/strong&gt;、&lt;strong&gt;FTP&lt;/strong&gt;等传输方式是‍以明文传送用户认证信息，本质上是&lt;strong&gt;不安全的&lt;/strong&gt;，存在被网络窃听的危险。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SSH（Secure Shell）&lt;/strong&gt;目前较可靠，是专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题，透过&lt;strong&gt;SSH可以对所有传输的数据进行加密&lt;/strong&gt;，也能够防止DNS欺骗和IP欺骗。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu中ufw防火墙配置</title>
    <link href="https://annecoding.github.io/2019/11/23/ubuntu%E4%B8%ADufw%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/"/>
    <id>https://annecoding.github.io/2019/11/23/ubuntu中ufw防火墙配置/</id>
    <published>2019-11-23T06:39:44.000Z</published>
    <updated>2019-11-23T07:48:20.256Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>UFW，即简单防火墙（uncomplicated firewall），是一个 Arch Linux、Debian 或 Ubuntu 中管理防火墙规则的前端。 UFW 通过命令行使用（尽管它有可用的 GUI），它的目的是使防火墙配置简单。</p><a id="more"></a><h2 id="在-Ubuntu-中用-UFW-配置防火墙"><a href="#在-Ubuntu-中用-UFW-配置防火墙" class="headerlink" title="在 Ubuntu 中用 UFW 配置防火墙"></a><strong>在 Ubuntu 中用 UFW 配置防火墙</strong></h2><h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a><strong>开始之前</strong></h3><p>1.设置时间同步</p><p>你可以使用命令验证是否启用了时间同步：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ timedatectl</span><br><span class="line">      Local time: Sat 2019-11-23 14:06:08 CST</span><br><span class="line">  Universal time: Sat 2019-11-23 06:06:08 UTC</span><br><span class="line">        RTC time: Sat 2019-11-23 14:06:07</span><br><span class="line">       Time zone: Asia/Shanghai (CST, +0800)</span><br><span class="line">     NTP enabled: yes</span><br><span class="line">NTP synchronized: yes</span><br><span class="line"> RTC <span class="keyword">in</span> <span class="built_in">local</span> TZ: yes</span><br><span class="line">      DST active: n/a</span><br></pre></td></tr></table></figure><p>2.查看时区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/timezone</span><br></pre></td></tr></table></figure><p>3.你可以使用以下命令设置所需的时区（例如，Asia/Shanghai）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo timedatectl <span class="built_in">set</span>-timezone Asia/Shanghai</span><br></pre></td></tr></table></figure><p>4.使用 date 命令再次检查时区是否已真正更改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date</span><br><span class="line">Tue Nov 19 15:20:18 CST 2019</span><br></pre></td></tr></table></figure><p>2、 更新系统</p><p><strong>Arch Linux</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syu</span><br></pre></td></tr></table></figure><p><strong>Debian / Ubuntu</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h3 id="安装-UFW"><a href="#安装-UFW" class="headerlink" title="安装 UFW"></a><strong>安装 UFW</strong></h3><p>UFW 默认包含在 Ubuntu 中，但在 Arch 和 Debian 中需要安装。 Debian 将自动启用 UFW 的 systemd 单元，并使其在重新启动时启动，但 Arch 不会。 这与告诉 UFW 启用防火墙规则不同，因为使用 systemd 或者 upstart 启用 UFW 仅仅是告知 init 系统打开 UFW 守护程序。</p><p>默认情况下，UFW 的规则集为空，因此即使守护程序正在运行，也不会强制执行任何防火墙规则。 </p><h4 id="Arch-Linux"><a href="#Arch-Linux" class="headerlink" title="Arch Linux"></a><strong>Arch Linux</strong></h4><p>1.安装 UFW：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S ufw</span><br></pre></td></tr></table></figure><p>2.启动并启用 UFW 的 systemd 单元：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start ufw</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> ufw</span><br></pre></td></tr></table></figure><h4 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian / Ubuntu"></a><strong>Debian / Ubuntu</strong></h4><p>1.安装 UFW</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ufw</span><br></pre></td></tr></table></figure><p>2.开启防火墙并以后开机运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw <span class="built_in">enable</span></span><br></pre></td></tr></table></figure><p>3.查看防火墙状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw status</span><br></pre></td></tr></table></figure><h3 id="使用-UFW-管理防火墙规则"><a href="#使用-UFW-管理防火墙规则" class="headerlink" title="使用 UFW 管理防火墙规则"></a><strong>使用 UFW 管理防火墙规则</strong></h3><h4 id="添加规则"><a href="#添加规则" class="headerlink" title="添加规则"></a><strong>添加规则</strong></h4><p>可以有两种方式添加规则：用<strong>端口号</strong>或者<strong>服务名</strong>表示。</p><p>要允许 SSH 的 22 端口的传入和传出连接，你可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow ssh</span><br></pre></td></tr></table></figure><p>你也可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow 22</span><br></pre></td></tr></table></figure><p>相似的，要在特定端口（比如 111）上 deny 流量，你需要运行： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw deny 111</span><br></pre></td></tr></table></figure><p>为了更好地调整你的规则，你也可以允许基于 TCP 或者 UDP 的包。下面例子会允许 80 端口的 TCP 包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow 80/tcp</span><br><span class="line">sudo ufw allow http/tcp</span><br></pre></td></tr></table></figure><p>这个会允许 1725 端口上的 UDP 包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow 1725/udp</span><br></pre></td></tr></table></figure><h4 id="高级规则"><a href="#高级规则" class="headerlink" title="高级规则"></a><strong>高级规则</strong></h4><p>除了基于端口的允许或阻止，UFW 还允许您按照 IP 地址、子网和 IP 地址/子网/端口的组合来允许/阻止。</p><p>允许从一个 IP 地址连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow from 123.45.67.89</span><br></pre></td></tr></table></figure><p>允许特定子网的连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow from 123.45.67.89/24</span><br></pre></td></tr></table></figure><p>允许特定 IP/ 端口的组合：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow from 123.45.67.89 to any port 22 proto tcp</span><br></pre></td></tr></table></figure><p>proto tcp 可以删除或者根据你的需求改成 proto udp，所有例子的 allow 都可以根据需要变成 deny。 </p><p>批量tcp端口开放</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow proto tcp from any to any port 80,443,1935,7443</span><br></pre></td></tr></table></figure><p>批量udp端口开放</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw  allow proto udp  from any to any port 16384:32768</span><br></pre></td></tr></table></figure><h4 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a><strong>删除规则</strong></h4><p>要删除一条规则，在规则的前面加上 delete。如果你希望不再允许 HTTP 流量，你可以运行： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw delete allow 80</span><br></pre></td></tr></table></figure><p>删除规则同样可以使用服务名。</p><h3 id="编辑-UFW-的配置文件"><a href="#编辑-UFW-的配置文件" class="headerlink" title="编辑 UFW 的配置文件"></a><strong>编辑 UFW 的配置文件</strong></h3><p>虽然可以通过命令行添加简单的规则，但仍有可能需要添加或删除更高级或特定的规则。 在运行通过终端输入的规则之前，UFW 将运行一个文件<code>before.rules</code>，它允许回环接口、ping 和 DHCP 等服务。要添加或改变这些规则，编辑 <code>/etc/ufw/before.rules</code> 这个文件。 同一目录中的 <code>before6.rules</code>文件用于 IPv6 。 </p><p>还存在一个<code>after.rule</code> 和 <code>after6.rule</code> 文件，用于添加在 UFW 运行你通过命令行输入的规则之后需要添加的任何规则。 </p><p>还有一个配置文件位于 <code>/etc/default/ufw</code>。 从此处可以禁用或启用 IPv6，可以设置默认规则，并可以设置 UFW 以管理内置防火墙链。 </p><h3 id="UFW-状态"><a href="#UFW-状态" class="headerlink" title="UFW 状态"></a><strong>UFW 状态</strong></h3><p>你可以在任何时候使用命令：<code>sudo ufw status</code>查看 UFW 的状态。这会显示所有规则列表，以及 UFW 是否处于激活状态： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Status: activeTo             Action   From</span><br><span class="line"></span><br><span class="line">--             ------   ----22             ALLOW    Anywhere80/tcp           ALLOW    Anywhere443            ALLOW    Anywhere22 (v6)          ALLOW    Anywhere (v6)80/tcp (v6)        ALLOW    Anywhere (v6)443 (v6)          ALLOW    Anywhere (v6)</span><br></pre></td></tr></table></figure><h3 id="启用防火墙"><a href="#启用防火墙" class="headerlink" title="启用防火墙"></a><strong>启用防火墙</strong></h3><p>随着你选择规则完成，你初始运行 ufw status 可能会输出 Status: inactive。 启用 UFW 并强制执行防火墙规则： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw <span class="built_in">enable</span></span><br></pre></td></tr></table></figure><p>相似地，禁用 UFW 规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw <span class="built_in">disable</span></span><br></pre></td></tr></table></figure><blockquote><p>UFW 会继续运行，并且在下次启动时会再次启动。</p></blockquote><h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a><strong>日志记录</strong></h3><p>你可以用下面的命令启动日志记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw logging on</span><br></pre></td></tr></table></figure><p>可以通过运行 <code>sudo ufw logging low|medium|high</code> 设计日志级别，可以选择 low、 medium 或者 high。默认级别是 low。 </p><p>常规日志类似于下面这样，位于<code>/var/logs/ufw</code>： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sep 16 15:08:14 &lt;hostname&gt; kernel: [UFW BLOCK] IN=eth0 OUT= MAC=00:00:00:00:00:00:00:00:00:00:00:00:00:00 SRC=123.45.67.89 DST=987.65.43.21 LEN=40 TOS=0x00 PREC=0x00 TTL=249 ID=8475 PROTO=TCP SPT=48247 DPT=22 WINDOW=1024 RES=0x00 SYN URGP=0</span><br></pre></td></tr></table></figure><p>前面的值列出了你的服务器的日期、时间、主机名。剩下的重要信息包括：</p><ul><li><strong>[UFW BLOCK]</strong>：这是记录事件的描述开始的位置。在此例中，它表示阻止了连接。</li><li><strong>IN</strong>：如果它包含一个值，那么代表该事件是传入事件</li><li><strong>OUT</strong>：如果它包含一个值，那么代表事件是传出事件</li><li><strong>MAC</strong>：目的地和源 MAC 地址的组合</li><li><strong>SRC</strong>：包源的 IP</li><li><strong>DST</strong>：包目的地的 IP</li><li><strong>LEN</strong>：数据包长度</li><li><strong>TTL</strong>：数据包 TTL，或称为 time to live。 在找到目的地之前，它将在路由器之间跳跃，直到它过期。</li><li><strong>PROTO</strong>：数据包的协议</li><li><strong>SPT</strong>：包的源端口</li><li><strong>DPT</strong>：包的目标端口</li><li><strong>WINDOW</strong>：发送方可以接收的数据包的大小</li><li><strong>SYN URGP</strong>：指示是否需要三次握手。 0 表示不需要。 </li></ul><ul><li>参考链接：<a href="http://www.imooc.com/article/258699" target="_blank" rel="noopener">在 Ubuntu 中用 UFW 配置防火墙</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;UFW，即简单防火墙（uncomplicated firewall），是一个 Arch Linux、Debian 或 Ubuntu 中管理防火墙规则的前端。 UFW 通过命令行使用（尽管它有可用的 GUI），它的目的是使防火墙配置简单。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://annecoding.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu拉黑ssh恶意连接地址</title>
    <link href="https://annecoding.github.io/2019/11/23/ubuntu%E6%8B%89%E9%BB%91ssh%E6%81%B6%E6%84%8F%E8%BF%9E%E6%8E%A5%E5%9C%B0%E5%9D%80/"/>
    <id>https://annecoding.github.io/2019/11/23/ubuntu拉黑ssh恶意连接地址/</id>
    <published>2019-11-23T06:38:52.000Z</published>
    <updated>2019-11-23T06:59:13.609Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>对于linux下通过ssh远程攻击的恶意ip，首先我们需要分析服务器资源占用情况，然后要找出是谁在连接本服务器，其次查看其连接方式。</p><a id="more"></a><p>最后，我们可以使用本机防火墙结合相关策略等来拉黑相关ip地址。</p><p>实现脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ vim /home/ubuntu/shell/secure_ssh.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">cat /var/<span class="built_in">log</span>/auth.log|awk <span class="string">'/Failed/&#123;print $(NF-3)&#125;'</span>|sort|uniq -c|awk <span class="string">'&#123;print $2"="$1;&#125;'</span> &gt; /tmp/blackIP.txt</span><br><span class="line">TRYCOUNT=<span class="string">"5"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `cat /tmp/blackIP.txt`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        IP=`<span class="built_in">echo</span> <span class="variable">$i</span> |awk -F= <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line">        NUM=`<span class="built_in">echo</span> <span class="variable">$i</span>|awk -F= <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$NUM</span> -gt <span class="variable">$TRYCOUNT</span> ];</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">                grep <span class="variable">$IP</span> /etc/hosts.deny &gt; /dev/null</span><br><span class="line">                <span class="keyword">if</span> [ $? -gt 0 ];</span><br><span class="line">                <span class="keyword">then</span></span><br><span class="line">                        <span class="built_in">echo</span> <span class="string">"ALL:<span class="variable">$IP</span>:deny"</span> &gt;&gt; /etc/hosts.deny</span><br><span class="line">                <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>添加定时任务</strong></p><p>添加为定时脚本,每分钟执行一次，选第4个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"><span class="comment"># 添加如下一行</span></span><br><span class="line">*/1 * * * * sh /home/ubuntu/shell/secure_ssh.sh</span><br></pre></td></tr></table></figure><p> <strong>开启日志</strong></p><p>cron日志，这里记录一下如何ubuntu server如何查看crontab日志</p><p>crontab记录日志</p><p>修改rsyslog</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/rsyslog.d/50-default.conf</span><br></pre></td></tr></table></figure><p>找到<code>cron.* /var/log/cron.log</code> #将cron前面的注释符去掉</p><p>重启rsyslog</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service rsyslog restart</span><br></pre></td></tr></table></figure><p><strong>查看日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tail -100f /var/mail/root </span></span><br><span class="line">tail -f /var/<span class="built_in">log</span>/cron.log</span><br></pre></td></tr></table></figure><p><strong>查看拉黑的ip</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo less /etc/hosts.deny</span><br></pre></td></tr></table></figure><p><strong>查看网络连接ip并倒序排序</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/<span class="built_in">log</span>/auth.log|awk <span class="string">'/Failed/&#123;print $(NF-3)&#125;'</span>|sort |uniq -c | sort -k1nr</span><br></pre></td></tr></table></figure><p><strong>查看连接客户端ip</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntu | awk <span class="string">'&#123;print $5&#125;'</span> | cut -d: -f1 | sort | uniq -c</span><br></pre></td></tr></table></figure><blockquote><p>参考链接：<a href="https://www.cnblogs.com/passedbylove/p/7517910.html" target="_blank" rel="noopener">ubuntu自动拉黑破解ssh服务的IP</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;对于linux下通过ssh远程攻击的恶意ip，首先我们需要分析服务器资源占用情况，然后要找出是谁在连接本服务器，其次查看其连接方式。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://annecoding.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Annecoding&#39;s Studio.</title>
    <link href="https://annecoding.github.io/2019/11/21/%E7%AB%99%E7%82%B9%E7%9B%AE%E5%BD%95/"/>
    <id>https://annecoding.github.io/2019/11/21/站点目录/</id>
    <published>2019-11-21T03:37:57.000Z</published>
    <updated>2019-11-27T08:31:42.997Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>本站点目录所有系列基本由浅入深，方便个人进行知识梳理亦欢迎指教。本站内容及本目录将持续更新，敬请期待！</p><a id="more"></a><h2 id="本站目录"><a href="#本站目录" class="headerlink" title="本站目录"></a>本站目录</h2><h3 id="linux入门系列"><a href="#linux入门系列" class="headerlink" title="linux入门系列"></a>linux入门系列</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ul><li><a href="https://annecoding.github.io/2019/03/24/linux基础/">linux基础精选系列</a></li><li><a href="https://annecoding.github.io/2019/03/25/Linux学习笔记/">Linux个人学习笔记整理</a></li><li><a href="https://annecoding.github.io/2019/03/27/linux常用命令/">linux常用命令整理·精选</a></li><li><a href="https://annecoding.github.io/2019/03/23/rpm命令/">rpm命令使用</a></li></ul><h4 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h4><ul><li><a href="https://annecoding.github.io/2019/03/22/linxu下vi编辑器的使用/">生产环境下最快速学会vi编辑器的使用</a></li><li><a href="https://annecoding.github.io/2019/03/22/linxu下vi编辑器的配置/">linxu下vi编辑器的配置</a></li></ul><h4 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h4><ul><li><a href="https://annecoding.github.io/2019/03/18/linux_centos网卡配置/">centos网卡配置</a></li><li><a href="https://annecoding.github.io/2019/07/20/ubuntu修改IP地址/">ubuntu修改IP地址</a></li></ul><h4 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h4><ul><li><a href="https://annecoding.github.io/2019/03/18/linux%E7%AB%AF%E5%8F%A3%E5%BC%80%E6%94%BE/">linux系统下端口的开放</a></li><li><a href="https://annecoding.github.io/2019/11/23/ubuntu中ufw防火墙配置/">ubuntu中ufw防火墙配置</a></li></ul><h4 id="项目实施"><a href="#项目实施" class="headerlink" title="项目实施"></a>项目实施</h4><ul><li><a href="https://annecoding.github.io/2019/03/18/linux_nodejs%E5%AE%89%E8%A3%85/">linux下最详细安装nodejs及配置</a></li><li><a href="https://annecoding.github.io/2019/03/19/nginx%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/">Linux系统Nginx安装及反向代理配置</a></li><li><a href="https://annecoding.github.io/2019/05/15/项目上线流程/">linux下项目上线流程</a></li><li><a href="https://annecoding.github.io/2019/08/22/Centos使用mailx告警邮件配置/">Centos使用mailx告警邮件配置</a></li></ul><h3 id="linux进阶学习"><a href="#linux进阶学习" class="headerlink" title="linux进阶学习"></a>linux进阶学习</h3><h4 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h4><ul><li><a href="https://annecoding.github.io/2019/07/20/linux系统扫描命令和安全防范笔记/">linux系统扫描命令和安全防范笔记</a></li><li><a href="https://annecoding.github.io/2019/05/13/ubuntu允许root远程ssh访问/">ubuntu允许root远程ssh访问</a></li></ul><h4 id="shell知识碎片"><a href="#shell知识碎片" class="headerlink" title="shell知识碎片"></a>shell知识碎片</h4><ul><li><a href="https://annecoding.github.io/2019/06/10/linux中玩转awk/">linux中玩转awk技巧分享</a></li><li><a href="https://annecoding.github.io/2019/06/11/linux中玩转sed/">linux中玩转sed技巧分享</a></li><li><a href="https://annecoding.github.io/2019/08/13/shell中切分文件名和扩展名/">shell中切分文件名和扩展名</a></li></ul><h4 id="shell实例"><a href="#shell实例" class="headerlink" title="shell实例"></a>shell实例</h4><ul><li><a href="https://annecoding.github.io/2019/05/15/shell脚本练习/">shell脚本实例入门精选系列</a></li><li><a href="https://annecoding.github.io/2019/06/15/linux下占用cpu和内存很高的进程/">linux下占用cpu和内存top10</a></li><li><a href="https://annecoding.github.io/2019/08/30/linux查看网卡实时流量/">linux查看网卡实时流量</a></li><li><a href="https://annecoding.github.io/2019/07/25/监控多台服务器利用率/">监控多台服务器利用率</a></li><li><a href="https://annecoding.github.io/2019/08/28/shell脚本实现centos系统初始化配置/">shell脚本实现centos系统初始化配置</a></li><li><a href="https://annecoding.github.io/2019/08/29/批量创建用户并设置随机密码/">批量创建用户并设置随机密码</a></li><li><a href="https://annecoding.github.io/2019/08/29/一键查看服务器资源利用率/">一键查看服务器资源利用率</a></li><li><a href="https://annecoding.github.io/2019/09/04/linux使用expect批量执行主机命令/">linux使用expect批量执行主机命令</a></li><li><a href="https://annecoding.github.io/2019/09/23/nginx访问日志分析/">nginx访问日志分析</a></li><li><a href="https://annecoding.github.io/2019/11/23/ubuntu拉黑ssh恶意连接地址/">ubuntu拉黑ssh恶意连接地址</a></li></ul><h3 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h3><ul><li><a href="https://annecoding.github.io/2019/03/18/git使用/">Git命令的使用及总结</a></li></ul><h3 id="Docker部署系列"><a href="#Docker部署系列" class="headerlink" title="Docker部署系列"></a>Docker部署系列</h3><ul><li><a href="https://annecoding.github.io/2019/03/19/docker安装jenkins/#利用Docker来部署jenkins的部署过程">利用Docker来部署jenkins的部署过程</a></li></ul><h3 id="Vue学习系列"><a href="#Vue学习系列" class="headerlink" title="Vue学习系列"></a>Vue学习系列</h3><ul><li><a href="https://annecoding.github.io/2019/03/21/vue学习/">vue.js初使用</a></li><li><a href="https://annecoding.github.io/2019/04/16/vue组件/">vue组件学习</a></li><li><a href="https://annecoding.github.io/2019/04/16/vue路由/">vue路由学习</a></li><li><a href="https://annecoding.github.io/2019/04/17/vue-blog项目/">vue-myblog项目实现</a></li><li><a href="https://annecoding.github.io/2019/04/25/vcustomers_demo/">Vue后台用户管理系统</a></li></ul><h3 id="Mac使用系列"><a href="#Mac使用系列" class="headerlink" title="Mac使用系列"></a>Mac使用系列</h3><ul><li><a href="https://annecoding.github.io/2019/10/15/Mac下实用工具推荐/">Mac下实用工具推荐</a></li><li><a href="https://annecoding.github.io/2019/07/20/linux安装hping添加环境变量/">Linux安装hping添加环境变量</a></li><li><a href="https://annecoding.github.io/2019/07/24/mtr网络分析工具安装/">mtr网络分析工具安装</a></li></ul><h3 id="Hexo使用系列"><a href="#Hexo使用系列" class="headerlink" title="Hexo使用系列"></a>Hexo使用系列</h3><ul><li><a href="https://annecoding.github.io/2019/05/20/hexo img 403/">hexo图片显示问题</a></li><li><a href="https://annecoding.github.io/2019/07/11/hexo文章置顶/">hexo文章置顶</a></li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><ul><li><a href="https://annecoding.github.io/2019/08/03/站外学习平台及实用工具推荐/">Learning Platform Utilities Recommended</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;本站点目录所有系列基本由浅入深，方便个人进行知识梳理亦欢迎指教。本站内容及本目录将持续更新，敬请期待！&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Mac下实用工具推荐</title>
    <link href="https://annecoding.github.io/2019/10/15/Mac%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    <id>https://annecoding.github.io/2019/10/15/Mac下实用工具推荐/</id>
    <published>2019-10-15T06:38:20.000Z</published>
    <updated>2019-11-23T06:57:40.156Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>Mac上好用的软件推荐</p><a id="more"></a><table><thead><tr><th>软件名称</th><th>软件描述</th></tr></thead><tbody><tr><td>iTerm</td><td>一个强大的终端</td></tr><tr><td>印象笔记</td><td>书签剪藏、支持markdown等等等强大到无往不利</td></tr><tr><td>onenote</td><td>很好用的笔记软件，可惜我的印象笔记先入为主啦</td></tr><tr><td>CheatSheet</td><td>快键键提示</td></tr><tr><td>iPic PicGo</td><td>上传图片</td></tr><tr><td>Typora markdown</td><td>写作实时渲染</td></tr><tr><td>Sublime</td><td>这个全平台神器就不说了吧</td></tr><tr><td>Visual Studio Code</td><td>有本事高颜值</td></tr><tr><td>OmniDiskSweeper</td><td>查看mac空间占用</td></tr><tr><td>DaisyDisk</td><td>图形化磁盘清理界面 需要破解</td></tr><tr><td>LastPass</td><td>浏览器插件 密码保存神器</td></tr><tr><td>Agenda</td><td>日程管理、笔记整理</td></tr><tr><td>e-zip</td><td>全能解压缩神器</td></tr><tr><td>Parallels Client</td><td>远程连接软件</td></tr><tr><td>Parallels Desktop</td><td>虚拟机软件</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;Mac上好用的软件推荐&lt;/p&gt;
    
    </summary>
    
      <category term="Mac" scheme="https://annecoding.github.io/categories/Mac/"/>
    
    
      <category term="Mac" scheme="https://annecoding.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>nginx访问日志分析</title>
    <link href="https://annecoding.github.io/2019/09/23/nginx%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"/>
    <id>https://annecoding.github.io/2019/09/23/nginx访问日志分析/</id>
    <published>2019-09-23T08:42:34.000Z</published>
    <updated>2019-09-25T06:55:47.320Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p><strong>nginx</strong>的log日志分为<strong>access log</strong>和<strong>error log</strong>。其中<strong>access log</strong>记录了哪些用户，哪些页面以及用户浏览器、ip和其他的访问信息。<strong>error log</strong>则是记录服务器错误日志。</p><a id="more"></a><h3 id="nginx日志格式配置"><a href="#nginx日志格式配置" class="headerlink" title="nginx日志格式配置"></a>nginx日志格式配置</h3><p>在nginx的<strong>nginx.conf</strong>配置文件找到：<strong>log_format</strong> 这里就是日志的格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                  <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                  <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br></pre></td></tr></table></figure><p><strong>常见的日志变量</strong></p><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>$remote_addr,$http_x_forwarded_for</td><td>记录客户端IP地址</td></tr><tr><td>$remote_user</td><td>记录客户端用户名称，默认为空</td></tr><tr><td>$request</td><td>记录请求的URL和HTTP协议(GET,POST,DEL等)</td></tr><tr><td>$time_local</td><td>通用日志格式下的本地时间，记录访问时间</td></tr><tr><td>$status</td><td>记录请求状态</td></tr><tr><td>$body_bytes_sent</td><td>发送给客户端的字节数，不包括响应头的大小，该变量与Apache模块mod_log_config里的“%B”参数兼容。</td></tr><tr><td>$http_referer</td><td>记录从哪个页面链接访问过来的</td></tr><tr><td>$http_user_agent</td><td>记录客户端浏览器相关信息</td></tr><tr><td>$http_x_forwarded_for</td><td>当前端有代理服务器时，设置web节点记录客户端地址的配置，此参数生效的前提是代理服务器也要进行相关的http_x_forwarded_for设置</td></tr><tr><td>$bytes_sent</td><td>发送给客户端的总字节数</td></tr><tr><td>$connection</td><td>连接的序列号</td></tr><tr><td>$connection_requests</td><td>当前通过一个连接获得的请求数量</td></tr><tr><td>$msec</td><td>日志写入时间，单位为秒，精度是毫秒</td></tr><tr><td>$pipe</td><td>如果请求是通过HTTP流水线(pipelined)发送，pipe值为“p”，否则为“.”</td></tr><tr><td>$http_host</td><td>请求地址，即浏览器中你输入的地址（IP或域名）</td></tr><tr><td>$request_body</td><td>记录POST数据</td></tr><tr><td>$request_length</td><td>请求的长度（包括请求行，请求头和请求正文）</td></tr><tr><td>$request_time</td><td>请求处理时间，单位为秒，精度毫秒，从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止</td></tr><tr><td>$time_iso8601</td><td>ISO8601标准格式下的本地时间</td></tr><tr><td>$upstream_status</td><td>upstream状态，成功是200</td></tr><tr><td>$upstream_addr</td><td>后台upstream的地址，即真正提供服务的主机地址</td></tr><tr><td>$upstream_response_time</td><td>请求过程中，upstream响应时间</td></tr></tbody></table><p><strong>access日志格式如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">111.222.222.222 - - [16/Apr/2018:16:18:15 +0800] <span class="string">"GET / HTTP/1.1"</span> 200 612 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36"</span></span><br><span class="line">111.222.222.222 - - [16/Apr/2018:16:18:16 +0800] <span class="string">"GET /favicon.ico HTTP/1.1"</span> 404 571 <span class="string">"http://39.107.204.206/"</span> <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36"</span></span><br></pre></td></tr></table></figure><p>1.客户端（用户）IP地址<br>2.访问时间<br>3.请求的url（目标url地址）的host和http协议<br>4.请求状态(状态码，200表示成功，404表示页面不存在，301表示永久重定向等)<br>5.请求页面大小，默认为B（byte）<br>6.来源页面，即从哪个页面转到本页，专业名称叫做“referer”<br>7.用户浏览器的其他信息，浏览器版本、浏览器类型等</p><h3 id="常用日志分析示例"><a href="#常用日志分析示例" class="headerlink" title="常用日志分析示例"></a>常用日志分析示例</h3><p>1.根据IP地址统计访问页码状态码数量TOP5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据IP地址、状态码和访问路径统计并排序找出top5</span></span><br><span class="line">$ awk <span class="string">'&#123;a[$1" "$7" "$9]++&#125;END&#123;for(v in a)&#123;if(a[v]&gt;10)print v,a[v]&#125;&#125;'</span> access.log | sort -k4 -nr | head -5</span><br><span class="line">185.234.217.54 /user/index.jsp 302 96701</span><br><span class="line">222.165.230.7 /user/index.jsp 302 76652</span><br><span class="line">210.27.176.184 /wls-wsat/index.jsp 302 45952</span><br><span class="line">61.162.236.77 /cgi-bin/index.jsp 302 2733</span><br></pre></td></tr></table></figure><p>2.根据时间段统计访问最多的IP地址TOP5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'$4&gt;="[16/Apr/2018:16:43:16" &amp;&amp; $4&lt;="[16/Apr/2018:22:43:16" &#123;a[$1]++&#125;END&#123;for(i in a)print i,a[i]&#125;'</span> access.log | sort -k2 -nr | head -10</span><br><span class="line">111.222.222.222 522</span><br><span class="line">66.102.6.249 26</span><br><span class="line">66.102.6.247 26</span><br><span class="line">66.102.6.245 25</span><br><span class="line">64.233.172.151 2</span><br></pre></td></tr></table></figure><p>3.根据状态码进行请求次数排序，cut实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配第9列为数字的选项，用正则来实现</span></span><br><span class="line">$ awk <span class="string">'$9 ~/^[0-9]&#123;3&#125;/&#123;print $9&#125;'</span> access.log | sort | uniq -c | sort -r </span><br><span class="line">93648 200</span><br><span class="line">3078 404</span><br><span class="line">307128 302</span><br><span class="line">3016 304</span><br><span class="line">2510 400</span><br><span class="line"> 868 173</span><br><span class="line"> 263 499</span><br><span class="line">  15 500</span><br><span class="line">   6 502</span><br><span class="line">   6 413</span><br><span class="line">   4 408</span><br><span class="line">   2 403</span><br><span class="line">   1 405</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ cat access.log | cut -d <span class="string">'"'</span> -f3 | cut -d <span class="string">' '</span> -f2 | sort | uniq -c | sort -r </span><br><span class="line">93648 200</span><br><span class="line">8883 400</span><br><span class="line">3078 404</span><br><span class="line">307130 302</span><br><span class="line">3016 304</span><br><span class="line"> 263 499</span><br><span class="line">  15 500</span><br><span class="line">   6 502</span><br><span class="line">   6 413</span><br><span class="line">   4 408</span><br><span class="line">   2 403</span><br><span class="line">   1 405</span><br></pre></td></tr></table></figure><p>4.统计总请求数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wc -l  access.log |awk <span class="string">'&#123;print $1&#125;'</span></span><br><span class="line">416252</span><br></pre></td></tr></table></figure><p>5.统计访问最多的独立IP TOP5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'&#123;a[$1]++&#125;END&#123;for(i in a)print i,a[i]&#125;'</span> access.log| sort -k2 -nr |head -5</span><br><span class="line">185.234.217.54 96703</span><br><span class="line">222.165.230.7 77701</span><br><span class="line">210.27.176.184 45953</span><br><span class="line">1.202.116.228 8386</span><br><span class="line">1.202.117.42 7524</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ awk <span class="string">'&#123;print $1&#125;'</span> access.log|sort |uniq -c |sort -nr |head -5</span><br><span class="line">96703 185.234.217.54</span><br><span class="line">77701 222.165.230.7</span><br><span class="line">45953 210.27.176.184</span><br><span class="line">8386 1.202.116.228</span><br><span class="line">7524 1.202.117.42</span><br></pre></td></tr></table></figure><p>6.每秒客户端请求数 TOP5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log|cut -d <span class="string">'"'</span> -f2 | cut -d <span class="string">' '</span> -f1 |sort |uniq -c|sort -r |head -3</span><br><span class="line">41793 POST</span><br><span class="line">365183 GET</span><br><span class="line">2064 HEAD</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># 以空格和双引号的一半为分隔符，取请求数，不然有双引号影响判断</span></span><br><span class="line">$ awk -F <span class="string">'[" ]'</span> <span class="string">'&#123;a[$7]++&#125;END&#123;for(i in a)print i,a[i]&#125;'</span> access.log| sort -k2 -nr | head -3</span><br><span class="line">GET 365183</span><br><span class="line">POST 41793</span><br><span class="line">HEAD 2064</span><br></pre></td></tr></table></figure><p>7.访问最频繁IP TOP5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'&#123;a[$1]++&#125;END&#123;for(i in a)print i,a[i]&#125;'</span> access.log|sort -k2 -nr |head -5</span><br><span class="line">185.234.217.54 96703</span><br><span class="line">222.165.230.7 77701</span><br><span class="line">210.27.176.184 45953</span><br><span class="line">1.202.116.228 8386</span><br><span class="line">1.202.117.42 7524</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ awk <span class="string">'&#123;print $1&#125;'</span> access.log|sort |uniq -c |sort -nr |head -5</span><br><span class="line">96703 185.234.217.54</span><br><span class="line">77701 222.165.230.7</span><br><span class="line">45953 210.27.176.184</span><br><span class="line">8386 1.202.116.228</span><br><span class="line">7524 1.202.117.42</span><br></pre></td></tr></table></figure><p>8.访问最频繁的URL TOP5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'&#123;a[$7]++&#125;END&#123;for(i in a)print i,a[i]&#125;'</span> access.log |sort -k2 -nr |head -5</span><br><span class="line">/user/index.jsp 173382</span><br><span class="line">/wls-wsat/index.jsp 46197</span><br><span class="line">/ 24163</span><br><span class="line">/phpMyAdmin/scripts/index.jsp 12507</span><br><span class="line">/phpMyAdmin-3.0.1.1/scripts/index.jsp 7564</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ awk <span class="string">'&#123;print $7&#125;'</span> access.log|sort|uniq -c|sort -nr|head -5</span><br><span class="line">173382 /user/index.jsp</span><br><span class="line">46197 /wls-wsat/index.jsp</span><br><span class="line">24163 /</span><br><span class="line">12507 /phpMyAdmin/scripts/index.jsp</span><br><span class="line">7564 /phpMyAdmin-3.0.1.1/scripts/index.jsp</span><br></pre></td></tr></table></figure><p>9.HTTP状态码(非200)统计 TOP5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># awk中if使用正则，if( info ~ /test/)，这里是只取数字，排除其他干扰</span></span><br><span class="line"><span class="comment"># DATEPATTERN="^[0-9]&#123;4&#125;-[0-9]&#123;1,2&#125;-[0-9]&#123;1,2&#125;$"</span></span><br><span class="line"><span class="comment"># shell中使用正则，if[[ info =~ $DATEPATTERN ]]，两种使用有区别，分情况使用</span></span><br><span class="line">$ awk <span class="string">'&#123;if ( $9 != 200 &amp;&amp; $9 ~ /^[0-9]&#123;3&#125;/ )&#123;print $9&#125;&#125;'</span> access.log|sort|uniq -c|sort -nr|head -5</span><br><span class="line">307128 302</span><br><span class="line">3078 404</span><br><span class="line">3016 304</span><br><span class="line">2510 400</span><br><span class="line"> 868 173</span><br></pre></td></tr></table></figure><p>10.分析请求数大于50000的源IP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意if需要再加一层&#123;&#125;</span></span><br><span class="line">$ awk <span class="string">'&#123;a[$1]++&#125;END&#123;for(i in a) &#123;if(a[i]&gt;50000)print i,a[i]&#125;&#125;'</span> access.log|sort -k2 -nr</span><br><span class="line">185.234.217.54 96703</span><br><span class="line">222.165.230.7 77701</span><br></pre></td></tr></table></figure><p>11.显示返回404状态码的url</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'($9 ~ /404/)'</span> access.log | awk <span class="string">'&#123;print $7&#125;'</span> | sort | uniq -c | sort -r |head -5</span><br><span class="line">1426 http://www.baidu.com/cache/global/img/gs.gif</span><br><span class="line"> 354 /favicon.ico</span><br><span class="line"> 169 http://www.qq.com/404/search_children.js</span><br><span class="line"> 128 /</span><br><span class="line">  89 /phpmyadmin/favicon.ico</span><br></pre></td></tr></table></figure><p>12.响应大于5秒的URL TOP5（这个本次并未统计）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'&#123;if ($7 &gt; 5)&#123;print $6&#125;&#125;'</span> access.log|sort|uniq -c|sort -nr |head -5</span><br></pre></td></tr></table></figure><h3 id="Web服务流量名词介绍"><a href="#Web服务流量名词介绍" class="headerlink" title="Web服务流量名词介绍"></a>Web服务流量名词介绍</h3><p><strong>网站并发连接数：定义为网站服务器在单位时间内能够处理的最大连接数。</strong>示例：某网站的并发是5000.意味着单位时间内（理解为1秒或数秒内），正在处理的连接数，正在建立的连接数，加起来一共是5000个。</p><p><strong>IP：即Internet Protocol</strong>，一般指独立IP数，独立IP数是指不同IP地址的计算机访问网站时被计的总次数。一般一天00:00-24:00内相同IP地址只被计算一次。</p><p><strong>PV：即Page View</strong>，中文翻译为页面浏览，即页面浏览量或点击量，不管客户端是否相同，也不管IP和网站页面是否相同，用户只要访问网站页面就会计算PV，一次计为一个PV</p><p><strong>UV：即Unique Visitor</strong>，同一个客户端（PC或移动端）访问网站被计为一个访客。一天（00:00-24:00）内相同的客户端访问同一个网站只统计一次UV。UV一般是以客户端Cookie等技术作为统计依据的，实际统计会有误差。</p><p><strong>IP，PV，UV的区别在哪？</strong></p><p>举例说明：假设某个公司有10个员工，都访问了<strong><a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a></strong>这个网站。每个人平均浏览了5个页面，但是公司的对外出口是一个公网IP。所以对于<strong><a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a></strong>这个网站而言，只会计算1个独立IP访问。但是因为有10个人在访问      <strong><a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a></strong>这个网站，并且平均都访问了5次，因此，对于<strong><a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a></strong>这个网站而言，PV数就是10x5=50个PV，而因为有10个人访问，就是10个不同的客户端访问，因此，UV（独立访客）为10。</p><p>因此上例结果为IP数为1个，PV数为50个，UV为10个。通过这个结果，不难看出，一个网站的独立IP数量要比网站实际访问的PV数量小得多。通常情况下，网站的UV数也会大于独立IP数。</p><p>🔅 举个栗子：统计该服务器访问PV和UV</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PV</span></span><br><span class="line">$ awk <span class="string">'&#123;a[$7]++&#125;END&#123;print "PV:",length(a);for(v in a)&#123;if(a[v]&gt;10)print v,a[v]&#125;&#125;'</span> access.log |sort -k2 -nr | head</span><br><span class="line">/user/index.jsp 173382</span><br><span class="line">/wls-wsat/index.jsp 46197</span><br><span class="line">/ 24163</span><br><span class="line">PV: 13907</span><br><span class="line">/phpMyAdmin/scripts/index.jsp 12507</span><br><span class="line">/phpMyAdmin-3.0.1.1/scripts/index.jsp 7564</span><br><span class="line">/index.jsp 7306</span><br><span class="line">/services/json/management/modcard/getcard 5498</span><br><span class="line">400 5428</span><br><span class="line">/services/json/schema/setup/getconfiguration 3312</span><br><span class="line"><span class="comment"># UV</span></span><br><span class="line">$ awk <span class="string">'&#123;a[$1]++&#125;END&#123;print "UV:",length(a);for(v in a)&#123;if(a[v]&gt;10)print v,a[v]&#125;&#125;'</span> access.log |sort -k2 -nr | head</span><br><span class="line">185.234.217.54 96703</span><br><span class="line">222.165.230.7 77701</span><br><span class="line">210.27.176.184 45953</span><br><span class="line">UV: 16218</span><br><span class="line">1.202.116.228 8386</span><br><span class="line">1.202.117.42 7524</span><br><span class="line">111.222.222.222 7067</span><br><span class="line">1.202.50.170 6452</span><br><span class="line">124.126.27.107 5384</span><br><span class="line">1.202.1.189 5379</span><br></pre></td></tr></table></figure><blockquote><p><strong>部分参考链接如下</strong><br><a href="https://blog.csdn.net/bbwangj/article/details/82186162" target="_blank" rel="noopener">Nginx日志配置及日志分析脚本案例</a><br><a href="https://blog.51cto.com/13707680/2116001" target="_blank" rel="noopener">Nginx日志分析和参数详解</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;&lt;strong&gt;nginx&lt;/strong&gt;的log日志分为&lt;strong&gt;access log&lt;/strong&gt;和&lt;strong&gt;error log&lt;/strong&gt;。其中&lt;strong&gt;access log&lt;/strong&gt;记录了哪些用户，哪些页面以及用户浏览器、ip和其他的访问信息。&lt;strong&gt;error log&lt;/strong&gt;则是记录服务器错误日志。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="nginx" scheme="https://annecoding.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>linux使用expect批量执行主机命令</title>
    <link href="https://annecoding.github.io/2019/09/04/linux%E4%BD%BF%E7%94%A8expect%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C%E4%B8%BB%E6%9C%BA%E5%91%BD%E4%BB%A4/"/>
    <id>https://annecoding.github.io/2019/09/04/linux使用expect批量执行主机命令/</id>
    <published>2019-09-04T02:57:10.000Z</published>
    <updated>2019-09-04T06:00:41.086Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>现在有两台Linux主机A和B，如何从A主机ssh到B主机，然后在B主机上执行命令，如何使这个过程实现全程自动化？之前有用过<strong>ssh-copy-id免密钥</strong>的形式，这里是用第二种方式<strong>expect</strong>实现。</p><a id="more"></a><h3 id="expect是什么"><a href="#expect是什么" class="headerlink" title="expect是什么"></a>expect是什么</h3><p>expect是一个免费的编程工具，用来<strong>实现自动的交互式任务，而无需人为干预。</strong> 说白了，expect就是一套用来实现自动交互功能的软件。</p><p>在实际工作中，我们运行命令、脚本或程序时，这些命令、脚本或程序都需要从终端输入某些继续运行的指令，而这些输入都需要人为的手工进行。而<strong>利用expect，则可以根据程序的提示，模拟标准输入提供给程序，从而实现自动化交互执行。</strong> 这就是expect！！！</p><p>1.安装expect</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install expect -y</span><br></pre></td></tr></table></figure><p>2.使用expect，基本上都是和以下四个命令打交道：</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>send</td><td>用于向进程发送字符串</td></tr><tr><td>expect</td><td>从进程接收字符串</td></tr><tr><td>spawn</td><td>启动新的进程</td></tr><tr><td>interact</td><td>允许用户交互</td></tr></tbody></table><p><code>send</code>命令接收一个<strong>字符串参数</strong>，并将该参数发送到进程。</p><p><code>expect</code>命令和<code>send</code>命令相反，<code>expect</code>通常用来等待一个进程的反馈，我们根据进程的反馈，再发送对应的交互命令。</p><p><code>spawn</code>命令用来<strong>启动新的进程</strong>，<code>spawn</code>后的<code>send</code>和<code>expect</code>命令都是和使用<code>spawn</code>打开的进程进行交互。</p><p>interact命令用的其实不是很多，一般情况下使用<code>spawn</code>、<code>send</code>和<code>expect</code>命令就可以很好的完成我们的任务；但在一些特殊场合下还是需要使用<code>interact</code>命令的，<code>interact</code>命令主要用于退出自动化，进入人工交互。比如我们使用<code>spawn</code>、<code>send</code>和<code>expect</code>命令完成了ftp登陆主机，执行下载文件任务，但是我们希望在文件下载结束以后，仍然可以停留在ftp命令行状态，以便手动的执行后续命令，此时使用<code>interact</code>命令就可以很好的完成这个任务。</p><h3 id="ssh免密登录"><a href="#ssh免密登录" class="headerlink" title="ssh免密登录"></a>ssh免密登录</h3><p>1.实现ssh登录执行命令，脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">SERVER=<span class="string">"192.168.1.241"</span></span><br><span class="line">PASSWD=nf123456</span><br><span class="line">expect -c <span class="string">"</span></span><br><span class="line"><span class="string">        set timeout -1;</span></span><br><span class="line"><span class="string">        spawn ssh <span class="variable">$SERVER</span>;</span></span><br><span class="line"><span class="string">        expect &#123;</span></span><br><span class="line"><span class="string">                \"yes/no\" &#123; send \"yes\r\" ;exp_contine; &#125;</span></span><br><span class="line"><span class="string">                \"password:\" &#123; send \"<span class="variable">$PASSWD</span>\r\"; &#125;</span></span><br><span class="line"><span class="string">        &#125;;</span></span><br><span class="line"><span class="string">        expect \"]#\" &#123; send \"ls -la \r\" &#125;;</span></span><br><span class="line"><span class="string">        expect \"]#\" &#123; send \"exit \r\" &#125;;</span></span><br><span class="line"><span class="string">        expect eof;</span></span><br><span class="line"><span class="string">        "</span></span><br></pre></td></tr></table></figure><p>上面的shell功能和expect脚本实现的功能一致，都是通过ssh登录进去后输入，执行<code>ls -la</code>命令，其中</p><p><code>set timeout -1</code>设置超时时间</p><p><code>expect</code>后面需要加上-c</p><p><code>expect</code>命令用“双引号包围起来的，这点要注意，里面如果有”需要用\”转义</p><p><code>ls -la</code>代表命令结束后发送一个退出命令，一般需要加上，防止阻塞</p><p><code>expect eof</code>匹配spawn结束</p><p>2.ssh批量免密demo，脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">SERVERS=<span class="string">"192.168.1.241 192.168.1.242"</span></span><br><span class="line">PASSWD=<span class="string">"123456"</span></span><br><span class="line"><span class="keyword">function</span> sshcopyid</span><br><span class="line">&#123;</span><br><span class="line">        expect -c <span class="string">"</span></span><br><span class="line"><span class="string">                set timeout -1;</span></span><br><span class="line"><span class="string">                spawn ssh-copy-id <span class="variable">$1</span>;</span></span><br><span class="line"><span class="string">                expect &#123;</span></span><br><span class="line"><span class="string">                        \"yes/no\" &#123; send \"yes\r\" ;exp_contine; &#125;</span></span><br><span class="line"><span class="string">                        \"password:\" &#123; send \"<span class="variable">$PASSWD</span>\r\";exp_continue; &#125;</span></span><br><span class="line"><span class="string">                &#125;;</span></span><br><span class="line"><span class="string">                expect eof;</span></span><br><span class="line"><span class="string">        "</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> server <span class="keyword">in</span> <span class="variable">$SERVERS</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        sshcopyid <span class="variable">$server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="批量执行主机命令"><a href="#批量执行主机命令" class="headerlink" title="批量执行主机命令"></a>批量执行主机命令</h3><p>1.存储在host.info的主机信息如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat host.info </span><br><span class="line">192.168.1.3 root 22 111111</span><br></pre></td></tr></table></figure><p>2.linux下批量执行主机命令实现脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ cat batch_host.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 接收所传所有参数</span></span><br><span class="line">COMMAND=$*</span><br><span class="line">HOST_INFO=host.info</span><br><span class="line"><span class="comment"># 不匹配文件中的注释</span></span><br><span class="line"><span class="keyword">for</span> IP <span class="keyword">in</span> $(awk <span class="string">'/^[^#]/&#123;print $1&#125;'</span> <span class="variable">$HOST_INFO</span>);<span class="keyword">do</span></span><br><span class="line">        USER=$(awk -v ip=<span class="variable">$IP</span> <span class="string">'ip=$1&#123;print $2&#125;'</span> <span class="variable">$HOST_INFO</span>)</span><br><span class="line">        PORT=$(awk -v ip=<span class="variable">$IP</span> <span class="string">'ip=$1&#123;print $3&#125;'</span> <span class="variable">$HOST_INFO</span>)</span><br><span class="line">        PASS=$(awk -v ip=<span class="variable">$IP</span> <span class="string">'ip=$1&#123;print $4&#125;'</span> <span class="variable">$HOST_INFO</span>)</span><br><span class="line">        <span class="comment"># expect -c执行自身的语句</span></span><br><span class="line">        <span class="comment"># 因为外面有双引号，再次出现都需要转义</span></span><br><span class="line">        <span class="comment"># 执行完命令要退出</span></span><br><span class="line">        expect -c <span class="string">"</span></span><br><span class="line"><span class="string">                spawn ssh -p <span class="variable">$PORT</span> <span class="variable">$USER</span>@<span class="variable">$IP</span></span></span><br><span class="line"><span class="string">                expect &#123;</span></span><br><span class="line"><span class="string">                        \"(yes/no)\" &#123;send \"yes\r\"; exp_continue&#125;</span></span><br><span class="line"><span class="string">                        \"password:\" &#123;send \"<span class="variable">$PASS</span>\r\"; exp_continue&#125;</span></span><br><span class="line"><span class="string">                        \"<span class="variable">$USER</span>@*\" &#123;send \"<span class="variable">$COMMAND</span>\r exit\r\"; exp_continue&#125;</span></span><br><span class="line"><span class="string">                &#125;;</span></span><br><span class="line"><span class="string">        "</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"--------------------------------------------"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>其中<code>exp_continue</code>表示循环式匹配，通常匹配之后都会退出语句，但如果有<code>exp_continue</code>则可以不断循环匹配，输入多条命令，简化写法。</p><p>结合着expect <code>&quot;*password*&quot; {send &quot;$password\r&quot;}</code>这句代码来说说“模式-动作”。简单的说就是匹配到一个模式，就执行对应的动作；匹配到password字符串，就输入密码。</p><p><strong>执行结果如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ bash  test.sh <span class="string">'df -h'</span></span><br><span class="line">spawn ssh -p 22 root@192.168.1.3</span><br><span class="line">Last login: Tue Sep  3 05:05:47 2019 from 192.168.1.2</span><br><span class="line">[root@localhost ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root   14G  979M   13G   7% /</span><br><span class="line">devtmpfs                 3.9G     0  3.9G   0% /dev</span><br><span class="line">tmpfs                    3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs                    3.9G   49M  3.8G   2% /run</span><br><span class="line">tmpfs                    3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1                497M  125M  373M  25% /boot</span><br><span class="line">tmpfs                    783M     0  783M   0% /run/user/0</span><br><span class="line">[root@localhost ~]<span class="comment">#  exit</span></span><br><span class="line"><span class="built_in">logout</span></span><br><span class="line">Connection to 192.168.1.3 closed.</span><br><span class="line">df -h</span><br><span class="line"> <span class="built_in">exit</span></span><br><span class="line">--------------------------------------------</span><br></pre></td></tr></table></figure><blockquote><p>参考链接<br><a href="https://www.jellythink.com/archives/373" target="_blank" rel="noopener">linux expect命令详解</a><br><a href="https://www.cnblogs.com/nfcm/p/7899831.html" target="_blank" rel="noopener">linux下expect命令实现批量ssh免密</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;现在有两台Linux主机A和B，如何从A主机ssh到B主机，然后在B主机上执行命令，如何使这个过程实现全程自动化？之前有用过&lt;strong&gt;ssh-copy-id免密钥&lt;/strong&gt;的形式，这里是用第二种方式&lt;strong&gt;expect&lt;/strong&gt;实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Centos" scheme="https://annecoding.github.io/tags/Centos/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>linux查看网卡实时流量</title>
    <link href="https://annecoding.github.io/2019/08/30/linux%E6%9F%A5%E7%9C%8B%E7%BD%91%E5%8D%A1%E5%AE%9E%E6%97%B6%E6%B5%81%E9%87%8F/"/>
    <id>https://annecoding.github.io/2019/08/30/linux查看网卡实时流量/</id>
    <published>2019-08-30T12:24:52.000Z</published>
    <updated>2019-11-24T02:50:25.048Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>在工作中，我们经常需要查看服务器的实时网卡流量。通常，我们会通过这几种方式查看Linux服务器的实时网卡流量。</p><a id="more"></a><h3 id="nload工具"><a href="#nload工具" class="headerlink" title="nload工具"></a>nload工具</h3><p>nload用于实时查看网卡流量，默认系统都没有安装，首先安装方式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y epel-release</span><br><span class="line">$ yum install -y nload</span><br></pre></td></tr></table></figure></p><p>使用也非常简单，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ nload</span><br><span class="line">Device eth0 [192.168.0.110] (4/5):    <span class="comment"># eth0网卡的流量，按方向键左或右可切换网卡</span></span><br><span class="line">===================================================================================</span><br><span class="line">Incoming:</span><br><span class="line">            Curr: 5.21 kBit/s      <span class="comment"># Incoming：进来的流量</span></span><br><span class="line">            Avg: 4.09 kBit/s       <span class="comment"># Outgoing：出去的流量</span></span><br><span class="line">            Min: 1.59 kBit/s       <span class="comment"># Curr：当前的流量值</span></span><br><span class="line">            Max: 12.51 kBit/s      <span class="comment"># Avg：平均值的流量值</span></span><br><span class="line">            Ttl: 4.16 GByte        <span class="comment"># Min：最小的流量值</span></span><br><span class="line">Outgoing:                          <span class="comment"># Max：最大的流量值</span></span><br><span class="line">            Curr: 16.48 kBit/s     <span class="comment"># Ttl：总的流量值</span></span><br><span class="line">            Avg: 14.38 kBit/s</span><br><span class="line">            Min: 6.73 kBit/s       </span><br><span class="line">            Max: 28.39 kBit/s</span><br></pre></td></tr></table></figure></p><h3 id="iftop工具"><a href="#iftop工具" class="headerlink" title="iftop工具"></a>iftop工具</h3><p>默认系统没有安装，需要安装，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要epel环境</span></span><br><span class="line">$ yum install -y epel-release</span><br><span class="line">$ yum install -y iftop</span><br></pre></td></tr></table></figure></p><p>安装完成之后，输入<code>iftop</code>便可看到如下界面<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g98xobwa37j31800gk0vn.jpg" alt="image-20191124104515216"></p><p>其中，相关参数解释如下：</p><ul><li>界面上面显示的是类似刻度尺的刻度范围，为显示流量图形的长条作标尺用的。</li><li>中间的&lt;= =&gt;这两个左右箭头，表示的是流量的方向。</li><li>TX：发送流量</li><li>RX：接收流量</li><li>TOTAL：总流量</li><li>Cumm：运行iftop到目前时间的总流量</li><li>peak：流量峰值</li><li>rates：分别表示过去 2s 10s 40s 的平均流量</li></ul><h3 id="sar命令"><a href="#sar命令" class="headerlink" title="sar命令"></a>sar命令</h3><p>sar命令包含在sysstat工具包中，提供系统的众多统计数据。其在不同的系统上命令有些差异，某些系统提供的sar支持基于网络接口的数据统计，也可以查看设备上每秒收发包的个数和流量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DEV显示网络接口信息</span></span><br><span class="line"><span class="comment"># 命令后面1 2 意思是：每一秒钟取1次值，取2次</span></span><br><span class="line">$ sar –n DEV  1 2</span><br></pre></td></tr></table></figure><p>另外，-n参数很有用，他有6个不同的开关：DEV | EDEV | NFS | NFSD | SOCK | ALL ，其代表的含义如下：</p><p>DEV显示网络接口信息。<br>EDEV显示关于网络错误的统计数据。<br>NFS统计活动的NFS客户端的信息。<br>NFSD统计NFS服务器的信息<br>SOCK显示套接字信息<br>ALL显示所有5个开关</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ sar -n DEV 1 2       </span><br><span class="line">Linux 3.10.0-514.26.2.el7.x86_64 (localhost)    08/31/2019      _x86_64_        (1 CPU)</span><br><span class="line"></span><br><span class="line">09:52:28 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">09:52:29 AM      eth0      2.02      1.01      0.13      0.16      0.00      0.00      0.00</span><br><span class="line">09:52:29 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">09:52:29 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">09:52:30 AM      eth0      1.02      1.02      0.07      0.23      0.00      0.00      0.00</span><br><span class="line">09:52:30 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">Average:        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">Average:         eth0      1.52      1.02      0.10      0.19      0.00      0.00      0.00</span><br><span class="line">Average:           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong><br>IFACE：LAN接口<br>rxpck/s：每秒钟接收的数据包<br>txpck/s：每秒钟发送的数据包<br>rxbyt/s：每秒钟接收的字节数<br>txbyt/s：每秒钟发送的字节数<br>rxcmp/s：每秒钟接收的压缩数据包<br>txcmp/s：每秒钟发送的压缩数据包<br>rxmcst/s：每秒钟接收的多播数据包<br>rxerr/s：每秒钟接收的坏数据包<br>txerr/s：每秒钟发送的坏数据包<br>coll/s：每秒冲突数<br>rxdrop/s：因为缓冲充满，每秒钟丢弃的已接收数据包数<br>txdrop/s：因为缓冲充满，每秒钟丢弃的已发送数据包数<br>txcarr/s：发送数据包时，每秒载波错误数<br>rxfram/s：每秒接收数据包的帧对齐错误数<br>rxfifo/s：接收的数据包每秒FIFO过速的错误数<br>txfifo/s：发送的数据包每秒FIFO过速的错误数</p><h3 id="实时监控脚本（1）"><a href="#实时监控脚本（1）" class="headerlink" title="实时监控脚本（1）"></a>实时监控脚本（1）</h3><p>ifconfig可以查看的是从连上网开始的流量总和，<code>cat /proc/net/dev</code>记录的值也是总流量，那么可以计算一下，实时流量=当前流量-上一秒的流量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat network.sh </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 传入网卡参数</span></span><br><span class="line">ethn=<span class="variable">$1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  RX_pre=$(cat /proc/net/dev | grep <span class="variable">$ethn</span> | sed <span class="string">'s/:/ /g'</span> | awk <span class="string">'&#123;print $2&#125;'</span>)</span><br><span class="line">  TX_pre=$(cat /proc/net/dev | grep <span class="variable">$ethn</span> | sed <span class="string">'s/:/ /g'</span> | awk <span class="string">'&#123;print $10&#125;'</span>)</span><br><span class="line">  sleep 1</span><br><span class="line">  RX_next=$(cat /proc/net/dev | grep <span class="variable">$ethn</span> | sed <span class="string">'s/:/ /g'</span> | awk <span class="string">'&#123;print $2&#125;'</span>)</span><br><span class="line">  TX_next=$(cat /proc/net/dev | grep <span class="variable">$ethn</span> | sed <span class="string">'s/:/ /g'</span> | awk <span class="string">'&#123;print $10&#125;'</span>)</span><br><span class="line"> </span><br><span class="line">  clear</span><br><span class="line">  <span class="comment"># echo -e激活转义符</span></span><br><span class="line">  <span class="comment"># 输出时间的标题</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">"\t RX `date +%k:%M:%S` TX"</span></span><br><span class="line"> </span><br><span class="line">  RX=$((<span class="variable">$&#123;RX_next&#125;</span>-<span class="variable">$&#123;RX_pre&#125;</span>))</span><br><span class="line">  TX=$((<span class="variable">$&#123;TX_next&#125;</span>-<span class="variable">$&#123;TX_pre&#125;</span>))</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> [[ <span class="variable">$RX</span> -lt 1024 ]];<span class="keyword">then</span></span><br><span class="line">    RX=<span class="string">"<span class="variable">$&#123;RX&#125;</span>B/s"</span></span><br><span class="line">  <span class="keyword">elif</span> [[ <span class="variable">$RX</span> -gt 1048576 ]];<span class="keyword">then</span></span><br><span class="line">    RX=$(<span class="built_in">echo</span> <span class="variable">$RX</span> | awk <span class="string">'&#123;print $1/1048576 "MB/s"&#125;'</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    RX=$(<span class="built_in">echo</span> <span class="variable">$RX</span> | awk <span class="string">'&#123;print $1/1024 "KB/s"&#125;'</span>)</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> [[ <span class="variable">$TX</span> -lt 1024 ]];<span class="keyword">then</span></span><br><span class="line">    TX=<span class="string">"<span class="variable">$&#123;TX&#125;</span>B/s"</span></span><br><span class="line">  <span class="keyword">elif</span> [[ <span class="variable">$TX</span> -gt 1048576 ]];<span class="keyword">then</span></span><br><span class="line">    TX=$(<span class="built_in">echo</span> <span class="variable">$TX</span> | awk <span class="string">'&#123;print $1/1048576 "MB/s"&#125;'</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    TX=$(<span class="built_in">echo</span> <span class="variable">$TX</span> | awk <span class="string">'&#123;print $1/1024 "KB/s"&#125;'</span>)</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="comment"># 输出流量</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$ethn</span> \t <span class="variable">$RX</span>   <span class="variable">$TX</span> "</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>执行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ./network.sh  eth0</span></span><br><span class="line">         RX 20:23:38 TX</span><br><span class="line">eth0     66B/s   0B/s </span><br><span class="line">         RX 20:23:39 TX</span><br><span class="line">eth0     132B/s   0B/s </span><br><span class="line">         RX 20:23:40 TX</span><br><span class="line">eth0     186B/s   194B/s </span><br><span class="line">         RX 20:23:41 TX</span><br><span class="line">eth0     240B/s   194B/s </span><br><span class="line">         RX 20:23:42 TX</span><br><span class="line">eth0     132B/s   0B/s </span><br><span class="line">         RX 20:23:43 TX</span><br><span class="line">eth0     240B/s   194B/s </span><br><span class="line">         RX 20:23:44 TX</span><br><span class="line">eth0     396B/s   4.19727KB/s </span><br><span class="line">         RX 20:23:45 TX</span><br><span class="line">eth0     276B/s   178B/s</span><br></pre></td></tr></table></figure></p><h3 id="实时监控脚本（2）"><a href="#实时监控脚本（2）" class="headerlink" title="实时监控脚本（2）"></a>实时监控脚本（2）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat network_flow.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 监控实时网卡流量</span></span><br><span class="line"><span class="comment"># $1 接收所传第一个参数 即要监控的网卡</span></span><br><span class="line">NIC=<span class="variable">$1</span></span><br><span class="line"><span class="comment"># echo -e "traffic in --- traffic out"</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>;<span class="keyword">do</span></span><br><span class="line">        <span class="comment"># $0 命令输出结果 ~ 匹配模式</span></span><br><span class="line">        OLD_IN=`awk <span class="string">'$0~"'</span><span class="variable">$NIC</span><span class="string">'"&#123;print $2&#125;'</span> /proc/net/dev`</span><br><span class="line">        OLD_OUT=`awk <span class="string">'$0~"'</span><span class="variable">$NIC</span><span class="string">'"&#123;print $10&#125;'</span> /proc/net/dev`</span><br><span class="line">        sleep 1</span><br><span class="line">        NEW_IN=`awk <span class="string">'$0~"'</span><span class="variable">$NIC</span><span class="string">'"&#123;print $2&#125;'</span> /proc/net/dev`</span><br><span class="line">        NEW_OUT=`awk <span class="string">'$0~"'</span><span class="variable">$NIC</span><span class="string">'"&#123;print $10&#125;'</span> /proc/net/dev`</span><br><span class="line">        clear</span><br><span class="line">        <span class="comment"># printf不换行 %s占位符</span></span><br><span class="line">        IN=$(<span class="built_in">printf</span> <span class="string">"%.1f%s"</span> <span class="string">"<span class="variable">$(($NEW_IN-$OLD_IN)</span>)"</span> <span class="string">"B/s"</span>)</span><br><span class="line">        OUT=$(<span class="built_in">printf</span> <span class="string">"%.1f%s"</span> <span class="string">"<span class="variable">$(($NEW_OUT-$OLD_OUT)</span>)"</span> <span class="string">"B/s"</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"       traffic in  `date +%k:%M:%S`  traffic out "</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$NIC</span>   <span class="variable">$IN</span>              <span class="variable">$OUT</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ./network_flow.sh eth0</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:02  traffic out </span><br><span class="line">eth0   732.0B/s              948.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:03  traffic out </span><br><span class="line">eth0   132.0B/s              0.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:04  traffic out </span><br><span class="line">eth0   132.0B/s              0.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:05  traffic out </span><br><span class="line">eth0   132.0B/s              0.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:06  traffic out </span><br><span class="line">eth0   186.0B/s              242.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:07  traffic out </span><br><span class="line">eth0   132.0B/s              0.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:08  traffic out </span><br><span class="line">eth0   132.0B/s              0.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:09  traffic out </span><br><span class="line">eth0   132.0B/s              0.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:10  traffic out </span><br><span class="line">eth0   240.0B/s              242.0B/s</span><br><span class="line">       traffic <span class="keyword">in</span>  11:15:11  traffic out </span><br><span class="line">eth0   132.0B/s              0.0B/s</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;在工作中，我们经常需要查看服务器的实时网卡流量。通常，我们会通过这几种方式查看Linux服务器的实时网卡流量。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Centos" scheme="https://annecoding.github.io/tags/Centos/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>一键查看服务器资源利用率</title>
    <link href="https://annecoding.github.io/2019/08/29/%E4%B8%80%E9%94%AE%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%BA%90%E5%88%A9%E7%94%A8%E7%8E%87/"/>
    <id>https://annecoding.github.io/2019/08/29/一键查看服务器资源利用率/</id>
    <published>2019-08-29T09:09:22.000Z</published>
    <updated>2019-08-29T09:18:34.970Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>一般要查服务器资源利用率，我们会先从以下几个方面入手，比如cpu、内存、硬盘、tcp连接情况等。</p><a id="more"></a><p>这里以cpu、内存、硬盘、tcp连接情况来举例，实现如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">$ cat resource_utilization_rate.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 一键查看服务器资源利用率</span></span><br><span class="line"><span class="comment"># 可通过 cpu 内存 硬盘 tcp连接情况 ...等来查看</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">cpu</span></span>()&#123;</span><br><span class="line">        <span class="comment"># NUM=1</span></span><br><span class="line">        <span class="comment"># while [ $NUM -le 3 ];do</span></span><br><span class="line">                <span class="comment"># 相较于top vmstat 可免交互取静态数据，id,空间状态百分比</span></span><br><span class="line">                util=`vmstat |awk <span class="string">'&#123;if(NR==3)print 100-$15"%"&#125;'</span>`</span><br><span class="line">                <span class="comment"># us用户进程消耗cpu时间百分比</span></span><br><span class="line">                user=`vmstat |awk <span class="string">'&#123;if(NR==3)print $13"%"&#125;'</span>`</span><br><span class="line">                <span class="comment"># 系统内核进程消耗cpu时间百分比</span></span><br><span class="line">                sys=`vmstat |awk <span class="string">'&#123;if(NR==3)print $14"%"&#125;'</span>`</span><br><span class="line">                <span class="comment"># cpu资源等待I/O时间百分比</span></span><br><span class="line">                iowait=`vmstat |awk <span class="string">'&#123;if(NR==3)print $16"%"&#125;'</span>`</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"CPU - 使用率：<span class="variable">$util</span> ,等待磁盘IO响应使用率：<span class="variable">$iowait</span>"</span></span><br><span class="line">        <span class="comment">#echo "===========          ****         ================"</span></span><br><span class="line">        <span class="comment">#       let NUM++</span></span><br><span class="line">        <span class="comment">#       sleep 1</span></span><br><span class="line">        <span class="comment">#done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">memory</span></span>()&#123;</span><br><span class="line">        <span class="comment"># ` ` 等同于 $()</span></span><br><span class="line">        total=`free -h |awk <span class="string">'&#123;if(NR==2)print $2&#125;'</span>`</span><br><span class="line">        <span class="comment"># $NF表示取最后一列数据值</span></span><br><span class="line">        used=`free -h |awk <span class="string">'&#123;if(NR==2)print $2-$NF&#125;'</span>`</span><br><span class="line">        available=`free -h |awk <span class="string">'&#123;if(NR==2)print $NF&#125;'</span>`</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"内存 - 总大小：<span class="variable">$&#123;total&#125;</span>G ,已使用：<span class="variable">$&#123;used&#125;</span>G ,可利用：<span class="variable">$&#123;available&#125;</span>G"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">function</span> <span class="function"><span class="title">disk</span></span>()&#123;</span><br><span class="line">     <span class="comment"># 特殊符号/转义,只取第一列</span></span><br><span class="line">     fs=`df -h |awk <span class="string">'/^\/dev/&#123;print $1&#125;'</span>`</span><br><span class="line">     <span class="keyword">for</span> p <span class="keyword">in</span> <span class="variable">$fs</span>;<span class="keyword">do</span></span><br><span class="line">             <span class="comment"># 只有当第一列是磁盘Filesystem，输出最后一列</span></span><br><span class="line">             mounted=`df -h |awk <span class="string">'$1=="'</span><span class="variable">$p</span><span class="string">'"&#123;print $NF&#125;'</span>`</span><br><span class="line">             size=`df -h |awk <span class="string">'$1=="'</span><span class="variable">$p</span><span class="string">'"&#123;print $2&#125;'</span>`</span><br><span class="line">             used=`df -h |awk <span class="string">'$1=="'</span><span class="variable">$p</span><span class="string">'"&#123;print $3&#125;'</span>`</span><br><span class="line">             used_percent=`df -h |awk <span class="string">'$1=="'</span><span class="variable">$p</span><span class="string">'"&#123;print $5&#125;'</span>`</span><br><span class="line">             <span class="built_in">echo</span> <span class="string">"硬盘 - 挂载点：<span class="variable">$&#123;mounted&#125;</span> , 总大小：<span class="variable">$&#123;size&#125;</span> , 使用：<span class="variable">$&#123;used&#125;</span> , 使用率：<span class="variable">$&#123;used_percent&#125;</span>"</span></span><br><span class="line">     <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">tcp_status</span></span>()&#123;</span><br><span class="line"><span class="comment"># printf不换行 “:”以冒号分隔  ss第一列表示连接状态</span></span><br><span class="line">summary=`ss -antp |awk <span class="string">'&#123;status[$1]++&#125;END&#123;for(i in status) printf i ":" status[i]" "&#125;'</span>`</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"TCP - 连接状态：<span class="variable">$summary</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">cpu</span><br><span class="line">memory</span><br><span class="line">disk</span><br><span class="line">tcp_status</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./resource_utilization_rate.sh </span><br><span class="line">CPU - 使用率：0% ,等待磁盘IO响应使用率：0%</span><br><span class="line">内存 - 总大小：1.8GG ,已使用：0.2G ,可利用：1.6GG</span><br><span class="line">硬盘 - 挂载点：/ , 总大小：40G , 使用：1.9G , 使用率：5%</span><br><span class="line">TCP - 连接状态：LISTEN:3 ESTAB:3 State:1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;一般要查服务器资源利用率，我们会先从以下几个方面入手，比如cpu、内存、硬盘、tcp连接情况等。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>批量创建用户并设置随机密码</title>
    <link href="https://annecoding.github.io/2019/08/29/%E6%89%B9%E9%87%8F%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E8%AE%BE%E7%BD%AE%E9%9A%8F%E6%9C%BA%E5%AF%86%E7%A0%81/"/>
    <id>https://annecoding.github.io/2019/08/29/批量创建用户并设置随机密码/</id>
    <published>2019-08-29T09:08:31.000Z</published>
    <updated>2019-09-01T11:42:01.780Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>假如，在linux系统服务器上，要一次创建多个用户并设置密码，你有什么好办法吗？跟我来吧🔅</p><a id="more"></a><h3 id="批量创建用户"><a href="#批量创建用户" class="headerlink" title="批量创建用户"></a>批量创建用户</h3><p>使用shell脚本实现批量创建用户，实现方式如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ cat batch_create_user.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 批量创建用户</span></span><br><span class="line"><span class="comment"># $@接收输入的所有参数</span></span><br><span class="line">USER_LIST=<span class="variable">$@</span></span><br><span class="line"><span class="comment"># 将生成的用户名和密码存在文件里面，这样写默认user.txt存在当前路径下</span></span><br><span class="line">USER_FILE=user.txt</span><br><span class="line"><span class="keyword">for</span> USER <span class="keyword">in</span> <span class="variable">$USER_LIST</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 通过id来判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span> ! id <span class="variable">$USER</span> &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># 生产随机的8位字符串</span></span><br><span class="line">        PASS=$(<span class="built_in">echo</span> <span class="variable">$RANDOM</span> |md5sum |cut -c 1-8)</span><br><span class="line">        <span class="comment"># 创建用户</span></span><br><span class="line">        useradd <span class="variable">$USER</span></span><br><span class="line">        <span class="comment"># 将随机生成的密码分配给用户</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$PASS</span> |passwd --stdin <span class="variable">$USER</span> &amp;&gt;/dev/null</span><br><span class="line">        <span class="comment"># 生成的用户名和密码存入文件中</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$USER</span>   <span class="variable">$PASS</span>"</span> &gt;&gt; <span class="variable">$USER_FILE</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$USER</span> User create successful."</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$USER</span> User already exists!"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>执行结果如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./batch_create_user.sh coco zhangsan</span><br><span class="line">coco User create successful.</span><br><span class="line">zhangsan User create successful.</span><br><span class="line"><span class="comment"># 文件默认存放在当前目录下</span></span><br><span class="line">$ cat user.txt </span><br><span class="line">coco   69b7bc14</span><br><span class="line">zhangsan   fd343a4f</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;假如，在linux系统服务器上，要一次创建多个用户并设置密码，你有什么好办法吗？跟我来吧🔅&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本实现centos系统初始化配置</title>
    <link href="https://annecoding.github.io/2019/08/28/shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0centos%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>https://annecoding.github.io/2019/08/28/shell脚本实现centos系统初始化配置/</id>
    <published>2019-08-28T01:32:11.000Z</published>
    <updated>2019-08-28T04:48:03.309Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>Linux系统配置初始化，顾名思义，在我们有大量机器要做相同工作时，比如都要安装好某些软件，配置环境等，这时候，一个便捷实用的脚本就派上用场啦。</p><a id="more"></a><p><strong>背景：</strong>新购买100台服务器并已安装linux操作系统</p><p><strong>需求：</strong><br>1.设置时区并同步时间<br>2.禁用selinux<br>3.清空防火墙默认策略<br>4.历史命令显示操作时间<br>5.禁止root远程登录，这个要注意，禁止之前确保有普通账户可以sudo到root权限使用，不然切不到root账户<br>6.禁止定时任务发送邮件<br>7.设置最大打开文件数，默认比较少<br>8.减少swap使用，默认物理内存不够会使用swap来交换，速度慢，不建议使用<br>9.系统内核参数优化<br>10.安装系统性能分析工具及一些其他的</p><p><strong>实现脚本如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">$ cat server_initialize.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 设置时区为上海并每小时同步一次时间，默认时区为东八区</span></span><br><span class="line">ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"><span class="comment"># if判断是根据命令执行状态返回值$#?来判断是否执行成功，执行成功则为0，执行失败则为其他，一般为1</span></span><br><span class="line"><span class="keyword">if</span> ! crontab -l | grep ntpdate &amp;&gt;/dev/null; <span class="keyword">then</span> </span><br><span class="line">        <span class="comment"># | crontab通过管道符接收定时任务</span></span><br><span class="line">        (<span class="built_in">echo</span> <span class="string">"* 1 * * * ntpdate time.windows.com &gt;/dev/null 2&gt;&amp;1"</span>;crontab -l) | crontab</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用selinux</span></span><br><span class="line">sed -i <span class="string">'/SELINUX/&#123;s/permissive/disabled/&#125;'</span> /etc/selinux/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line"><span class="keyword">if</span> egrep <span class="string">"7.[0-9]"</span> /etc/redhat-release &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">        systemctl stop firewalld</span><br><span class="line">        systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"><span class="keyword">elif</span> egrep <span class="string">"6.[0-9]"</span> /etc/redhat-release &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">        service iptables stop</span><br><span class="line">        chkconfig iptables off</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 历史命令显示操作时间</span></span><br><span class="line"><span class="comment"># 方便后期审计，谁在什么时间操作</span></span><br><span class="line"><span class="keyword">if</span> ! grep HISTTIMEFORMAT /etc/bashrc &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'export HISTTIMEFORMAT="%F %T `whoami` "'</span> &gt;&gt; /etc/bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SSH超时时间</span></span><br><span class="line"><span class="comment"># 只有TMOUT可以控制ssh连接在空闲时间超时，自动断开连接的时间，数字单位为“秒”</span></span><br><span class="line"><span class="keyword">if</span> ! grep <span class="string">"TMOUT=1500"</span> /etc/profile &amp;&gt;/dev/null; <span class="keyword">then</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"export TMOUT=1500"</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁止root远程登录</span></span><br><span class="line"><span class="comment"># 操作之前授权其他账号或者将自己本机的key保存在系统，或者授权其他账户可以sudo到root账户</span></span><br><span class="line"><span class="comment"># sed -i 's/#PermitRootLogin yes/PermitRootLogin no/' /etc/ssh/sshd_config</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁止定时任务向root发送邮件</span></span><br><span class="line"><span class="comment"># 定时任务的错误等会给当前用户发送邮件，默认是当前用户，会在/var/mail很多小文件占用很大的磁盘空间</span></span><br><span class="line">sed -i <span class="string">'s/^MAILTO=root/MAILTO=""/'</span> /etc/crontab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置最大打开文件数</span></span><br><span class="line"><span class="comment"># 并发较高时，很容易会达到默认，很容易不可用，这里做个优化</span></span><br><span class="line"><span class="comment"># EOF直接将内容追加到文件中，需要在当前行起始位置，不能加空格</span></span><br><span class="line"><span class="keyword">if</span> ! grep <span class="string">"* soft nofile 65535"</span> /etc/security/limits.conf &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">        cat &gt;&gt; /etc/security/limits.conf &lt;&lt; EOF</span><br><span class="line">        * soft nofile 65535</span><br><span class="line">        * hard nofile 65535</span><br><span class="line">EOF</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统内核优化</span></span><br><span class="line"><span class="comment"># 默认数值可通过systcl -a查看</span></span><br><span class="line"><span class="comment"># net.core.netdev_max_backlog 决定了，网络设备接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。</span></span><br><span class="line"><span class="comment"># net.ipv4.tcp_syncookies = 1表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭。</span></span><br><span class="line"><span class="comment"># net.ipv4.tcp_fin_timeout =20表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。</span></span><br><span class="line">cat &gt;&gt; /etc/sysctl.conf &lt;&lt; EOF</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 20480</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 20480</span><br><span class="line">net.core.netdev_max_backlog = 262144</span><br><span class="line">net.ipv4.tcp_fin_timeout = 20</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 减少SWAP使用</span></span><br><span class="line"><span class="comment"># 权重值设置的越大，使用的可能越大。设置为0，尽可能不使用它。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"0"</span> &gt; /proc/sys/vm/swappiness</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装系统性能分析工具及其他</span></span><br><span class="line"><span class="comment"># htop 比top好用的工具</span></span><br><span class="line">yum install gcc make autoconf vim htop sysstat net-tools iostat iftop iotp lrzsz -y</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;Linux系统配置初始化，顾名思义，在我们有大量机器要做相同工作时，比如都要安装好某些软件，配置环境等，这时候，一个便捷实用的脚本就派上用场啦。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Centos使用mailx告警邮件配置</title>
    <link href="https://annecoding.github.io/2019/08/22/Centos%E4%BD%BF%E7%94%A8mailx%E5%91%8A%E8%AD%A6%E9%82%AE%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    <id>https://annecoding.github.io/2019/08/22/Centos使用mailx告警邮件配置/</id>
    <published>2019-08-22T01:09:19.000Z</published>
    <updated>2019-08-24T01:38:04.551Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>今天为大家介绍一个可以直接在 Linux 上使用 SMTP 发送邮件的程序：Mailx，这个程序可以帮助我们让服务器直接支持邮件发送，不用再在每个站点上都设置了。</p><a id="more"></a><p><strong>centos配置自带邮件服务器mailx发件配置</strong></p><h4 id="安装mailx程序"><a href="#安装mailx程序" class="headerlink" title="安装mailx程序"></a>安装mailx程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mailx</span><br></pre></td></tr></table></figure><p>🌟 安装之前，建议移除不再需要且可能会引起冲突的 postfix 或 sendmail 程序。</p><h4 id="修改发件人设置"><a href="#修改发件人设置" class="headerlink" title="修改发件人设置"></a>修改发件人设置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ vim + /etc/mail.rc </span><br><span class="line"><span class="built_in">set</span> nss-config-dir=/root/.certs</span><br><span class="line"><span class="built_in">set</span> smtp=<span class="string">"smtps://smtp.163.com:465"</span></span><br><span class="line"><span class="comment"># set smtp=smtp.163.com  默认25端口不放开</span></span><br><span class="line"><span class="built_in">set</span> from=<span class="string">"annecoding@163.com"</span></span><br><span class="line"><span class="built_in">set</span> smtp-auth=login</span><br><span class="line"><span class="built_in">set</span> smtp-auth-user=<span class="string">"annecoding@163.com"</span></span><br><span class="line"><span class="comment"># 不是密码，不是密码！！！获取网易163设置的客户端授权密码。</span></span><br><span class="line"><span class="built_in">set</span> smtp-auth-password=<span class="string">"xxxxxx"</span></span><br><span class="line"><span class="built_in">set</span> ssl-verify=ignore</span><br></pre></td></tr></table></figure><p>💡 一般邮件服务器会提供 smtp、smtps 和 smtp starttls 服务来发送邮件。smtp 最简单的，也最不安全的，不建议使用，最好使用 smtps 或者 smtp starttls 来发送邮件。</p><h4 id="测试发送"><a href="#测试发送" class="headerlink" title="测试发送"></a>测试发送</h4><p>可以发送出邮件，但是会报错，如下面这种情况。需要生成证书来解决此问题。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"TEST"</span> | mail -s <span class="string">"Title"</span> <span class="string">"annecoding@163.com"</span></span><br><span class="line">$ Error <span class="keyword">in</span> certificate: Peer<span class="string">'s certificate issuer is not recognized.</span></span><br></pre></td></tr></table></figure></p><h4 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h4><p>在本地新建目录生成证书<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /root/.certs/</span><br><span class="line">$ <span class="built_in">echo</span> -n | openssl s_client -connect smtp.163.com:465 | sed -ne <span class="string">'/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p'</span> &gt; ~/.certs/163.crt</span><br><span class="line">$ certutil -A -n <span class="string">"GeoTrust SSL CA"</span> -t <span class="string">"C,,"</span> -d ~/.certs -i ~/.certs/163.crt</span><br><span class="line">$ certutil -A -n <span class="string">"GeoTrust Global CA"</span> -t <span class="string">"C,,"</span> -d ~/.certs -i ~/.certs/163.crt</span><br><span class="line">$ certutil -L -d /root/.certs</span><br><span class="line"><span class="comment"># 信任证书</span></span><br><span class="line">$ <span class="built_in">cd</span> .certs</span><br><span class="line">$ certutil -A -n <span class="string">"GeoTrust SSL CA - G3"</span> -t <span class="string">"Pu,Pu,Pu"</span>  -d ./ -i 163.crt</span><br></pre></td></tr></table></figure></p><p>💡 参考上面的设置（如果要用qq邮箱，可以把所有的生成证书的163改为qq），同样可以使用 126，163 等邮箱在服务器上通过 SMTP 发送邮件。设置成功以后，服务器上的所有站点，或者其他程序、其他语言开发的站点，都可以直接发送邮件了，是不是很方便？</p><h4 id="再次修改mail-rc"><a href="#再次修改mail-rc" class="headerlink" title="再次修改mail.rc"></a>再次修改mail.rc</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/mail.rc</span><br><span class="line">$ <span class="built_in">set</span> nss-config-dir=/root/.certs/</span><br></pre></td></tr></table></figure><h4 id="测试发送-1"><a href="#测试发送-1" class="headerlink" title="测试发送"></a>测试发送</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mail -s发送邮件 -v可以显示发件的详细信息</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"邮件正文"</span> | mail -s <span class="string">"标题"</span> <span class="string">"annecoding@163.com"</span> </span><br><span class="line">$ mail -s <span class="string">"xxxx"</span> annecoding@163.com &lt; /root/cpu.sh</span><br></pre></td></tr></table></figure><blockquote><p>参考链接：</p><p><a href="https://www.wpzhiku.com/shi-yong-mailx-tong-guo-smtp-zai-centos-shang-fa-song-you-jian/" target="_blank" rel="noopener">使用 Mailx 通过 SMTP 在 Centos 上发送邮件，解决 WordPress 发送邮件问题</a></p><p> <a href="https://www.cnblogs.com/hqqq/p/6261419.html" target="_blank" rel="noopener">mialx配置qq邮箱发送邮件</a></p><p> <a href="https://help.mail.163.com/faqDetail.do?code=d7a5dc8471cd0c0e8b4b8f4f8e49998b374173cfe9171305fa1ce630d7f67ac2cda80145a1742516" target="_blank" rel="noopener">如何开启客户端授权码？</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;今天为大家介绍一个可以直接在 Linux 上使用 SMTP 发送邮件的程序：Mailx，这个程序可以帮助我们让服务器直接支持邮件发送，不用再在每个站点上都设置了。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Centos" scheme="https://annecoding.github.io/tags/Centos/"/>
    
      <category term="mailx" scheme="https://annecoding.github.io/tags/mailx/"/>
    
  </entry>
  
  <entry>
    <title>shell中切分文件名和扩展名</title>
    <link href="https://annecoding.github.io/2019/08/13/shell%E4%B8%AD%E5%88%87%E5%88%86%E6%96%87%E4%BB%B6%E5%90%8D%E5%92%8C%E6%89%A9%E5%B1%95%E5%90%8D/"/>
    <id>https://annecoding.github.io/2019/08/13/shell中切分文件名和扩展名/</id>
    <published>2019-08-13T08:22:49.000Z</published>
    <updated>2019-08-13T08:50:59.385Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>对于shell涉及的修改文件名的操作，我们可能需要提取某个文件名，或者提取某个文件的扩展名。get✔</p><a id="more"></a><h3 id="根据扩展名切分文件名"><a href="#根据扩展名切分文件名" class="headerlink" title="根据扩展名切分文件名"></a>根据扩展名切分文件名</h3><p>截取文件名称示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat file.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">file_jpg=<span class="string">"sample.jpg"</span></span><br><span class="line">name=<span class="variable">$&#123;file_jpg%.*&#125;</span></span><br><span class="line"><span class="built_in">echo</span> File name is:<span class="variable">$name</span></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./file.sh </span><br><span class="line">File name is:sample</span><br></pre></td></tr></table></figure><p>截取文件扩展名示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat file1.sh</span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">file_jpg=<span class="string">"sample.jpg"</span></span><br><span class="line">extension=<span class="variable">$&#123;file_jpg#*.&#125;</span></span><br><span class="line"><span class="built_in">echo</span> Extension is:<span class="variable">$extension</span></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./file1.sh</span><br><span class="line">Extension is:jpg</span><br></pre></td></tr></table></figure><p><code>${VAR%.*}</code>工作原理：</p><ul><li>从<code>$VAR</code>中删除位于<code>%</code>右侧的通配符（在上例中式<code>.*</code>），通配符从右向左进行匹配。</li><li>给<code>VAR</code>赋值，即<code>VAR=sample.jpg</code>，通配符从右向左匹配得到的内容是<code>.jpg</code>，因此从<code>$VAR</code>中删除匹配结果，得到输出结果sample。</li></ul><p>💡 那么，有没有考虑过，要是文件名有很多后缀呢<code>cute.a.b.c.d.txt</code>？要是提取的变量为域名<code>www.google.com</code>呢？有的是办法，往下看~</p><p><strong>%属于非贪婪匹配，它从右向左找出匹配通配符的最短结果。还有另一个操作符%%，它于%相似，但行为模式确是贪婪的，它会匹配符合通配符的最长结果。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明变量var</span></span><br><span class="line">$ var=hack.fun.book.txt</span><br><span class="line"><span class="comment"># 执行从右向左非贪婪匹配，得到的匹配结果为.txt,删除了.txt之后文件名，可以得到具体的文件名</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var%.*&#125;</span></span><br><span class="line">hack.fun.book</span><br><span class="line"><span class="comment"># 执行从右向左贪婪匹配，得到结果.fun.book.txt,删除了.fun.book.txt</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var%%.*&#125;</span></span><br><span class="line">hack</span><br></pre></td></tr></table></figure><p><code>${VAR#*.}</code>工作原理：</p><ul><li>从<code>$VAR</code>中删除位于<code>#</code>右侧的通配符（上个栗子中使用的<code>*.</code>），从左到右匹配字符串。</li><li>和<code>#</code>对应的贪婪操作是<code>##</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从右到左进行非贪婪匹配，得到匹配结果hack，从指定变量中删除匹配结果</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var#*.&#125;</span></span><br><span class="line">fun.book.txt</span><br><span class="line"><span class="comment"># 从右到左进行非贪婪匹配，得到匹配结果hack.fun.book，删除匹配结果后得到扩展名</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var##*.&#125;</span></span><br><span class="line">txt</span><br></pre></td></tr></table></figure><p>💡总结</p><p><strong>文件名中可能包含多个.字符，所以呢</strong></p><p><strong>对于文件名：相较于%%，%更适合于提取文件名。%执行的是非贪婪匹配，只会删除扩展名。</strong></p><p><strong>对于扩展名：相较于#，##更适合于从中提取扩展名。##执行的是贪婪匹配，因此能准确的提取扩展名。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;对于shell涉及的修改文件名的操作，我们可能需要提取某个文件名，或者提取某个文件的扩展名。get✔&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Learning Platform Utilities Recommended</title>
    <link href="https://annecoding.github.io/2019/08/03/%E7%AB%99%E5%A4%96%E5%AD%A6%E4%B9%A0%E5%B9%B3%E5%8F%B0%E5%8F%8A%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    <id>https://annecoding.github.io/2019/08/03/站外学习平台及实用工具推荐/</id>
    <published>2019-08-03T02:11:57.000Z</published>
    <updated>2019-11-27T08:31:52.415Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>这里有关于liunx、python、算法等学习资料，也有非常好用都工具推荐，欢迎入坑。</p><a id="more"></a><h2 id="linux系列"><a href="#linux系列" class="headerlink" title="linux系列"></a>linux系列</h2><h3 id="linux入门"><a href="#linux入门" class="headerlink" title="linux入门"></a>linux入门</h3><ul><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html#" target="_blank" rel="noopener">Linux工具快速教程</a></li><li><a href="http://linux.vbird.org/" target="_blank" rel="noopener">鸟哥的linux私房菜-新</a></li><li><a href="http://cn.linux.vbird.org/" target="_blank" rel="noopener">鸟哥的linux私房菜-旧</a></li></ul><h3 id="linux进阶"><a href="#linux进阶" class="headerlink" title="linux进阶"></a>linux进阶</h3><ul><li><a href="http://billie66.github.io/TLCL/book/" target="_blank" rel="noopener">The Linux Command Line</a></li><li><a href="https://www.server-world.info/en/" target="_blank" rel="noopener">Server World - Build Network Server</a></li><li><a href="http://www.netkiller.cn/" target="_blank" rel="noopener">Netkiller ebook - Linux ebook</a></li></ul><h3 id="linux工具"><a href="#linux工具" class="headerlink" title="linux工具"></a>linux工具</h3><ul><li><a href="https://wangchujiang.com/linux-command/" target="_blank" rel="noopener">Linux命令搜索</a></li><li><a href="https://man.linuxde.net/" target="_blank" rel="noopener">linux命令大全</a></li></ul><h3 id="其他技术干货平台"><a href="#其他技术干货平台" class="headerlink" title="其他技术干货平台"></a>其他技术干货平台</h3><ul><li><a href="http://www.liangxu.co/" target="_blank" rel="noopener">良许linux官方网站</a></li><li><a href="https://mp.weixin.qq.com/s/oI2EqdT7gqkSS5GcTpJICQ" target="_blank" rel="noopener">良许Linux技术干货合集（不断更新中……）</a></li><li><a href="http://wiki.jikexueyuan.com/list/server/" target="_blank" rel="noopener">极客学院全部wiki</a></li><li><a href="https://github.com/justjavac/free-programming-books-zh_CN" target="_blank" rel="noopener">计算机中文编程书籍</a></li></ul><h2 id="python学习"><a href="#python学习" class="headerlink" title="python学习"></a>python学习</h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400" target="_blank" rel="noopener">廖雪峰python教程</a></li><li><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/preface.html" target="_blank" rel="noopener">python3-cookbook简明文档</a></li><li><a href="https://zhuanlan.zhihu.com/p/48961080" target="_blank" rel="noopener">超全Python学习资源整理（入门系列）</a></li><li><a href="https://zhuanlan.zhihu.com/p/49182617" target="_blank" rel="noopener">超全Python学习资源整理（进阶系列）</a></li><li><a href="https://wiki.python.org/moin/BeginnersGuideChinese" target="_blank" rel="noopener">python官方学习文档</a></li></ul><h2 id="算法学习"><a href="#算法学习" class="headerlink" title="算法学习"></a>算法学习</h2><ul><li><a href="https://github.com/MisterBooo/LeetCodeAnimation" target="_blank" rel="noopener">动画超级多的LeetCode算法题目解析</a></li><li><a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">star数超级高的大佬LeetCode算法题目</a></li></ul><h2 id="高质量图片网站"><a href="#高质量图片网站" class="headerlink" title="高质量图片网站"></a>高质量图片网站</h2><ul><li><a href="https://wallhaven.cc/" target="_blank" rel="noopener">超级高质量的网站个人最喜欢的wallhaven</a></li><li><a href="https://www.pexels.com/" target="_blank" rel="noopener">还有这个每天更新100张pexels</a></li><li><a href="https://unsplash.com/" target="_blank" rel="noopener">刷朋友圈一样的支持个人上传的网站unsplash</a></li></ul><h2 id="web实用工具"><a href="#web实用工具" class="headerlink" title="web实用工具"></a>web实用工具</h2><ul><li><a href="https://tinypng.com/" target="_blank" rel="noopener">超级好用的图片无损压缩工具tiny</a></li><li><a href="https://www.ilovepdf.com/zh-cn" target="_blank" rel="noopener">在线pdf转换工具ilovepdf</a></li><li><a href="https://www.hipdf.com/" target="_blank" rel="noopener">在线pdf转换工具hipdf</a></li><li><a href="http://www.mdeditor.com/" target="_blank" rel="noopener">markdown在线编辑器</a></li><li><a href="https://word-to-markdown.herokuapp.com/" target="_blank" rel="noopener">word格式转换为markdown</a></li><li><a href="http://www.tablesgenerator.com/markdown_tables#" target="_blank" rel="noopener">excel格式转换为markdown</a></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li><a href="https://annecoding.github.io/2019/11/21/%E7%AB%99%E7%82%B9%E7%9B%AE%E5%BD%95/">Annecoding’s Studio.</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;这里有关于liunx、python、算法等学习资料，也有非常好用都工具推荐，欢迎入坑。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>监控多台服务器利用率</title>
    <link href="https://annecoding.github.io/2019/07/25/%E7%9B%91%E6%8E%A7%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%A9%E7%94%A8%E7%8E%87/"/>
    <id>https://annecoding.github.io/2019/07/25/监控多台服务器利用率/</id>
    <published>2019-07-25T02:12:15.000Z</published>
    <updated>2019-09-01T04:57:52.968Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>通常，我们可以在linux主机ssh通过密码<strong>交互登录</strong>到远程其他主机。但是，我们在脚本里面不想用交互呢？当然了，ssh给我们提供了一个强大的工具。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">环境：192.168.1.2（监控主机） 192.168.1.3（被监控主机） 192.168.1.4（被监控主机）</span><br></pre></td></tr></table></figure><p>现在要做的是在ssh主机之间免密钥登录，这样才能方便我们下一步使用脚本在直接在本机连接远程主机执行命令。其实就是在监控主机上面生成公钥，然后放到被监控主机上，类似于我们登录github把自己本机的公钥放在github服务器上面一样，这样我们ssh连接的时候就不用总输入密码了。</p><h3 id="免密钥登录"><a href="#免密钥登录" class="headerlink" title="免密钥登录"></a>免密钥登录</h3><p>1.产生公钥对<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在本地机器上使用ssh-keygen产生公钥私钥对</span></span><br><span class="line"><span class="comment"># 在/root根目录下，一直默认，默认存在当前目录下.ssh里面（ll -a）</span></span><br><span class="line">$ ssh-keygen</span><br></pre></td></tr></table></figure></p><p>2.将本机公钥复制到远程要免密登录的机器中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用ssh-copy-id将公钥id_rsa.pub复制到远程机器中，第一次需要输入密码</span></span><br><span class="line"><span class="comment"># 默认将192.168.1.2的公钥存放在/root根目录下的.ssh里面authorized_keys</span></span><br><span class="line">$ ssh root@192.168.1.3</span><br><span class="line">$ ssh root@192.168.1.4</span><br></pre></td></tr></table></figure></p><p>3.免密连接远程主机执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh root@192.168.1.3</span><br><span class="line">$ ssh root@192.168.1.4 <span class="string">'df -h'</span></span><br></pre></td></tr></table></figure></p><h3 id="监控服务器利用率"><a href="#监控服务器利用率" class="headerlink" title="监控服务器利用率"></a>监控服务器利用率</h3><p>好了，现在基础环境已经做好了，磁盘使用情况可以用<code>df -h</code>来查询，脚本实现如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ cat disk_availabile.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 监控多台服务器利用率</span></span><br><span class="line"><span class="comment"># 将需要监控的服务器信息存储在host.info中，IP地址 用户 端口号</span></span><br><span class="line">HOST_INFO=host.info</span><br><span class="line"><span class="comment"># 逐行匹配，不匹配注释（以#开头）</span></span><br><span class="line"><span class="keyword">for</span> IP <span class="keyword">in</span> $(awk <span class="string">'/^[^#]/&#123;print $1&#125;'</span> <span class="variable">$HOST_INFO</span>);<span class="keyword">do</span></span><br><span class="line"> <span class="comment"># awk -v 在shell中使用变量，以ip为基准匹配，匹配到了取出用户</span></span><br><span class="line">        USER=`awk -v ip=<span class="variable">$IP</span> <span class="string">'ip==$1&#123;print $2&#125;'</span> <span class="variable">$HOST_INFO</span>`</span><br><span class="line">        PORT=`awk -v ip=<span class="variable">$IP</span> <span class="string">'ip==$1&#123;print $3&#125;'</span> <span class="variable">$HOST_INFO</span>`</span><br><span class="line">        TMP_FILE=/tmp/disk.tmp</span><br><span class="line">        <span class="comment"># 将连接到远程主机的信息暂时存入文件中</span></span><br><span class="line">        ssh -p <span class="variable">$PORT</span> <span class="variable">$USER</span>@<span class="variable">$IP</span> <span class="string">'df -h'</span> &gt; <span class="variable">$TMP_FILE</span></span><br><span class="line">        <span class="comment"># 取出挂载点并添加分隔符=  </span></span><br><span class="line">        <span class="comment"># int($5) 去除百分比以方便后面做判断 /=5</span></span><br><span class="line">        USE_PART_LIST=`awk <span class="string">'BEGIN&#123;OFS="="&#125;/^\/dev/&#123;print $NF,int($5)&#125;'</span> <span class="variable">$TMP_FILE</span>`</span><br><span class="line">        <span class="comment"># 取挂载点和利用率</span></span><br><span class="line">        <span class="keyword">for</span> USE_RATE <span class="keyword">in</span> <span class="variable">$USE_PART_LIST</span>;<span class="keyword">do</span></span><br><span class="line">                <span class="comment"># 挂载点 匹配到=右边的 /</span></span><br><span class="line">                PART_NAME=<span class="variable">$&#123;USE_RATE%=*&#125;</span></span><br><span class="line">                <span class="comment"># 使用率 匹配到=左边的 5</span></span><br><span class="line">                USE_RATE=<span class="variable">$&#123;USE_RATE#*=&#125;</span></span><br><span class="line">                <span class="keyword">if</span> [ <span class="variable">$USE_RATE</span> -ge 80 ]; <span class="keyword">then</span></span><br><span class="line">                        <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$IP</span> \n Warning: <span class="variable">$PART_NAME</span> Partition usage <span class="variable">$USE_RATE</span>%!"</span></span><br><span class="line">                <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat host.info </span><br><span class="line">192.168.1.3 root 22</span><br><span class="line">$ ./disk_availabile.sh</span><br><span class="line">192.168.1.3 </span><br><span class="line"> Warning: / Partition usage 86%!</span><br><span class="line">192.168.1.3 </span><br><span class="line"> Warning: /dev/sda2 Partition usage 88%!</span><br><span class="line">192.168.1.4</span><br><span class="line"> Warning: / Partition usage 89%!</span><br><span class="line">192.168.1.4 </span><br><span class="line"> Warning: /dev/vda1 Partition usage 92%!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;通常，我们可以在linux主机ssh通过密码&lt;strong&gt;交互登录&lt;/strong&gt;到远程其他主机。但是，我们在脚本里面不想用交互呢？当然了，ssh给我们提供了一个强大的工具。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Centos" scheme="https://annecoding.github.io/tags/Centos/"/>
    
      <category term="shell" scheme="https://annecoding.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>mtr网络分析工具安装</title>
    <link href="https://annecoding.github.io/2019/07/24/mtr%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/"/>
    <id>https://annecoding.github.io/2019/07/24/mtr网络分析工具安装/</id>
    <published>2019-07-24T08:00:54.000Z</published>
    <updated>2019-08-03T01:19:07.801Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>遇到了安装完成mtr以后命令不能使用的情况，因为环境变量的配置问题！！！</p><a id="more"></a><p>mtr网络分析工具安装</p><p>1.首先保证安装brew工具</p><p>2.执行<code>brew cask mtr</code>进行软件安装</p><p>3.配置PATH变量 <code>vim ~/.bash_profile</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/sbin</span><br></pre></td></tr></table></figure><p>4.配置文件生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><p>5.安装完以后在<code>usr/local/sbin</code>目录下，第一次执行可以执行，再打开窗口就不行，环境变量只生效了一次。</p><p>再次打开新的窗口就发现不能使用了，输入<code>mtr</code>命令发现不能运行，提示如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtr: mtr should not run suid</span><br></pre></td></tr></table></figure><p>再次查看环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 内容如下</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin:/usr/bin:/bin:/usr/sbin:/sbin</span><br></pre></td></tr></table></figure><p>果然，没有<code>usr/local/sbin</code></p><p>6.此时有两种解决方案： </p><p>第一种解决方案，建立软链接，将所安装的mtr指令软链接到系统找得到的目录下，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/sbin/mtr* /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure><p>第二种解决方案，修改/etc/paths的path文件，添加。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/paths </span><br><span class="line">在最后一行添加：/usr/<span class="built_in">local</span>/sbin，此修改重新启动程序便会生效。</span><br></pre></td></tr></table></figure><p>7.使用mtr命令必须是root权限，当然也可以修改目录权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mtr www.baidu.com</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;遇到了安装完成mtr以后命令不能使用的情况，因为环境变量的配置问题！！！&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="mtr" scheme="https://annecoding.github.io/tags/mtr/"/>
    
  </entry>
  
  <entry>
    <title>mac下如何修改环境变量</title>
    <link href="https://annecoding.github.io/2019/07/24/mac%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>https://annecoding.github.io/2019/07/24/mac下如何修改环境变量/</id>
    <published>2019-07-24T08:00:33.000Z</published>
    <updated>2019-07-28T01:39:28.265Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>mac下环境变量到底该修改哪个文件呢？？？黑人问号脸，所以，一起来揭穿它神秘的面纱吧。<br><a id="more"></a></p><p>mac下一般使用bash作为默认shell</p><p>mac系统的环境变量，加载顺序为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc</span><br></pre></td></tr></table></figure><p>当然<code>/etc/profile</code>和<code>/etc/paths</code>是系统级别的，系统启动就会加载，后面几个是当前用户级的环境变量。</p><p>后面3个按照从前往后的顺序读取，如果<code>/.bash_profile</code>文件存在，则后面的几个文件就会被忽略不读了，如果<code>~/.bash_profile</code>文件不存在，才会以此类推读取后面的文件。</p><p><code>~/.bashrc</code>没有上述规则，它是<code>bash shell</code>打开的时候载入的。</p><p>如果没特殊说明,设置PATH的语法都为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#中间用冒号隔开 </span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:------:&lt;PATH N&gt;</span><br></pre></td></tr></table></figure><h3 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h3><p>下面的几个文件设置是全局的,修改时需要root权限</p><p>1、<code>/etc/paths</code> （全局建议修改这个文件 ）</p><p>编辑 <code>/etc/paths</code>，将环境变量添加到<code>/etc/paths</code>文件中 ，一行一个路径</p><p>Hint：输入环境变量时，不用一个一个地输入，只要拖动文件夹到 Terminal 里就可以了。</p><p>2、<code>/etc/profile</code>（建议不修改这个文件 ）全局（公有）配置，不管是哪个用户，登录时都会读取该文件。</p><p>3、<code>/etc/bashrc</code>（一般在这个文件中添加系统级环境变量）全局（公有）配置，bash shell执行时，不管是何种方式，都会读取此文件。</p><p>4、这条是什么鬼，先放着hhh~~~~👻</p><p>1.创建一个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo touch /etc/paths.d/mysql</span><br></pre></td></tr></table></figure><p>2.用 vim 打开这个文件（如果是以 open -t 的方式打开，则不允许编辑）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/paths.d/mysql</span><br></pre></td></tr></table></figure><p>3.编辑该文件，键入路径并保存（关闭该 Terminal 窗口并重新打开一个，就能使用 mysql 命令了）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/mysql/bin</span><br></pre></td></tr></table></figure><p>据说，这样可以自己生成新的文件，不用把变量全都放到 paths 一个文件里，方便管理。</p><h3 id="单个用户设置"><a href="#单个用户设置" class="headerlink" title="单个用户设置"></a>单个用户设置</h3><p>1、<code>~/.bash_profile</code> （任意一个文件中添加用户级环境变量）</p><p>（注：Linux 里面是<code>.bashrc</code> 而 Mac 是 <code>.bash_profile</code>）</p><p>若<code>bash shell</code>是以login方式执行时，才会读取此文件。该文件仅仅执行一次!默认情况下,他设置一些环境变量</p><p>设置命令别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> ll=’ls -la’</span><br></pre></td></tr></table></figure><p>设置环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/opt/<span class="built_in">local</span>/bin:/opt/<span class="built_in">local</span>/sbin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>2、<code>~/.bashrc</code>同上</p><p>如果想立刻生效，则可执行下面的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source 相应的文件</span><br></pre></td></tr></table></figure><p>一般环境变量更改后，重启程序后生效。</p><blockquote><p>参考：</p><p><a href="https://segmentfault.com/q/1010000008484965/a-1020000008485621" target="_blank" rel="noopener">MAC OS中修改环境变量到底应该修改哪个文件</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;mac下环境变量到底该修改哪个文件呢？？？黑人问号脸，所以，一起来揭穿它神秘的面纱吧。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mac" scheme="https://annecoding.github.io/categories/Mac/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Mac" scheme="https://annecoding.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>linux安装hping添加环境变量</title>
    <link href="https://annecoding.github.io/2019/07/20/linux%E5%AE%89%E8%A3%85hping%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>https://annecoding.github.io/2019/07/20/linux安装hping添加环境变量/</id>
    <published>2019-07-20T11:06:59.000Z</published>
    <updated>2019-07-24T09:03:16.493Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>当我试图去安装hping的时候，出现了一些些问题，明明已经安装，但是却不能使用，后来发现是环境变量没有配置上。<br><a id="more"></a></p><p>在mac下通过brew安装hping<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install hping</span><br></pre></td></tr></table></figure></p><p>查看已安装列表…找到如下一列<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew list</span><br><span class="line">.... ... .... hping ... .... ...</span><br></pre></td></tr></table></figure></p><p>然而,当我运行hping时…<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hping</span><br><span class="line">zsh: <span class="built_in">command</span> not found: hping</span><br></pre></td></tr></table></figure></p><p>再次查看安装信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ brew info hping</span><br><span class="line">hping: stable 3.20051105</span><br><span class="line">http://www.hping.org/</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/hping/3.20051105 (9 files, 196K) *</span><br><span class="line">  Built from <span class="built_in">source</span></span><br><span class="line">From: https://github.com/Homebrew/homebrew/blob/master/Library/Formula/hping.rb</span><br></pre></td></tr></table></figure></p><p>emmm…得出结论，安装了hping却不能使用<br>将<code>/usr/local/sbin</code>添加到<code>$PATH</code>,<br>因为hping二进制文件安装在<code>/usr/local/sbin</code>中,而不是安装在<code>/usr/local/bin</code>中。</p><p><strong>解决方案</strong></p><p>在终端中输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/sbin</span><br></pre></td></tr></table></figure></p><p>哦对了 等号之间不能有空格</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;当我试图去安装hping的时候，出现了一些些问题，明明已经安装，但是却不能使用，后来发现是环境变量没有配置上。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mac" scheme="https://annecoding.github.io/categories/Mac/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Mac" scheme="https://annecoding.github.io/tags/Mac/"/>
    
      <category term="hping" scheme="https://annecoding.github.io/tags/hping/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu修改IP地址</title>
    <link href="https://annecoding.github.io/2019/07/20/ubuntu%E4%BF%AE%E6%94%B9IP%E5%9C%B0%E5%9D%80/"/>
    <id>https://annecoding.github.io/2019/07/20/ubuntu修改IP地址/</id>
    <published>2019-07-20T10:59:03.000Z</published>
    <updated>2019-07-28T01:42:55.801Z</updated>
    
    <content type="html"><![CDATA[<!-- <meta name="referrer" content="no-referrer" /> --><p>ubuntu修改静态ip地址需要单独设置DNS，这个要注意一下哦。<br><a id="more"></a></p><h3 id="ubuntu修改ip地址"><a href="#ubuntu修改ip地址" class="headerlink" title="ubuntu修改ip地址"></a>ubuntu修改ip地址</h3><h4 id="ubuntu16-04修改IP地址"><a href="#ubuntu16-04修改IP地址" class="headerlink" title="ubuntu16.04修改IP地址"></a>ubuntu16.04修改IP地址</h4><p>1、修改网卡配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sudo  vi /etc/network/interfaces</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到其中以下几行进行修改</span></span><br><span class="line">auto ens123</span><br><span class="line">iface ens123 inet static</span><br><span class="line">        address 10.10.133.233</span><br><span class="line">        netmask 255.255.255.0</span><br><span class="line">        network 10.10.133.0</span><br><span class="line">        broadcast 10.10.133.255</span><br><span class="line">        gateway 10.10.133.254</span><br><span class="line">        <span class="comment"># dns-* options are implemented by the resolvconf package, if installed</span></span><br><span class="line">        dns-nameservers 8.8.8.8</span><br></pre></td></tr></table></figure><p>2、修改DNS配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi + /etc/resolvconf/resolv.conf.d/head</span><br><span class="line"><span class="comment"># 在文件最后添加一句话</span></span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>3、重启网卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo /etc/init.d/networking restart</span><br></pre></td></tr></table></figure><h4 id="ubuntu18-04修改ip地址"><a href="#ubuntu18-04修改ip地址" class="headerlink" title="ubuntu18.04修改ip地址"></a>ubuntu18.04修改ip地址</h4><p>1、修改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/netplan/50-cloud-init.yaml</span><br><span class="line"><span class="comment"># 修改以下内容</span></span><br><span class="line">network:</span><br><span class="line">    ethernets:</span><br><span class="line">        eth0:</span><br><span class="line">            addresses:</span><br><span class="line">            - 192.168.15.72/20</span><br><span class="line">            gateway4: 192.168.12.2</span><br><span class="line">            nameservers:</span><br><span class="line">                addresses:</span><br><span class="line">                - 223.5.5.5</span><br><span class="line">                search: []</span><br><span class="line">            optional: <span class="literal">true</span></span><br><span class="line">    version: 2</span><br></pre></td></tr></table></figure><p>2、使配置生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netplan apply</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; --&gt;
&lt;p&gt;ubuntu修改静态ip地址需要单独设置DNS，这个要注意一下哦。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://annecoding.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>linux系统扫描命令和安全防范笔记</title>
    <link href="https://annecoding.github.io/2019/07/20/linux%E7%B3%BB%E7%BB%9F%E6%89%AB%E6%8F%8F%E5%91%BD%E4%BB%A4%E5%92%8C%E5%AE%89%E5%85%A8%E9%98%B2%E8%8C%83%E7%AC%94%E8%AE%B0/"/>
    <id>https://annecoding.github.io/2019/07/20/linux系统扫描命令和安全防范笔记/</id>
    <published>2019-07-20T09:21:31.000Z</published>
    <updated>2019-07-28T01:40:42.649Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>本文主要介绍了一些常用的网络扫描工具以及安全防范，了解更多命令的使用。<br><a id="more"></a></p><h3 id="linux系统扫描命令和安全防范笔记"><a href="#linux系统扫描命令和安全防范笔记" class="headerlink" title="linux系统扫描命令和安全防范笔记"></a><strong>linux系统扫描命令和安全防范笔记</strong></h3><p>通过网络入侵来窃取敏感信息</p><p>通过网络扫描获取运营商核心设备的管理权限</p><h3 id="网络入侵方式"><a href="#网络入侵方式" class="headerlink" title="网络入侵方式"></a><strong>网络入侵方式</strong></h3><p>踩点-网络扫描-差点-提权</p><p><strong>常用命令</strong></p><p>tracert/traceroute、namp、nc</p><h3 id="主机扫描命令fping"><a href="#主机扫描命令fping" class="headerlink" title="主机扫描命令fping"></a><strong>主机扫描命令fping</strong></h3><p>批量的给目标主机发送ping请求，测试主机的存活情况。</p><p>特点：并行发送，结果易读</p><p><strong>源码包编译过程</strong></p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g54yozizhcj30yg0lign8.jpg" alt="image-20190719105646797"></p><p>fping编译安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># wget https://fping.org/dist/fping-4.2.tar.gz</span></span><br><span class="line">[root@localhost ~]<span class="comment"># tar -xvf fping-4.2.tar.gz </span></span><br><span class="line">[root@localhost fping-4.2]<span class="comment"># ./configure &amp; make &amp; make install</span></span><br><span class="line">[root@localhost fping-4.2]<span class="comment"># fping -h  #查看帮助命令</span></span><br><span class="line">[root@localhost fping-4.2]<span class="comment"># fping -v</span></span><br><span class="line">fping: Version 4.2</span><br><span class="line">fping: comments to david@schweikert.ch</span><br></pre></td></tr></table></figure><h4 id="fping参数介绍"><a href="#fping参数介绍" class="headerlink" title="fping参数介绍"></a><strong>fping参数介绍</strong></h4><p>命令参数man、-h方式</p><p>常用参数：</p><p>-a 只显示出存活的主机(相反参数-u)</p><p>-l 循环ping</p><p>1、通过标准输入方式fping+IP1+IP2</p><p>-g 支持主机段的方式 192.168.1.1 192.168.1.255 192.168.1.0/24</p><p>2、通过读取一个文件中的IP内容</p><p>方式：fping -f filename</p><p>3、fping使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找存货的主机</span></span><br><span class="line">fping -a 10.10.163.233</span><br><span class="line"><span class="comment"># 可以查找某个网段内存活的主机</span></span><br><span class="line">fping  -g -a 10.10.163.1 10.10.163.254</span><br><span class="line"><span class="comment"># 查找某个网段内存活主机第二种写法</span></span><br><span class="line">fping -a -g 10.10.163.233/24</span><br></pre></td></tr></table></figure><h3 id="主机扫描命令hping"><a href="#主机扫描命令hping" class="headerlink" title="主机扫描命令hping"></a><strong>主机扫描命令hping</strong></h3><p>支持使用tcp/ip数据包组装、分析工具</p><p>linux下编译安装</p><p>如果遇到如下错误</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g556megt3vj30oi04et9c.jpg" alt="image-20190719153110732"></p><p>可通过安装下面库解决</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g556sceynmj30ji09274q.jpg" alt="image-20190719153652881"></p><p><a href="http://rpmfind.net/" target="_blank" rel="noopener">http://rpmfind.net/</a></p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g556pk21f9j30xy082do7.jpg" alt="image-20190719153414670"></p><h4 id="hping常用参数"><a href="#hping常用参数" class="headerlink" title="hping常用参数"></a><strong>hping常用参数</strong></h4><p>1、对特定的目标发起tcp探测（规避运营商防火墙、主机等对icmp包屏蔽）</p><p>-p 端口tcp</p><p>-S 设置TCP模式SYN包</p><p>2、伪造来源IP，模拟Ddos攻击</p><p>-a 伪造IP地址</p><p>3、hping使用 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo hping -p 22 -S 10.10.163.233</span><br><span class="line"></span><br><span class="line">sudo hping -p 22 -S 10.10.163.233 -a 10.10.163.235</span><br></pre></td></tr></table></figure><p> centos拒绝掉icmp包设置</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g56489gypsj30kg01mwei.jpg" alt="image-20190720105353473"></p><h3 id="路由扫描"><a href="#路由扫描" class="headerlink" title="路由扫描"></a><strong>路由扫描</strong></h3><p>作用：查询一个主机经过的路由的跳数、及数据延迟情况</p><p>常用工具：traceroute、mtr</p><p>mtr特点：能测出主机到每一个路由间的联通性。</p><p>traceroute连接原理。</p><p>linux下发送udp包（&gt;30000端口），windows发送icmp包。</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g564xl90vhj30pk0i23zb.jpg" alt="image-20190720111813791"></p><p>TTL，生存时间的值。发给第一跳，ttl-1=0，返回udp数据包。</p><p>扫描到几个路由器，发送几个ttl数据包。</p><h4 id="traceroute参数的使用"><a href="#traceroute参数的使用" class="headerlink" title="traceroute参数的使用"></a><strong>traceroute参数的使用</strong></h4><p> linux一般默认有，如果没有安装方式</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5657hwwdpj30mi03gjru.jpg" alt="image-20190720112746947"></p><p>1、默认使用的是udp协议(30000以上的端口)</p><p>2、支持使用TCP协议 -T(发送tcp协议) -p(基于tcp什么端口)</p><p>3、使用ICMP协议介绍 -I </p><p>4、traceroute使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">traceroute www.baidu.com</span><br><span class="line"><span class="comment"># -n 去掉解析</span></span><br><span class="line">traceroute -n www.baidu.com </span><br><span class="line"><span class="comment"># 使用icmp，window默认使用</span></span><br><span class="line">traceroute -In  www.imooc.com</span><br><span class="line"><span class="comment"># 使用tcp才能检测到最终跳数(一般会屏蔽icmp协议)</span></span><br><span class="line">traceroute -T -p 80 -n www.imooc.com</span><br></pre></td></tr></table></figure><h4 id="mtr使用"><a href="#mtr使用" class="headerlink" title="mtr使用"></a>mtr使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum install mtr -y</span><br><span class="line"><span class="comment"># 使用，原理和traceroute一样，可以看到到哪一跳丢包率更为严重</span></span><br><span class="line">mtr www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="批量主机扫描"><a href="#批量主机扫描" class="headerlink" title="批量主机扫描"></a><strong>批量主机扫描</strong></h3><p>目的：</p><p>1、批量主机存活扫描</p><p>2、针对主机服务扫描</p><p>作用：</p><p>1、能快捷的获取主机的存活状态</p><p>2、能更加细致、只能获取主机服务侦查情况</p><p><strong>典型命令</strong></p><p>1、nmap 基于端口扫描，特别强大</p><p>2、ncat 瑞士军刀</p><h4 id="nmap使用"><a href="#nmap使用" class="headerlink" title="nmap使用"></a><strong>nmap使用</strong></h4><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g56dmqgtktj30v60f8dhb.jpg" alt="image-20190720161913675"></p><p>tcp半开放，不建立完整的tcp，未建立完整的三次握手。</p><p>1、主机存活扫描</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 扫描主机存活状态,s检测用什么协议做侦测</span></span><br><span class="line">namp -sP 10.10.140.0/24</span><br></pre></td></tr></table></figure><p>2、主机端口开放扫描，默认扫描范围1-1024，以及一些常用的服务端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namp -sS 10.10.10.163.233</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g56dzj5o2kj30mq0ae400.jpg" alt="image-20190720163117782"></p><p>3、半开放指定端口扫描</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namp -sS -p 0-30000 10.10.163.233</span><br></pre></td></tr></table></figure><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g56e6peru2j30nw0a0t9w.jpg" alt="image-20190720163823202"></p><p>4、全开放连接参数，建立一次全握手，时间长</p><p>建立全握手，可以模拟用户的真实操作请求，需要服务端能检测到相关的日志，打印出相关记录信息。</p><p>建议日常使用半扫描模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sT -p 0-30000 10.10.163.233</span><br></pre></td></tr></table></figure><p> 5、udp协议扫描方式</p><p>扫描udp，响应比较慢、可能特别慢。会限制icmp不可达返回的次数。不建议使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sU 10.10.163.233</span><br></pre></td></tr></table></figure><h4 id="ncat使用"><a href="#ncat使用" class="headerlink" title="ncat使用"></a><strong>ncat使用</strong></h4><p>查看某个路由开放哪些端口80 23</p><p>通过shell交互更改数据 ，可进行任意操作</p><p>nc -lvp 2005 监听端口</p><p><strong>nc好处</strong></p><p>1、不会频繁通过界面登录留下痕迹</p><p>2、登录非常方便</p><p>3、不会被侦测设备侦测到</p><p>-w 设置的超市时间</p><p>-z 一个输入输出模式</p><p>-v 显示命令执行过程</p><p>1、基于tcp协议(默认)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看22端口开放情况</span></span><br><span class="line">nc -zv 10.10.163.233 22</span><br><span class="line"><span class="comment"># 查看一些端口开放 超时2s</span></span><br><span class="line">nc -zv -w2 10.10.163.233 1-50</span><br></pre></td></tr></table></figure><p>2、基于udp协议 -u  </p><p>回应时间长，不建议使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看一些端口开放 超时2s</span></span><br><span class="line">nc -zv -u -w2 10.10.163.233 1-50</span><br></pre></td></tr></table></figure><h3 id="预防策略"><a href="#预防策略" class="headerlink" title="预防策略"></a><strong>预防策略</strong></h3><p>在linux进行防御。</p><p>常见攻击方法：</p><p>1、SYN攻击</p><p>2、DDoS攻击</p><p>3、恶意扫描</p><p>什么是SYN攻击？</p><p>利用TCP协议缺陷进行，导致系统服务停止响应，网络带宽跑满或者响应缓慢。</p><p>什么是DDoS攻击？</p><p>分布式拒绝访问服务攻击。</p><p>正常服务在同一时间接到了很多个类似于正常服务的请求，也有可能是完全正常的请求，导致服务响应不过来。</p><p>SYN攻击一般会伴随着DDoS攻击进行</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g56eutfdydj30qq0ikgmc.jpg" alt="image-20190720170129641"></p><p>SYN攻击原理，eg可以利用hping伪造源ip，发送给假的主机，得不到第三次请求。目标机器不断发送重试，不停回应包，就会导致网络带宽占满。</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g56f1z4xe1j30og0iuq3m.jpg" alt="image-20190720170357218"></p><ul><li><p>减少重试次数</p></li><li><p>可以增加backlog</p></li><li><p>禁止三次握手，SYN cookies技术</p></li></ul><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g56f1r9lamj30m40c40x8.jpg" alt="image-20190720170816652"></p><p>linux下其他预防策略</p><p>1、防火墙上面做相关设置</p><p>2、linux下面可以关闭icmp协议请求</p><p>3、通过iptables防止扫描</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g56f53ibkej30xc0bqmyd.jpg" alt="image-20190720171122849"></p><blockquote><p>学习笔记整理自慕课网以下课程:<br>linux系统扫描命令和安全防范笔记</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;本文主要介绍了一些常用的网络扫描工具以及安全防范，了解更多命令的使用。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://annecoding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://annecoding.github.io/tags/Linux/"/>
    
      <category term="hping" scheme="https://annecoding.github.io/tags/hping/"/>
    
      <category term="traceroute" scheme="https://annecoding.github.io/tags/traceroute/"/>
    
      <category term="Nmap" scheme="https://annecoding.github.io/tags/Nmap/"/>
    
      <category term="Ncap" scheme="https://annecoding.github.io/tags/Ncap/"/>
    
      <category term="fping" scheme="https://annecoding.github.io/tags/fping/"/>
    
  </entry>
  
</feed>
